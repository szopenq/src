; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	A:\From C\Desktop\Serwer\Source\Source Client\client\GameLib\MapOutdoorUpdate.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	_sqrtf
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0D3DXVECTOR2@@QAE@XZ				; D3DXVECTOR2::D3DXVECTOR2
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??XD3DXVECTOR3@@QAEAAU0@M@Z			; D3DXVECTOR3::operator*=
PUBLIC	??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator+
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator-
PUBLIC	??D@YA?AUD3DXVECTOR3@@MABU0@@Z			; operator*
PUBLIC	?D3DXVec2Dot@@YAMPBUD3DXVECTOR2@@0@Z		; D3DXVec2Dot
PUBLIC	?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z		; D3DXVec3Length
PUBLIC	?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z	; D3DXVec3LengthSq
PUBLIC	?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ ; CSingleton<CTimer>::Instance
PUBLIC	??0CDynamicSphereInstance@@QAE@XZ		; CDynamicSphereInstance::CDynamicSphereInstance
PUBLIC	??0Vector3d@@QAE@XZ				; Vector3d::Vector3d
PUBLIC	?Set@Vector3d@@QAEXMMM@Z			; Vector3d::Set
PUBLIC	?GetEye@CCamera@@QBEABUD3DXVECTOR3@@XZ		; CCamera::GetEye
PUBLIC	?GetTarget@CCamera@@QBEABUD3DXVECTOR3@@XZ	; CCamera::GetTarget
PUBLIC	?GetView@CCamera@@QBEABUD3DXVECTOR3@@XZ		; CCamera::GetView
PUBLIC	?GetDistance@CCamera@@QBEMXZ			; CCamera::GetDistance
PUBLIC	?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ ; CSingleton<CCameraManager>::Instance
PUBLIC	??0SpherePackCallback@@QAE@XZ			; SpherePackCallback::SpherePackCallback
PUBLIC	??1SpherePackCallback@@UAE@XZ			; SpherePackCallback::~SpherePackCallback
PUBLIC	?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::VisibilityCallback
PUBLIC	?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ; SpherePackCallback::RayTraceCallback
PUBLIC	?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::RangeTestCallback
PUBLIC	?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::PointTest2dCallback
PUBLIC	??_GSpherePackCallback@@UAEPAXI@Z		; SpherePackCallback::`scalar deleting destructor'
PUBLIC	?GetUserData@SpherePack@@QBEPAXXZ		; SpherePack::GetUserData
PUBLIC	?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ ; CSingleton<CCullingManager>::Instance
PUBLIC	?RangeTest@CCullingManager@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; CCullingManager::RangeTest
PUBLIC	??0?$allocator@PAVCGraphicObjectInstance@@@std@@QAE@XZ ; std::allocator<CGraphicObjectInstance *>::allocator<CGraphicObjectInstance *>
PUBLIC	?deallocate@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEXPAPAVCGraphicObjectInstance@@I@Z ; std::allocator<CGraphicObjectInstance *>::deallocate
PUBLIC	?allocate@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEPAPAVCGraphicObjectInstance@@I@Z ; std::allocator<CGraphicObjectInstance *>::allocate
PUBLIC	?construct@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEXPAPAVCGraphicObjectInstance@@ABQAV3@@Z ; std::allocator<CGraphicObjectInstance *>::construct
PUBLIC	?max_size@?$allocator@PAVCGraphicObjectInstance@@@std@@QBEIXZ ; std::allocator<CGraphicObjectInstance *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@SAIABV?$allocator@PAVCGraphicObjectInstance@@@2@@Z ; std::allocator_traits<std::allocator<CGraphicObjectInstance *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEPAPAVCGraphicObjectInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXPAPAVCGraphicObjectInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> >::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicObjectInstance@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> > >::_Getal
PUBLIC	??0?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >
PUBLIC	??1?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::~vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >
PUBLIC	?capacity@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::begin
PUBLIC	?end@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::end
PUBLIC	?size@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::size
PUBLIC	?max_size@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::max_size
PUBLIC	?push_back@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXABQAVCGraphicObjectInstance@@@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::push_back
PUBLIC	?clear@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXPAPAVCGraphicObjectInstance@@0@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBEII@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBE_NPBQAVCGraphicObjectInstance@@@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXXZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBEXXZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBEXPAPAVCGraphicObjectInstance@@0@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Orphan_range
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEABQAVCGraphicObjectInstance@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator++
PUBLIC	??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator-
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
PUBLIC	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAEAAV12@PAPAVCGraphicObjectInstance@@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Rechecked
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicObjectInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Unchecked
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEAAPAVCGraphicObjectInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator++
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator-
PUBLIC	?Instance@?$CSingleton@VCSpeedTreeForestDirectX8@@@@SAAAVCSpeedTreeForestDirectX8@@XZ ; CSingleton<CSpeedTreeForestDirectX8>::Instance
PUBLIC	?select_on_container_copy_construction@?$allocator@PAVCArea@@@std@@QBE?AV12@XZ ; std::allocator<CArea *>::select_on_container_copy_construction
PUBLIC	??0?$allocator@PAVCArea@@@std@@QAE@XZ		; std::allocator<CArea *>::allocator<CArea *>
PUBLIC	??0?$allocator@PAVCArea@@@std@@QAE@ABV01@@Z	; std::allocator<CArea *>::allocator<CArea *>
PUBLIC	?deallocate@?$allocator@PAVCArea@@@std@@QAEXPAPAVCArea@@I@Z ; std::allocator<CArea *>::deallocate
PUBLIC	?allocate@?$allocator@PAVCArea@@@std@@QAEPAPAVCArea@@I@Z ; std::allocator<CArea *>::allocate
PUBLIC	?construct@?$allocator@PAVCArea@@@std@@QAEXPAPAVCArea@@ABQAV3@@Z ; std::allocator<CArea *>::construct
PUBLIC	?max_size@?$allocator@PAVCArea@@@std@@QBEIXZ	; std::allocator<CArea *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SAIABV?$allocator@PAVCArea@@@2@@Z ; std::allocator_traits<std::allocator<CArea *> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SA?AV?$allocator@PAVCArea@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<CArea *> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<CArea *> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CArea *> >::_Wrap_alloc<std::allocator<CArea *> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAE@ABV?$allocator@PAVCArea@@@1@@Z ; std::_Wrap_alloc<std::allocator<CArea *> >::_Wrap_alloc<std::allocator<CArea *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@I@Z ; std::_Wrap_alloc<std::allocator<CArea *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEXPAPAVCArea@@I@Z ; std::_Wrap_alloc<std::allocator<CArea *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CArea *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CArea *> >::_Vector_val<std::_Simple_types<CArea *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCArea@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CArea *,std::allocator<CArea *> > >::_Vector_alloc<0,std::_Vec_base_types<CArea *,std::allocator<CArea *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CArea *,std::allocator<CArea *> > >::_Getal
PUBLIC	??0?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ ; std::vector<CArea *,std::allocator<CArea *> >::vector<CArea *,std::allocator<CArea *> >
PUBLIC	??0?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CArea *,std::allocator<CArea *> >::vector<CArea *,std::allocator<CArea *> >
PUBLIC	??1?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ ; std::vector<CArea *,std::allocator<CArea *> >::~vector<CArea *,std::allocator<CArea *> >
PUBLIC	?capacity@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ ; std::vector<CArea *,std::allocator<CArea *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ ; std::vector<CArea *,std::allocator<CArea *> >::begin
PUBLIC	?begin@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ ; std::vector<CArea *,std::allocator<CArea *> >::begin
PUBLIC	?end@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ ; std::vector<CArea *,std::allocator<CArea *> >::end
PUBLIC	?end@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ ; std::vector<CArea *,std::allocator<CArea *> >::end
PUBLIC	?_Make_iter@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Make_iter
PUBLIC	?resize@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXI@Z ; std::vector<CArea *,std::allocator<CArea *> >::resize
PUBLIC	?size@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ ; std::vector<CArea *,std::allocator<CArea *> >::size
PUBLIC	?max_size@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ ; std::vector<CArea *,std::allocator<CArea *> >::max_size
PUBLIC	?empty@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE_NXZ ; std::vector<CArea *,std::allocator<CArea *> >::empty
PUBLIC	??A?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEAAPAVCArea@@I@Z ; std::vector<CArea *,std::allocator<CArea *> >::operator[]
PUBLIC	?push_back@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXABQAVCArea@@@Z ; std::vector<CArea *,std::allocator<CArea *> >::push_back
PUBLIC	?erase@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@@Z ; std::vector<CArea *,std::allocator<CArea *> >::erase
PUBLIC	?_Pop_back_n@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXI@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Pop_back_n
PUBLIC	?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::clear
PUBLIC	?_Buy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAE_NI@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Buy
PUBLIC	?_Destroy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXPAPAVCArea@@0@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBEII@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBE_NPBQAVCArea@@@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXI@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXI@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBEXPAPAVCArea@@0@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Orphan_range
PUBLIC	?GetMinX@CTerrainPatch@@QAEMXZ			; CTerrainPatch::GetMinX
PUBLIC	?GetMaxX@CTerrainPatch@@QAEMXZ			; CTerrainPatch::GetMaxX
PUBLIC	?GetMinY@CTerrainPatch@@QAEMXZ			; CTerrainPatch::GetMinY
PUBLIC	?GetMaxY@CTerrainPatch@@QAEMXZ			; CTerrainPatch::GetMaxY
PUBLIC	?GetMinZ@CTerrainPatch@@QAEMXZ			; CTerrainPatch::GetMinZ
PUBLIC	?GetMaxZ@CTerrainPatch@@QAEMXZ			; CTerrainPatch::GetMaxZ
PUBLIC	?isUsed@CTerrainPatchProxy@@QAE_NXZ		; CTerrainPatchProxy::isUsed
PUBLIC	?SetUsed@CTerrainPatchProxy@@QAEX_N@Z		; CTerrainPatchProxy::SetUsed
PUBLIC	?SetPatchNum@CTerrainPatchProxy@@QAEXF@Z	; CTerrainPatchProxy::SetPatchNum
PUBLIC	?GetTerrainNum@CTerrainPatchProxy@@QAEEXZ	; CTerrainPatchProxy::GetTerrainNum
PUBLIC	?SetTerrainNum@CTerrainPatchProxy@@QAEXE@Z	; CTerrainPatchProxy::SetTerrainNum
PUBLIC	?SetTerrainPatch@CTerrainPatchProxy@@QAEXPAVCTerrainPatch@@@Z ; CTerrainPatchProxy::SetTerrainPatch
PUBLIC	?GetMinX@CTerrainPatchProxy@@QAEMXZ		; CTerrainPatchProxy::GetMinX
PUBLIC	?GetMaxX@CTerrainPatchProxy@@QAEMXZ		; CTerrainPatchProxy::GetMaxX
PUBLIC	?GetMinY@CTerrainPatchProxy@@QAEMXZ		; CTerrainPatchProxy::GetMinY
PUBLIC	?GetMaxY@CTerrainPatchProxy@@QAEMXZ		; CTerrainPatchProxy::GetMaxY
PUBLIC	?GetMinZ@CTerrainPatchProxy@@QAEMXZ		; CTerrainPatchProxy::GetMinZ
PUBLIC	?GetMaxZ@CTerrainPatchProxy@@QAEMXZ		; CTerrainPatchProxy::GetMaxZ
PUBLIC	?GetCoordinate@CTerrain@@QAEXPAG0@Z		; CTerrain::GetCoordinate
PUBLIC	?select_on_container_copy_construction@?$allocator@PAVCTerrain@@@std@@QBE?AV12@XZ ; std::allocator<CTerrain *>::select_on_container_copy_construction
PUBLIC	??0?$allocator@PAVCTerrain@@@std@@QAE@XZ	; std::allocator<CTerrain *>::allocator<CTerrain *>
PUBLIC	??0?$allocator@PAVCTerrain@@@std@@QAE@ABV01@@Z	; std::allocator<CTerrain *>::allocator<CTerrain *>
PUBLIC	?deallocate@?$allocator@PAVCTerrain@@@std@@QAEXPAPAVCTerrain@@I@Z ; std::allocator<CTerrain *>::deallocate
PUBLIC	?allocate@?$allocator@PAVCTerrain@@@std@@QAEPAPAVCTerrain@@I@Z ; std::allocator<CTerrain *>::allocate
PUBLIC	?construct@?$allocator@PAVCTerrain@@@std@@QAEXPAPAVCTerrain@@ABQAV3@@Z ; std::allocator<CTerrain *>::construct
PUBLIC	?max_size@?$allocator@PAVCTerrain@@@std@@QBEIXZ	; std::allocator<CTerrain *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SAIABV?$allocator@PAVCTerrain@@@2@@Z ; std::allocator_traits<std::allocator<CTerrain *> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SA?AV?$allocator@PAVCTerrain@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<CTerrain *> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<CTerrain *> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CTerrain *> >::_Wrap_alloc<std::allocator<CTerrain *> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@ABV?$allocator@PAVCTerrain@@@1@@Z ; std::_Wrap_alloc<std::allocator<CTerrain *> >::_Wrap_alloc<std::allocator<CTerrain *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@I@Z ; std::_Wrap_alloc<std::allocator<CTerrain *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXPAPAVCTerrain@@I@Z ; std::_Wrap_alloc<std::allocator<CTerrain *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CTerrain *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CTerrain *> >::_Vector_val<std::_Simple_types<CTerrain *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTerrain@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CTerrain *,std::allocator<CTerrain *> > >::_Vector_alloc<0,std::_Vec_base_types<CTerrain *,std::allocator<CTerrain *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CTerrain *,std::allocator<CTerrain *> > >::_Getal
PUBLIC	??0?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::vector<CTerrain *,std::allocator<CTerrain *> >
PUBLIC	??0?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::vector<CTerrain *,std::allocator<CTerrain *> >
PUBLIC	??1?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::~vector<CTerrain *,std::allocator<CTerrain *> >
PUBLIC	?capacity@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::begin
PUBLIC	?begin@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::begin
PUBLIC	?end@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::end
PUBLIC	?end@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::end
PUBLIC	?_Make_iter@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Make_iter
PUBLIC	?resize@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::resize
PUBLIC	?size@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::size
PUBLIC	?max_size@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::max_size
PUBLIC	?empty@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE_NXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::empty
PUBLIC	??A?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEAAPAVCTerrain@@I@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::operator[]
PUBLIC	?push_back@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXABQAVCTerrain@@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::push_back
PUBLIC	?erase@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::erase
PUBLIC	?_Pop_back_n@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Pop_back_n
PUBLIC	?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear
PUBLIC	?_Buy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAE_NI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Buy
PUBLIC	?_Destroy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXPAPAVCTerrain@@0@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBEII@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBE_NPBQAVCTerrain@@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBEXPAPAVCTerrain@@0@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Orphan_range
PUBLIC	?Update@CMapOutdoor@@UAE_NMMM@Z			; CMapOutdoor::Update
PUBLIC	?UpdateAroundAmbience@CMapOutdoor@@UAEXMMM@Z	; CMapOutdoor::UpdateAroundAmbience
PUBLIC	?UpdateSky@CMapOutdoor@@QAEXXZ			; CMapOutdoor::UpdateSky
PUBLIC	?__ClearGarvage@CMapOutdoor@@MAEXXZ		; CMapOutdoor::__ClearGarvage
PUBLIC	?__UpdateGarvage@CMapOutdoor@@MAEXXZ		; CMapOutdoor::__UpdateGarvage
PUBLIC	?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z		; CMapOutdoor::UpdateAreaList
PUBLIC	?UpdateTerrain@CMapOutdoor@@IAEXMM@Z		; CMapOutdoor::UpdateTerrain
PUBLIC	?ConvertTerrainToTnL@CMapOutdoor@@IAEXJJ@Z	; CMapOutdoor::ConvertTerrainToTnL
PUBLIC	?AssignPatch@CMapOutdoor@@IAEXJJJJJ@Z		; CMapOutdoor::AssignPatch
PUBLIC	?__UpdateArea@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@@Z ; CMapOutdoor::__UpdateArea
PUBLIC	?__Game_UpdateArea@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@@Z ; CMapOutdoor::__Game_UpdateArea
PUBLIC	?__CollectShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z ; CMapOutdoor::__CollectShadowReceiver
PUBLIC	?__CollectCollisionPCBlocker@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0M@Z ; CMapOutdoor::__CollectCollisionPCBlocker
PUBLIC	?__CollectCollisionShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z ; CMapOutdoor::__CollectCollisionShadowReceiver
PUBLIC	?__UpdateAroundAreaList@CMapOutdoor@@IAEXXZ	; CMapOutdoor::__UpdateAroundAreaList
PUBLIC	?__IsInShadowReceiverList@CMapOutdoor@@IAE_NPAVCGraphicObjectInstance@@@Z ; CMapOutdoor::__IsInShadowReceiverList
PUBLIC	?__IsInPCBlockerList@CMapOutdoor@@IAE_NPAVCGraphicObjectInstance@@@Z ; CMapOutdoor::__IsInPCBlockerList
PUBLIC	?UpdateQuadTreeHeights@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@@Z ; CMapOutdoor::UpdateQuadTreeHeights
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAE@PAPAVCTerrain@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >
PUBLIC	?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEPBQAVCTerrain@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Unchecked
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEABQAVCTerrain@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAE@PAPAVCTerrain@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >
PUBLIC	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAEAAV12@PAPAVCTerrain@@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Rechecked
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEPAPAVCTerrain@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Unchecked
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEAAPAVCTerrain@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator++
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAE@PAPAVCArea@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >
PUBLIC	?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEPBQAVCArea@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Unchecked
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEABQAVCArea@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAE@PAPAVCArea@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >
PUBLIC	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAEAAV12@PAPAVCArea@@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Rechecked
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEPAPAVCArea@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Unchecked
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEAAPAVCArea@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator++
PUBLIC	??0FPushToDeleteVector@CMapOutdoor@@QAE@W4EDeleteDir@01@0USOutdoorMapCoordinate@@@Z ; CMapOutdoor::FPushToDeleteVector::FPushToDeleteVector
PUBLIC	??0FPushTerrainToDeleteVector@CMapOutdoor@@QAE@W4EDeleteDir@FPushToDeleteVector@1@0USOutdoorMapCoordinate@@@Z ; CMapOutdoor::FPushTerrainToDeleteVector::FPushTerrainToDeleteVector
PUBLIC	??RFPushTerrainToDeleteVector@CMapOutdoor@@QAEXPAVCTerrain@@@Z ; CMapOutdoor::FPushTerrainToDeleteVector::operator()
PUBLIC	??1FPushTerrainToDeleteVector@CMapOutdoor@@QAE@XZ ; CMapOutdoor::FPushTerrainToDeleteVector::~FPushTerrainToDeleteVector
PUBLIC	??0FPushTerrainToDeleteVector@CMapOutdoor@@QAE@ABU01@@Z ; CMapOutdoor::FPushTerrainToDeleteVector::FPushTerrainToDeleteVector
PUBLIC	??0FPushAreaToDeleteVector@CMapOutdoor@@QAE@W4EDeleteDir@FPushToDeleteVector@1@0USOutdoorMapCoordinate@@@Z ; CMapOutdoor::FPushAreaToDeleteVector::FPushAreaToDeleteVector
PUBLIC	??RFPushAreaToDeleteVector@CMapOutdoor@@QAEXPAVCArea@@@Z ; CMapOutdoor::FPushAreaToDeleteVector::operator()
PUBLIC	??1FPushAreaToDeleteVector@CMapOutdoor@@QAE@XZ	; CMapOutdoor::FPushAreaToDeleteVector::~FPushAreaToDeleteVector
PUBLIC	??0FPushAreaToDeleteVector@CMapOutdoor@@QAE@ABU01@@Z ; CMapOutdoor::FPushAreaToDeleteVector::FPushAreaToDeleteVector
PUBLIC	??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
PUBLIC	??0?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::allocator<NEffectUpdateDecorator::CHeaderDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::~vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	?begin@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
PUBLIC	??0?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::allocator<NEffectUpdateDecorator::CNullDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::~vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	?begin@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
PUBLIC	??0?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	?begin@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
PUBLIC	??0?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	?begin@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
PUBLIC	??0?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	?begin@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
PUBLIC	??0?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::~vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	?begin@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
PUBLIC	??0?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::allocator<NEffectUpdateDecorator::CGravityDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::~vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	?begin@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
PUBLIC	??0?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::allocator<NEffectUpdateDecorator::CRotationDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::~vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	?begin@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
PUBLIC	??0PCBlocker_CDynamicSphereInstanceVector@@QAE@XZ ; PCBlocker_CDynamicSphereInstanceVector::PCBlocker_CDynamicSphereInstanceVector
PUBLIC	??1PCBlocker_CDynamicSphereInstanceVector@@QAE@XZ ; PCBlocker_CDynamicSphereInstanceVector::~PCBlocker_CDynamicSphereInstanceVector
PUBLIC	?Begin@PCBlocker_CDynamicSphereInstanceVector@@QAEPAUCDynamicSphereInstance@@XZ ; PCBlocker_CDynamicSphereInstanceVector::Begin
PUBLIC	?End@PCBlocker_CDynamicSphereInstanceVector@@QAEPAUCDynamicSphereInstance@@XZ ; PCBlocker_CDynamicSphereInstanceVector::End
PUBLIC	??0FGetShadowReceiverFromCollisionData@@QAE@PAUCDynamicSphereInstance@@PAV?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@Z ; FGetShadowReceiverFromCollisionData::FGetShadowReceiverFromCollisionData
PUBLIC	??RFGetShadowReceiverFromCollisionData@@QAEXPAVCGraphicObjectInstance@@@Z ; FGetShadowReceiverFromCollisionData::operator()
PUBLIC	??0FPCBlockerDistanceSort@@QAE@AAUD3DXVECTOR3@@@Z ; FPCBlockerDistanceSort::FPCBlockerDistanceSort
PUBLIC	??RFPCBlockerDistanceSort@@QBE_NPAVCGraphicObjectInstance@@0@Z ; FPCBlockerDistanceSort::operator()
PUBLIC	??0FGetShadowReceiverFromHeightData@@QAE@MMMM@Z	; FGetShadowReceiverFromHeightData::FGetShadowReceiverFromHeightData
PUBLIC	?GetCollectItem@FGetShadowReceiverFromHeightData@@QAEPAVCGraphicObjectInstance@@I@Z ; FGetShadowReceiverFromHeightData::GetCollectItem
PUBLIC	?GetCollectCount@FGetShadowReceiverFromHeightData@@QAEIXZ ; FGetShadowReceiverFromHeightData::GetCollectCount
PUBLIC	??RFGetShadowReceiverFromHeightData@@QAEXPAVCGraphicObjectInstance@@@Z ; FGetShadowReceiverFromHeightData::operator()
PUBLIC	??$ForInRange@UFGetShadowReceiverFromHeightData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromHeightData@@@Z ; CCullingManager::ForInRange<FGetShadowReceiverFromHeightData>
PUBLIC	??0PCBlocker_SInstanceList@@QAE@PAVPCBlocker_CDynamicSphereInstanceVector@@@Z ; PCBlocker_SInstanceList::PCBlocker_SInstanceList
PUBLIC	??1PCBlocker_SInstanceList@@QAE@XZ		; PCBlocker_SInstanceList::~PCBlocker_SInstanceList
PUBLIC	?Begin@PCBlocker_SInstanceList@@QAEPAPAVCGraphicObjectInstance@@XZ ; PCBlocker_SInstanceList::Begin
PUBLIC	?End@PCBlocker_SInstanceList@@QAEPAPAVCGraphicObjectInstance@@XZ ; PCBlocker_SInstanceList::End
PUBLIC	?IsEmpty@PCBlocker_SInstanceList@@QAE_NXZ	; PCBlocker_SInstanceList::IsEmpty
PUBLIC	?__AppendPCBlocker@PCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z ; PCBlocker_SInstanceList::__AppendPCBlocker
PUBLIC	?__AppendObject@PCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z ; PCBlocker_SInstanceList::__AppendObject
PUBLIC	??RPCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z ; PCBlocker_SInstanceList::operator()
PUBLIC	??0?$RangeTester@UPCBlocker_SInstanceList@@@@QAE@PAUPCBlocker_SInstanceList@@M@Z ; RangeTester<PCBlocker_SInstanceList>::RangeTester<PCBlocker_SInstanceList>
PUBLIC	??1?$RangeTester@UPCBlocker_SInstanceList@@@@UAE@XZ ; RangeTester<PCBlocker_SInstanceList>::~RangeTester<PCBlocker_SInstanceList>
PUBLIC	?RayTraceCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ; RangeTester<PCBlocker_SInstanceList>::RayTraceCallback
PUBLIC	?VisibilityCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<PCBlocker_SInstanceList>::VisibilityCallback
PUBLIC	?RangeTestCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ; RangeTester<PCBlocker_SInstanceList>::RangeTestCallback
PUBLIC	?PointTest2dCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<PCBlocker_SInstanceList>::PointTest2dCallback
PUBLIC	??_G?$RangeTester@UPCBlocker_SInstanceList@@@@UAEPAXI@Z ; RangeTester<PCBlocker_SInstanceList>::`scalar deleting destructor'
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFPCBlockerDistanceSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0UFPCBlockerDistanceSort@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,FPCBlockerDistanceSort>
PUBLIC	??$ForInRange@UFGetShadowReceiverFromCollisionData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromCollisionData@@@Z ; CCullingManager::ForInRange<FGetShadowReceiverFromCollisionData>
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@PAVCGraphicObjectInstance@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@V10@0ABQAVCGraphicObjectInstance@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,CGraphicObjectInstance *>
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@PAVCTerrain@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@V10@0ABQAVCTerrain@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,CTerrain *>
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@PAVCArea@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@V10@0ABQAVCArea@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,CArea *>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@P6AXPAVCTerrain@@@Z@std@@YAP6AXPAVCTerrain@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,void (__cdecl*)(CTerrain *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@P6AXPAVCArea@@@Z@std@@YAP6AXPAVCArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,void (__cdecl*)(CArea *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushTerrainToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0U12@@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,CMapOutdoor::FPushTerrainToDeleteVector>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushAreaToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0U12@@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,CMapOutdoor::FPushAreaToDeleteVector>
PUBLIC	??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@V10@00@Z ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > > >
PUBLIC	??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@V10@00@Z ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > > >
PUBLIC	??$addressof@QAVCGraphicObjectInstance@@@std@@YAPBQAVCGraphicObjectInstance@@ABQAV1@@Z ; std::addressof<CGraphicObjectInstance * const>
PUBLIC	??$construct@PAVCGraphicObjectInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXPAPAVCGraphicObjectInstance@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::construct<CGraphicObjectInstance *,CGraphicObjectInstance * &>
PUBLIC	??$construct@PAVCGraphicObjectInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXPAPAVCGraphicObjectInstance@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::construct<CGraphicObjectInstance *,CGraphicObjectInstance * const &>
PUBLIC	??$_Uninitialized_default_fill_n@PAPAVCArea@@IU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAXPAPAVCArea@@IAAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<CArea * *,unsigned int,std::_Wrap_alloc<std::allocator<CArea *> > >
PUBLIC	??$addressof@QAVCArea@@@std@@YAPBQAVCArea@@ABQAV1@@Z ; std::addressof<CArea * const>
PUBLIC	??$construct@PAVCArea@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEXPAPAVCArea@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<CArea *> >::construct<CArea *,CArea * &>
PUBLIC	??$construct@PAVCArea@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEXPAPAVCArea@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<CArea *> >::construct<CArea *,CArea * const &>
PUBLIC	??$_Move@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z ; std::_Move<CArea * *,CArea * *>
PUBLIC	??$_Uninitialized_default_fill_n@PAPAVCTerrain@@IU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAXPAPAVCTerrain@@IAAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<CTerrain * *,unsigned int,std::_Wrap_alloc<std::allocator<CTerrain *> > >
PUBLIC	??$addressof@QAVCTerrain@@@std@@YAPBQAVCTerrain@@ABQAV1@@Z ; std::addressof<CTerrain * const>
PUBLIC	??$construct@PAVCTerrain@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXPAPAVCTerrain@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<CTerrain *> >::construct<CTerrain *,CTerrain * &>
PUBLIC	??$construct@PAVCTerrain@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXPAPAVCTerrain@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<CTerrain *> >::construct<CTerrain *,CTerrain * const &>
PUBLIC	??$_Move@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z ; std::_Move<CTerrain * *,CTerrain * *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAXPAPAVCArea@@0AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CArea *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAXPAPAVCTerrain@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTerrain *> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCHeaderDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCNullDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCGravityDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCRotationDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
PUBLIC	??$_Umove@PAPAVCGraphicObjectInstance@@@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEPAPAVCGraphicObjectInstance@@PAPAV2@00@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Umove<CGraphicObjectInstance * *>
PUBLIC	??$_Umove@PAPAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEPAPAVCArea@@PAPAV2@00@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Umove<CArea * *>
PUBLIC	??$_Umove@PAPAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEPAPAVCTerrain@@PAPAV2@00@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Umove<CTerrain * *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	??$_Allocate@PAVCGraphicObjectInstance@@@std@@YAPAPAVCGraphicObjectInstance@@IPAPAV1@@Z ; std::_Allocate<CGraphicObjectInstance *>
PUBLIC	??$_Allocate@PAVCArea@@@std@@YAPAPAVCArea@@IPAPAV1@@Z ; std::_Allocate<CArea *>
PUBLIC	??$_Allocate@PAVCTerrain@@@std@@YAPAPAVCTerrain@@IPAPAV1@@Z ; std::_Allocate<CTerrain *>
PUBLIC	??0?$RangeTester@UFGetShadowReceiverFromHeightData@@@@QAE@PAUFGetShadowReceiverFromHeightData@@M@Z ; RangeTester<FGetShadowReceiverFromHeightData>::RangeTester<FGetShadowReceiverFromHeightData>
PUBLIC	??1?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAE@XZ ; RangeTester<FGetShadowReceiverFromHeightData>::~RangeTester<FGetShadowReceiverFromHeightData>
PUBLIC	?RayTraceCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ; RangeTester<FGetShadowReceiverFromHeightData>::RayTraceCallback
PUBLIC	?VisibilityCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<FGetShadowReceiverFromHeightData>::VisibilityCallback
PUBLIC	?RangeTestCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ; RangeTester<FGetShadowReceiverFromHeightData>::RangeTestCallback
PUBLIC	?PointTest2dCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<FGetShadowReceiverFromHeightData>::PointTest2dCallback
PUBLIC	??_G?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEPAXI@Z ; RangeTester<FGetShadowReceiverFromHeightData>::`scalar deleting destructor'
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
PUBLIC	??$_Sort@PAPAVCGraphicObjectInstance@@HUFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0HUFPCBlockerDistanceSort@@@Z ; std::_Sort<CGraphicObjectInstance * *,int,FPCBlockerDistanceSort>
PUBLIC	??0?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@QAE@PAUFGetShadowReceiverFromCollisionData@@M@Z ; RangeTester<FGetShadowReceiverFromCollisionData>::RangeTester<FGetShadowReceiverFromCollisionData>
PUBLIC	??1?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAE@XZ ; RangeTester<FGetShadowReceiverFromCollisionData>::~RangeTester<FGetShadowReceiverFromCollisionData>
PUBLIC	?RayTraceCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ; RangeTester<FGetShadowReceiverFromCollisionData>::RayTraceCallback
PUBLIC	?VisibilityCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<FGetShadowReceiverFromCollisionData>::VisibilityCallback
PUBLIC	?RangeTestCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ; RangeTester<FGetShadowReceiverFromCollisionData>::RangeTestCallback
PUBLIC	?PointTest2dCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<FGetShadowReceiverFromCollisionData>::PointTest2dCallback
PUBLIC	??_G?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEPAXI@Z ; RangeTester<FGetShadowReceiverFromCollisionData>::`scalar deleting destructor'
PUBLIC	??$_Find@PAPAVCGraphicObjectInstance@@PAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@0ABQAV1@@Z ; std::_Find<CGraphicObjectInstance * *,CGraphicObjectInstance *>
PUBLIC	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@AAV10@PAPAVCGraphicObjectInstance@@@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CTerrain *> > >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@YAPBQAVCTerrain@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CTerrain *> > >
PUBLIC	??$_Find@PAPAVCTerrain@@PAV1@@std@@YAPAPAVCTerrain@@PAPAV1@0ABQAV1@@Z ; std::_Find<CTerrain * *,CTerrain *>
PUBLIC	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@AAV10@PAPAVCTerrain@@@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CTerrain *> > >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CArea *> > >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@YAPBQAVCArea@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CArea *> > >
PUBLIC	??$_Find@PAPAVCArea@@PAV1@@std@@YAPAPAVCArea@@PAPAV1@0ABQAV1@@Z ; std::_Find<CArea * *,CArea *>
PUBLIC	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@AAV10@PAPAVCArea@@@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CArea *> > >
PUBLIC	??$_For_each@PAPAVCTerrain@@P6AXPAV1@@Z@std@@YAXPAPAVCTerrain@@0AAP6AXPAV1@@Z@Z ; std::_For_each<CTerrain * *,void (__cdecl*)(CTerrain *)>
PUBLIC	??$move@AAP6AXPAVCTerrain@@@Z@std@@YA$$QAP6AXPAVCTerrain@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(CTerrain *)>
PUBLIC	??$_For_each@PAPAVCArea@@P6AXPAV1@@Z@std@@YAXPAPAVCArea@@0AAP6AXPAV1@@Z@Z ; std::_For_each<CArea * *,void (__cdecl*)(CArea *)>
PUBLIC	??$move@AAP6AXPAVCArea@@@Z@std@@YA$$QAP6AXPAVCArea@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(CArea *)>
PUBLIC	??$_For_each@PAPAVCTerrain@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YAXPAPAVCTerrain@@0AAUFPushTerrainToDeleteVector@CMapOutdoor@@@Z ; std::_For_each<CTerrain * *,CMapOutdoor::FPushTerrainToDeleteVector>
PUBLIC	??$move@AAUFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA$$QAUFPushTerrainToDeleteVector@CMapOutdoor@@AAU12@@Z ; std::move<CMapOutdoor::FPushTerrainToDeleteVector &>
PUBLIC	??$_For_each@PAPAVCArea@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YAXPAPAVCArea@@0AAUFPushAreaToDeleteVector@CMapOutdoor@@@Z ; std::_For_each<CArea * *,CMapOutdoor::FPushAreaToDeleteVector>
PUBLIC	??$move@AAUFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA$$QAUFPushAreaToDeleteVector@CMapOutdoor@@AAU12@@Z ; std::move<CMapOutdoor::FPushAreaToDeleteVector &>
PUBLIC	??$_Copy_impl@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z ; std::_Copy_impl<CTerrain * *,CTerrain * *>
PUBLIC	??$_Copy_impl@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z ; std::_Copy_impl<CArea * *,CArea * *>
PUBLIC	??$forward@AAPAVCGraphicObjectInstance@@@std@@YAAAPAVCGraphicObjectInstance@@AAPAV1@@Z ; std::forward<CGraphicObjectInstance * &>
PUBLIC	??$construct@PAVCGraphicObjectInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicObjectInstance@@@1@PAPAVCGraphicObjectInstance@@AAPAV3@@Z ; std::allocator_traits<std::allocator<CGraphicObjectInstance *> >::construct<CGraphicObjectInstance *,CGraphicObjectInstance * &>
PUBLIC	??$forward@ABQAVCGraphicObjectInstance@@@std@@YAABQAVCGraphicObjectInstance@@ABQAV1@@Z ; std::forward<CGraphicObjectInstance * const &>
PUBLIC	??$construct@PAVCGraphicObjectInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicObjectInstance@@@1@PAPAVCGraphicObjectInstance@@ABQAV3@@Z ; std::allocator_traits<std::allocator<CGraphicObjectInstance *> >::construct<CGraphicObjectInstance *,CGraphicObjectInstance * const &>
PUBLIC	??$_Val_type@PAPAVCArea@@@std@@YAPAPAVCArea@@PAPAV1@@Z ; std::_Val_type<CArea * *>
PUBLIC	??$_Ptr_cat@PAVCArea@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVCArea@@PAPAV2@@Z ; std::_Ptr_cat<CArea *,CArea *>
PUBLIC	??$_Ptr_cat@PAVCArea@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCArea@@0@Z ; std::_Ptr_cat<CArea *,CArea *>
PUBLIC	??$_Uninit_def_fill_n@PAVCArea@@IPAV1@@std@@YAXPAPAVCArea@@IAAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<CArea *,unsigned int,CArea *>
PUBLIC	??$forward@AAPAVCArea@@@std@@YAAAPAVCArea@@AAPAV1@@Z ; std::forward<CArea * &>
PUBLIC	??$construct@PAVCArea@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SAXAAV?$allocator@PAVCArea@@@1@PAPAVCArea@@AAPAV3@@Z ; std::allocator_traits<std::allocator<CArea *> >::construct<CArea *,CArea * &>
PUBLIC	??$forward@ABQAVCArea@@@std@@YAABQAVCArea@@ABQAV1@@Z ; std::forward<CArea * const &>
PUBLIC	??$construct@PAVCArea@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SAXAAV?$allocator@PAVCArea@@@1@PAPAVCArea@@ABQAV3@@Z ; std::allocator_traits<std::allocator<CArea *> >::construct<CArea *,CArea * const &>
PUBLIC	??$_Move@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<CArea * *,CArea * *>
PUBLIC	??$_Val_type@PAPAVCTerrain@@@std@@YAPAPAVCTerrain@@PAPAV1@@Z ; std::_Val_type<CTerrain * *>
PUBLIC	??$_Ptr_cat@PAVCTerrain@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVCTerrain@@PAPAV2@@Z ; std::_Ptr_cat<CTerrain *,CTerrain *>
PUBLIC	??$_Ptr_cat@PAVCTerrain@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTerrain@@0@Z ; std::_Ptr_cat<CTerrain *,CTerrain *>
PUBLIC	??$_Uninit_def_fill_n@PAVCTerrain@@IPAV1@@std@@YAXPAPAVCTerrain@@IAAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<CTerrain *,unsigned int,CTerrain *>
PUBLIC	??$forward@AAPAVCTerrain@@@std@@YAAAPAVCTerrain@@AAPAV1@@Z ; std::forward<CTerrain * &>
PUBLIC	??$construct@PAVCTerrain@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SAXAAV?$allocator@PAVCTerrain@@@1@PAPAVCTerrain@@AAPAV3@@Z ; std::allocator_traits<std::allocator<CTerrain *> >::construct<CTerrain *,CTerrain * &>
PUBLIC	??$forward@ABQAVCTerrain@@@std@@YAABQAVCTerrain@@ABQAV1@@Z ; std::forward<CTerrain * const &>
PUBLIC	??$construct@PAVCTerrain@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SAXAAV?$allocator@PAVCTerrain@@@1@PAPAVCTerrain@@ABQAV3@@Z ; std::allocator_traits<std::allocator<CTerrain *> >::construct<CTerrain *,CTerrain * const &>
PUBLIC	??$_Move@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<CTerrain * *,CTerrain * *>
PUBLIC	??$_Ptr_cat@PAVCGraphicObjectInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicObjectInstance@@0@Z ; std::_Ptr_cat<CGraphicObjectInstance *,CGraphicObjectInstance *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAXPAPAVCArea@@0AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CArea *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAXPAPAVCTerrain@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTerrain *> > >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCHeaderDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	??$_For_each@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CHeaderDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
PUBLIC	??$move@AAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CHeaderDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCNullDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	??$_For_each@PAPAVCNullDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CNullDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
PUBLIC	??$move@AAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CNullDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	??$_For_each@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
PUBLIC	??$move@AAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	??$_For_each@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
PUBLIC	??$move@AAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	??$_For_each@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationRandomDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
PUBLIC	??$move@AAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	??$_For_each@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CAirResistanceDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
PUBLIC	??$move@AAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCGravityDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	??$_For_each@PAPAVCGravityDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CGravityDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
PUBLIC	??$move@AAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CGravityDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCRotationDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	??$_For_each@PAPAVCRotationDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CRotationDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
PUBLIC	??$move@AAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CRotationDecorator *)>
PUBLIC	??$_Uninitialized_move@PAPAVCGraphicObjectInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@@Z ; std::_Uninitialized_move<CGraphicObjectInstance * *,CGraphicObjectInstance * *,std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> > >
PUBLIC	??$_Uninitialized_move@PAPAVCArea@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z ; std::_Uninitialized_move<CArea * *,CArea * *,std::_Wrap_alloc<std::allocator<CArea *> > >
PUBLIC	??$_Uninitialized_move@PAPAVCTerrain@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z ; std::_Uninitialized_move<CTerrain * *,CTerrain * *,std::_Wrap_alloc<std::allocator<CTerrain *> > >
PUBLIC	??$_Ptr_cat@PAVCHeaderDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CHeaderDecorator *,NEffectUpdateDecorator::CHeaderDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCNullDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CNullDecorator *,NEffectUpdateDecorator::CNullDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCWDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CAirResistanceDecorator *,NEffectUpdateDecorator::CAirResistanceDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCGravityDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CGravityDecorator *,NEffectUpdateDecorator::CGravityDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCRotationDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CRotationDecorator *,NEffectUpdateDecorator::CRotationDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEPAPAVCArea@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@1@0PAPAV2@@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > > >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEPAPAVCTerrain@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@1@0PAPAV2@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > > >
PUBLIC	??$_Unguarded_partition@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YA?AU?$pair@PAPAVCGraphicObjectInstance@@PAPAV1@@0@PAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z ; std::_Unguarded_partition<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
PUBLIC	??$make_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z ; std::make_heap<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
PUBLIC	??$sort_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z ; std::sort_heap<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
PUBLIC	??$_Insertion_sort@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z ; std::_Insertion_sort<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
PUBLIC	??$_Find@PAPAVCGraphicObjectInstance@@PAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@0ABQAV1@U?$integral_constant@_N$0A@@0@@Z ; std::_Find<CGraphicObjectInstance * *,CGraphicObjectInstance *>
PUBLIC	??$_Find@PAPAVCTerrain@@PAV1@@std@@YAPAPAVCTerrain@@PAPAV1@0ABQAV1@U?$integral_constant@_N$0A@@0@@Z ; std::_Find<CTerrain * *,CTerrain *>
PUBLIC	??$_Find@PAPAVCArea@@PAV1@@std@@YAPAPAVCArea@@PAPAV1@0ABQAV1@U?$integral_constant@_N$0A@@0@@Z ; std::_Find<CArea * *,CArea *>
PUBLIC	??$_Copy_impl@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<CTerrain * *,CTerrain * *>
PUBLIC	??$_Copy_impl@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<CArea * *,CArea * *>
PUBLIC	??$construct@PAVCGraphicObjectInstance@@AAPAV1@@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEXPAPAVCGraphicObjectInstance@@AAPAV2@@Z ; std::allocator<CGraphicObjectInstance *>::construct<CGraphicObjectInstance *,CGraphicObjectInstance * &>
PUBLIC	??$_Fill_n@PAPAVCArea@@IPAV1@@std@@YAPAPAVCArea@@PAPAV1@IABQAV1@@Z ; std::_Fill_n<CArea * *,unsigned int,CArea *>
PUBLIC	??$construct@PAVCArea@@AAPAV1@@?$allocator@PAVCArea@@@std@@QAEXPAPAVCArea@@AAPAV2@@Z ; std::allocator<CArea *>::construct<CArea *,CArea * &>
PUBLIC	??$_Fill_n@PAPAVCTerrain@@IPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@IABQAV1@@Z ; std::_Fill_n<CTerrain * *,unsigned int,CTerrain *>
PUBLIC	??$construct@PAVCTerrain@@AAPAV1@@?$allocator@PAVCTerrain@@@std@@QAEXPAPAVCTerrain@@AAPAV2@@Z ; std::allocator<CTerrain *>::construct<CTerrain *,CTerrain * &>
PUBLIC	??$_Unchecked@PAPAVCGraphicObjectInstance@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@@Z ; std::_Unchecked<CGraphicObjectInstance * *>
PUBLIC	??$_Uninit_move@PAPAVCGraphicObjectInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@@Z ; std::_Uninit_move<CGraphicObjectInstance * *,CGraphicObjectInstance * *,std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> > >
PUBLIC	??$_Rechecked@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAAAPAPAVCGraphicObjectInstance@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<CGraphicObjectInstance * *,CGraphicObjectInstance * *>
PUBLIC	??$_Unchecked@PAPAVCArea@@@std@@YAPAPAVCArea@@PAPAV1@@Z ; std::_Unchecked<CArea * *>
PUBLIC	??$_Uninit_move@PAPAVCArea@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z ; std::_Uninit_move<CArea * *,CArea * *,std::_Wrap_alloc<std::allocator<CArea *> > >
PUBLIC	??$_Rechecked@PAPAVCArea@@PAPAV1@@std@@YAAAPAPAVCArea@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<CArea * *,CArea * *>
PUBLIC	??$_Unchecked@PAPAVCTerrain@@@std@@YAPAPAVCTerrain@@PAPAV1@@Z ; std::_Unchecked<CTerrain * *>
PUBLIC	??$_Uninit_move@PAPAVCTerrain@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z ; std::_Uninit_move<CTerrain * *,CTerrain * *,std::_Wrap_alloc<std::allocator<CTerrain *> > >
PUBLIC	??$_Rechecked@PAPAVCTerrain@@PAPAV1@@std@@YAAAPAPAVCTerrain@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<CTerrain * *,CTerrain * *>
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@PAPAVCArea@@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@2@@std@@YAPAPAVCArea@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,CArea * *,std::_Wrap_alloc<std::allocator<CArea *> > >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@PAPAVCTerrain@@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@2@@std@@YAPAPAVCTerrain@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,CTerrain * *,std::_Wrap_alloc<std::allocator<CTerrain *> > >
PUBLIC	??$_Median@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00UFPCBlockerDistanceSort@@@Z ; std::_Median<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
PUBLIC	??$iter_swap@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAXPAPAVCGraphicObjectInstance@@0@Z ; std::iter_swap<CGraphicObjectInstance * *,CGraphicObjectInstance * *>
PUBLIC	??$?0AAPAPAVCGraphicObjectInstance@@AAPAPAV0@X@?$pair@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@QAE@AAPAPAVCGraphicObjectInstance@@0@Z ; std::pair<CGraphicObjectInstance * *,CGraphicObjectInstance * *>::pair<CGraphicObjectInstance * *,CGraphicObjectInstance * *><CGraphicObjectInstance * * &,CGraphicObjectInstance * * &,void>
PUBLIC	??$_Dist_type@PAPAVCGraphicObjectInstance@@@std@@YAPAHPAPAVCGraphicObjectInstance@@@Z ; std::_Dist_type<CGraphicObjectInstance * *>
PUBLIC	??$_Val_type@PAPAVCGraphicObjectInstance@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@@Z ; std::_Val_type<CGraphicObjectInstance * *>
PUBLIC	??$_Make_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@PAH0@Z ; std::_Make_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>
PUBLIC	??$_Sort_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z ; std::_Sort_heap<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
PUBLIC	??$_Insertion_sort1@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@PAV1@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@0@Z ; std::_Insertion_sort1<CGraphicObjectInstance * *,FPCBlockerDistanceSort,CGraphicObjectInstance *>
PUBLIC	??$_Uninit_move@PAVCGraphicObjectInstance@@PAV1@PAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CGraphicObjectInstance *,CGraphicObjectInstance *,CGraphicObjectInstance *>
PUBLIC	??$_Uninit_move@PAVCArea@@PAV1@PAV1@@std@@YAPAPAVCArea@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CArea *,CArea *,CArea *>
PUBLIC	??$_Uninit_move@PAVCTerrain@@PAV1@PAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CTerrain *,CTerrain *,CTerrain *>
PUBLIC	??$_Uninit_copy@PBQAVCArea@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z ; std::_Uninit_copy<CArea * const *,CArea * *,std::_Wrap_alloc<std::allocator<CArea *> > >
PUBLIC	??$_Uninit_copy@PBQAVCTerrain@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z ; std::_Uninit_copy<CTerrain * const *,CTerrain * *,std::_Wrap_alloc<std::allocator<CTerrain *> > >
PUBLIC	??$_Med3@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00UFPCBlockerDistanceSort@@@Z ; std::_Med3<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
PUBLIC	??$swap@PAVCGraphicObjectInstance@@@std@@YAXAAPAVCGraphicObjectInstance@@0@Z ; std::swap<CGraphicObjectInstance *>
PUBLIC	??$forward@AAPAPAVCGraphicObjectInstance@@@std@@YAAAPAPAVCGraphicObjectInstance@@AAPAPAV1@@Z ; std::forward<CGraphicObjectInstance * * &>
PUBLIC	??$_Move@AAPAVCGraphicObjectInstance@@@std@@YA$$QAPAVCGraphicObjectInstance@@AAPAV1@@Z ; std::_Move<CGraphicObjectInstance * &>
PUBLIC	??$_Adjust_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@HH$$QAPAV1@UFPCBlockerDistanceSort@@@Z ; std::_Adjust_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>
PUBLIC	??$_Pop_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z ; std::_Pop_heap<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
PUBLIC	??$_Move_backward@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00@Z ; std::_Move_backward<CGraphicObjectInstance * *,CGraphicObjectInstance * *>
PUBLIC	??$_Uninit_copy@QAVCArea@@PAV1@@std@@YAPAPAVCArea@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CArea * const,CArea *>
PUBLIC	??$_Uninit_copy@QAVCTerrain@@PAV1@@std@@YAPAPAVCTerrain@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CTerrain * const,CTerrain *>
PUBLIC	??$_Push_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@HH$$QAPAV1@UFPCBlockerDistanceSort@@@Z ; std::_Push_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>
PUBLIC	??$_Pop_heap_0@PAPAVCGraphicObjectInstance@@PAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@0@Z ; std::_Pop_heap_0<CGraphicObjectInstance * *,CGraphicObjectInstance *,FPCBlockerDistanceSort>
PUBLIC	??$_Move_backward@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<CGraphicObjectInstance * *,CGraphicObjectInstance * *>
PUBLIC	??$_Pop_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00$$QAPAV1@UFPCBlockerDistanceSort@@PAH@Z ; std::_Pop_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>
PUBLIC	?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
PUBLIC	??_7SpherePackCallback@@6B@			; SpherePackCallback::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
PUBLIC	??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
PUBLIC	??_C@_0BK@IDOOHDBC@Update?3?3Load?5spent?5?$CFd?5ms?6?$AA@ ; `string'
PUBLIC	??_7?$RangeTester@UPCBlocker_SInstanceList@@@@6B@ ; RangeTester<PCBlocker_SInstanceList>::`vftable'
PUBLIC	??_C@_0BB@GFILMBNJ@Delete?5Terrain?5?6?$AA@	; `string'
PUBLIC	??_C@_0O@MNAKBLAF@Delete?5Area?5?6?$AA@		; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_7?$RangeTester@UFGetShadowReceiverFromHeightData@@@@6B@ ; RangeTester<FGetShadowReceiverFromHeightData>::`vftable'
PUBLIC	??_7?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@6B@ ; RangeTester<FGetShadowReceiverFromCollisionData>::`vftable'
PUBLIC	??_R4SpherePackCallback@@6B@			; SpherePackCallback::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSpherePackCallback@@@8			; SpherePackCallback `RTTI Type Descriptor'
PUBLIC	??_R3SpherePackCallback@@8			; SpherePackCallback::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SpherePackCallback@@8			; SpherePackCallback::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SpherePackCallback@@8		; SpherePackCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$RangeTester@UPCBlocker_SInstanceList@@@@6B@ ; RangeTester<PCBlocker_SInstanceList>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU?$RangeTester@UPCBlocker_SInstanceList@@@@@8 ; RangeTester<PCBlocker_SInstanceList> `RTTI Type Descriptor'
PUBLIC	??_R3?$RangeTester@UPCBlocker_SInstanceList@@@@8 ; RangeTester<PCBlocker_SInstanceList>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$RangeTester@UPCBlocker_SInstanceList@@@@8 ; RangeTester<PCBlocker_SInstanceList>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$RangeTester@UPCBlocker_SInstanceList@@@@8 ; RangeTester<PCBlocker_SInstanceList>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$RangeTester@UFGetShadowReceiverFromHeightData@@@@6B@ ; RangeTester<FGetShadowReceiverFromHeightData>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU?$RangeTester@UFGetShadowReceiverFromHeightData@@@@@8 ; RangeTester<FGetShadowReceiverFromHeightData> `RTTI Type Descriptor'
PUBLIC	??_R3?$RangeTester@UFGetShadowReceiverFromHeightData@@@@8 ; RangeTester<FGetShadowReceiverFromHeightData>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$RangeTester@UFGetShadowReceiverFromHeightData@@@@8 ; RangeTester<FGetShadowReceiverFromHeightData>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@8 ; RangeTester<FGetShadowReceiverFromHeightData>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@6B@ ; RangeTester<FGetShadowReceiverFromCollisionData>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@@8 ; RangeTester<FGetShadowReceiverFromCollisionData> `RTTI Type Descriptor'
PUBLIC	??_R3?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@8 ; RangeTester<FGetShadowReceiverFromCollisionData>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@8 ; RangeTester<FGetShadowReceiverFromCollisionData>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@8 ; RangeTester<FGetShadowReceiverFromCollisionData>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3f000000
PUBLIC	__real@3fddb22d
PUBLIC	__real@402fff8cc0000000
PUBLIC	__real@42480000
PUBLIC	__real@c05db22d
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?MINMAX@@YAHHHH@Z:PROC				; MINMAX
EXTRN	?Trace@@YAXPBD@Z:PROC				; Trace
EXTRN	?Tracenf@@YAXPBDZZ:PROC				; Tracenf
EXTRN	?GetCurrentSecond@CTimer@@QAEMXZ:PROC		; CTimer::GetCurrentSecond
EXTRN	?ELTimer_GetMSec@@YAKXZ:PROC			; ELTimer_GetMSec
EXTRN	?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ:PROC ; CCameraManager::GetCurrentCamera
EXTRN	??_ESpherePackCallback@@UAEPAXI@Z:PROC		; SpherePackCallback::`vector deleting destructor'
EXTRN	?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z:PROC ; SpherePackFactory::RangeTest
EXTRN	?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ:PROC ; CGraphicObjectInstance::GetPosition
EXTRN	?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z:PROC ; CGraphicObjectInstance::CollisionDynamicSphere
EXTRN	?GetObjectHeight@CGraphicObjectInstance@@QAE_NMMPAM@Z:PROC ; CGraphicObjectInstance::GetObjectHeight
EXTRN	?UpdateSystem@CSpeedTreeForest@@QAEXM@Z:PROC	; CSpeedTreeForest::UpdateSystem
EXTRN	?Update@CArea@@QAEXXZ:PROC			; CArea::Update
EXTRN	?UpdateAroundAmbience@CArea@@QAEXMMM@Z:PROC	; CArea::UpdateAroundAmbience
EXTRN	?GetCoordinate@CArea@@QAEXPAG0@Z:PROC		; CArea::GetCoordinate
EXTRN	?Delete@CArea@@SAXPAV1@@Z:PROC			; CArea::Delete
EXTRN	?GetTerrainPatchPtr@CTerrain@@QAEPAVCTerrainPatch@@EE@Z:PROC ; CTerrain::GetTerrainPatchPtr
EXTRN	?Delete@CTerrain@@SAXPAV1@@Z:PROC		; CTerrain::Delete
EXTRN	?AssignTerrainPtr@CMapOutdoor@@IAEXXZ:PROC	; CMapOutdoor::AssignTerrainPtr
EXTRN	?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z:PROC ; CMapOutdoor::GetTerrainPointer
EXTRN	?GetAreaPointer@CMapOutdoor@@QAEHEPAPAVCArea@@@Z:PROC ; CMapOutdoor::GetAreaPointer
EXTRN	?__HeightCache_Update@CMapOutdoor@@AAEXXZ:PROC	; CMapOutdoor::__HeightCache_Update
EXTRN	??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vector deleting destructor'
EXTRN	?IsBuilding@CActorInstance@@QAE_NXZ:PROC	; CActorInstance::IsBuilding
EXTRN	??_E?$RangeTester@UPCBlocker_SInstanceList@@@@UAEPAXI@Z:PROC ; RangeTester<PCBlocker_SInstanceList>::`vector deleting destructor'
EXTRN	??_E?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEPAXI@Z:PROC ; RangeTester<FGetShadowReceiverFromHeightData>::`vector deleting destructor'
EXTRN	??_E?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEPAXI@Z:PROC ; RangeTester<FGetShadowReceiverFromCollisionData>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?PR_FCNV@@3MA:DWORD				; PR_FCNV
EXTRN	?PR_ICNV@@3JA:DWORD				; PR_ICNV
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A DD 01H DUP (?) ; CSingleton<CTimer>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A DD 01H DUP (?) ; CSingleton<CCameraManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A DD 01H DUP (?) ; CSingleton<CCullingManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A DD 01H DUP (?) ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
_BSS	ENDS
;	COMDAT ?dwEraseTime@?1??__UpdateGarvage@CMapOutdoor@@MAEXXZ@4KA
_BSS	SEGMENT
?dwEraseTime@?1??__UpdateGarvage@CMapOutdoor@@MAEXXZ@4KA DD 01H DUP (?) ; `CMapOutdoor::__UpdateGarvage'::`2'::dwEraseTime
_BSS	ENDS
;	COMDAT ?$S1@?1??__UpdateGarvage@CMapOutdoor@@MAEXXZ@4IA
_BSS	SEGMENT
?$S1@?1??__UpdateGarvage@CMapOutdoor@@MAEXXZ@4IA DD 01H DUP (?) ; S1<`template-parameter-2',UNKNOWN,CMapOutdoor::pdateGarvage,float, ?? >
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c05db22d
CONST	SEGMENT
__real@c05db22d DD 0c05db22dr			; -3.464
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@402fff8cc0000000
CONST	SEGMENT
__real@402fff8cc0000000 DQ 0402fff8cc0000000r	; 15.9991
CONST	ENDS
;	COMDAT __real@3fddb22d
CONST	SEGMENT
__real@3fddb22d DD 03fddb22dr			; 1.732
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@8 DD FLAT:??_R0?AU?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@@8 ; RangeTester<FGetShadowReceiverFromCollisionData>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@8
rdata$r	SEGMENT
??_R2?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@8 DD FLAT:??_R1A@?0A@EA@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@8 ; RangeTester<FGetShadowReceiverFromCollisionData>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R3?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@8
rdata$r	SEGMENT
??_R3?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@8 DD 00H ; RangeTester<FGetShadowReceiverFromCollisionData>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@@8
data$r	SEGMENT
??_R0?AU?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@@8 DD FLAT:??_7type_info@@6B@ ; RangeTester<FGetShadowReceiverFromCollisionData> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$RangeTester@UFGetShadowReceiverFromCollisionData@@'
	DB	'@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@6B@
rdata$r	SEGMENT
??_R4?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@6B@ DD 00H ; RangeTester<FGetShadowReceiverFromCollisionData>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@@8
	DD	FLAT:??_R3?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@8 DD FLAT:??_R0?AU?$RangeTester@UFGetShadowReceiverFromHeightData@@@@@8 ; RangeTester<FGetShadowReceiverFromHeightData>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$RangeTester@UFGetShadowReceiverFromHeightData@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$RangeTester@UFGetShadowReceiverFromHeightData@@@@8
rdata$r	SEGMENT
??_R2?$RangeTester@UFGetShadowReceiverFromHeightData@@@@8 DD FLAT:??_R1A@?0A@EA@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@8 ; RangeTester<FGetShadowReceiverFromHeightData>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R3?$RangeTester@UFGetShadowReceiverFromHeightData@@@@8
rdata$r	SEGMENT
??_R3?$RangeTester@UFGetShadowReceiverFromHeightData@@@@8 DD 00H ; RangeTester<FGetShadowReceiverFromHeightData>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$RangeTester@UFGetShadowReceiverFromHeightData@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$RangeTester@UFGetShadowReceiverFromHeightData@@@@@8
data$r	SEGMENT
??_R0?AU?$RangeTester@UFGetShadowReceiverFromHeightData@@@@@8 DD FLAT:??_7type_info@@6B@ ; RangeTester<FGetShadowReceiverFromHeightData> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$RangeTester@UFGetShadowReceiverFromHeightData@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$RangeTester@UFGetShadowReceiverFromHeightData@@@@6B@
rdata$r	SEGMENT
??_R4?$RangeTester@UFGetShadowReceiverFromHeightData@@@@6B@ DD 00H ; RangeTester<FGetShadowReceiverFromHeightData>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$RangeTester@UFGetShadowReceiverFromHeightData@@@@@8
	DD	FLAT:??_R3?$RangeTester@UFGetShadowReceiverFromHeightData@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$RangeTester@UPCBlocker_SInstanceList@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$RangeTester@UPCBlocker_SInstanceList@@@@8 DD FLAT:??_R0?AU?$RangeTester@UPCBlocker_SInstanceList@@@@@8 ; RangeTester<PCBlocker_SInstanceList>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$RangeTester@UPCBlocker_SInstanceList@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$RangeTester@UPCBlocker_SInstanceList@@@@8
rdata$r	SEGMENT
??_R2?$RangeTester@UPCBlocker_SInstanceList@@@@8 DD FLAT:??_R1A@?0A@EA@?$RangeTester@UPCBlocker_SInstanceList@@@@8 ; RangeTester<PCBlocker_SInstanceList>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R3?$RangeTester@UPCBlocker_SInstanceList@@@@8
rdata$r	SEGMENT
??_R3?$RangeTester@UPCBlocker_SInstanceList@@@@8 DD 00H	; RangeTester<PCBlocker_SInstanceList>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$RangeTester@UPCBlocker_SInstanceList@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$RangeTester@UPCBlocker_SInstanceList@@@@@8
data$r	SEGMENT
??_R0?AU?$RangeTester@UPCBlocker_SInstanceList@@@@@8 DD FLAT:??_7type_info@@6B@ ; RangeTester<PCBlocker_SInstanceList> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$RangeTester@UPCBlocker_SInstanceList@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$RangeTester@UPCBlocker_SInstanceList@@@@6B@
rdata$r	SEGMENT
??_R4?$RangeTester@UPCBlocker_SInstanceList@@@@6B@ DD 00H ; RangeTester<PCBlocker_SInstanceList>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$RangeTester@UPCBlocker_SInstanceList@@@@@8
	DD	FLAT:??_R3?$RangeTester@UPCBlocker_SInstanceList@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDe'
	DB	'corator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDec'
	DB	'orator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpd'
	DB	'ateDecorator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@N'
	DB	'EffectUpdateDecorator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEff'
	DB	'ectUpdateDecorator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffe'
	DB	'ctUpdateDecorator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecora'
	DB	'tor@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDeco'
	DB	'rator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SpherePackCallback@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SpherePackCallback@@8 DD FLAT:??_R0?AVSpherePackCallback@@@8 ; SpherePackCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R2SpherePackCallback@@8
rdata$r	SEGMENT
??_R2SpherePackCallback@@8 DD FLAT:??_R1A@?0A@EA@SpherePackCallback@@8 ; SpherePackCallback::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3SpherePackCallback@@8
rdata$r	SEGMENT
??_R3SpherePackCallback@@8 DD 00H			; SpherePackCallback::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSpherePackCallback@@@8
data$r	SEGMENT
??_R0?AVSpherePackCallback@@@8 DD FLAT:??_7type_info@@6B@ ; SpherePackCallback `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSpherePackCallback@@', 00H
data$r	ENDS
;	COMDAT ??_R4SpherePackCallback@@6B@
rdata$r	SEGMENT
??_R4SpherePackCallback@@6B@ DD 00H			; SpherePackCallback::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSpherePackCallback@@@8
	DD	FLAT:??_R3SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_7?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@6B@
CONST	SEGMENT
??_7?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@6B@ DD FLAT:??_R4?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@6B@ ; RangeTester<FGetShadowReceiverFromCollisionData>::`vftable'
	DD	FLAT:??_E?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEPAXI@Z
	DD	FLAT:?VisibilityCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?RayTraceCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?PointTest2dCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
;	COMDAT ??_7?$RangeTester@UFGetShadowReceiverFromHeightData@@@@6B@
CONST	SEGMENT
??_7?$RangeTester@UFGetShadowReceiverFromHeightData@@@@6B@ DD FLAT:??_R4?$RangeTester@UFGetShadowReceiverFromHeightData@@@@6B@ ; RangeTester<FGetShadowReceiverFromHeightData>::`vftable'
	DD	FLAT:??_E?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEPAXI@Z
	DD	FLAT:?VisibilityCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?RayTraceCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?PointTest2dCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MNAKBLAF@Delete?5Area?5?6?$AA@
CONST	SEGMENT
??_C@_0O@MNAKBLAF@Delete?5Area?5?6?$AA@ DB 'Delete Area ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GFILMBNJ@Delete?5Terrain?5?6?$AA@
CONST	SEGMENT
??_C@_0BB@GFILMBNJ@Delete?5Terrain?5?6?$AA@ DB 'Delete Terrain ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_7?$RangeTester@UPCBlocker_SInstanceList@@@@6B@
CONST	SEGMENT
??_7?$RangeTester@UPCBlocker_SInstanceList@@@@6B@ DD FLAT:??_R4?$RangeTester@UPCBlocker_SInstanceList@@@@6B@ ; RangeTester<PCBlocker_SInstanceList>::`vftable'
	DD	FLAT:??_E?$RangeTester@UPCBlocker_SInstanceList@@@@UAEPAXI@Z
	DD	FLAT:?VisibilityCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?RayTraceCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?PointTest2dCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
;	COMDAT ??_C@_0BK@IDOOHDBC@Update?3?3Load?5spent?5?$CFd?5ms?6?$AA@
CONST	SEGMENT
??_C@_0BK@IDOOHDBC@Update?3?3Load?5spent?5?$CFd?5ms?6?$AA@ DB 'Update::Lo'
	DB	'ad spent %d ms', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7SpherePackCallback@@6B@
CONST	SEGMENT
??_7SpherePackCallback@@6B@ DD FLAT:??_R4SpherePackCallback@@6B@ ; SpherePackCallback::`vftable'
	DD	FLAT:??_ESpherePackCallback@@UAEPAXI@Z
	DD	FLAT:?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushAreaToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0U12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushAreaToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0U12@@Z$0
__ehfuncinfo$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushAreaToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0U12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushAreaToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0U12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushTerrainToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0U12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushTerrainToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0U12@@Z$0
__ehfuncinfo$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushTerrainToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0U12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushTerrainToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0U12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$ForInRange@UFGetShadowReceiverFromCollisionData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromCollisionData@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$ForInRange@UFGetShadowReceiverFromCollisionData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromCollisionData@@@Z$0
__ehfuncinfo$??$ForInRange@UFGetShadowReceiverFromCollisionData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromCollisionData@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$ForInRange@UFGetShadowReceiverFromCollisionData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromCollisionData@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$ForInRange@UFGetShadowReceiverFromHeightData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromHeightData@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$ForInRange@UFGetShadowReceiverFromHeightData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromHeightData@@@Z$0
__ehfuncinfo$??$ForInRange@UFGetShadowReceiverFromHeightData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromHeightData@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$ForInRange@UFGetShadowReceiverFromHeightData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromHeightData@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__CollectCollisionShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__CollectCollisionShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?__CollectCollisionShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z$1
__ehfuncinfo$?__CollectCollisionShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?__CollectCollisionShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__CollectCollisionPCBlocker@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0M@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__CollectCollisionPCBlocker@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0M@Z$0
__ehfuncinfo$?__CollectCollisionPCBlocker@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0M@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__CollectCollisionPCBlocker@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0M@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__CollectShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__CollectShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z$0
__ehfuncinfo$?__CollectShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__CollectShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z$3
__ehfuncinfo$?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__UpdateGarvage@CMapOutdoor@@MAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__UpdateGarvage@CMapOutdoor@@MAEXXZ$0
__ehfuncinfo$?__UpdateGarvage@CMapOutdoor@@MAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__UpdateGarvage@CMapOutdoor@@MAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00$$QAPAV1@UFPCBlockerDistanceSort@@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 12
___formal$ = 36						; size = 4
??$_Pop_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00$$QAPAV1@UFPCBlockerDistanceSort@@PAH@Z PROC ; std::_Pop_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>, COMDAT

; 2394 : 	{	// pop *_First to *_Dest and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2395 : 	*_Dest = _Move(*_First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	f3 0f 7e 45 18	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  00011	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00013	89 08		 mov	 DWORD PTR [eax], ecx
  00015	8b cc		 mov	 ecx, esp
  00017	8b 45 20	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  0001a	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  0001d	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00021	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00024	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00027	2b c2		 sub	 eax, edx
  00029	c1 f8 02	 sar	 eax, 2
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@HH$$QAPAV1@UFPCBlockerDistanceSort@@@Z ; std::_Adjust_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>
  00035	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2398 : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$_Pop_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00$$QAPAV1@UFPCBlockerDistanceSort@@PAH@Z ENDP ; std::_Pop_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move_backward@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move_backward@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward<CGraphicObjectInstance * *,CGraphicObjectInstance * *>, COMDAT

; 2535 : 	{	// move [_First, _Last) backwards to [..., _Dest), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2536 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	56		 push	 esi

; 2537 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2538 : 		_Count * sizeof (*_First));

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000d	2b c8		 sub	 ecx, eax
  0000f	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00012	51		 push	 ecx
  00013	2b f1		 sub	 esi, ecx
  00015	50		 push	 eax
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 _memmove
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2539 : 	return (_Dest - _Count);

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi

; 2540 : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_Move_backward@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward<CGraphicObjectInstance * *,CGraphicObjectInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Pop_heap_0@PAPAVCGraphicObjectInstance@@PAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Val$ = 12						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 12
___formal$ = 28						; size = 4
??$_Pop_heap_0@PAPAVCGraphicObjectInstance@@PAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@0@Z PROC ; std::_Pop_heap_0<CGraphicObjectInstance * *,CGraphicObjectInstance *,FPCBlockerDistanceSort>, COMDAT

; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2395 : 	*_Dest = _Move(*_First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00006	f3 0f 7e 45 10	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  0000b	56		 push	 esi

; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  0000f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00012	8b cc		 mov	 ecx, esp

; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  00014	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00017	89 45 0c	 mov	 DWORD PTR __Val$[ebp], eax

; 2395 : 	*_Dest = _Move(*_First);

  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  0001f	2b f2		 sub	 esi, edx
  00021	8b 45 18	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  00024	83 ee 04	 sub	 esi, 4
  00027	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0002b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0002e	8d 45 0c	 lea	 eax, DWORD PTR __Val$[ebp]
  00031	50		 push	 eax
  00032	c1 fe 02	 sar	 esi, 2
  00035	56		 push	 esi
  00036	6a 00		 push	 0
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@HH$$QAPAV1@UFPCBlockerDistanceSort@@@Z ; std::_Adjust_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>
  0003e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2406 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2407 : 		_Move(_Val), _Pred, _Dist_type(_First));
; 2408 : 	}

  00041	5e		 pop	 esi
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??$_Pop_heap_0@PAPAVCGraphicObjectInstance@@PAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@0@Z ENDP ; std::_Pop_heap_0<CGraphicObjectInstance * *,CGraphicObjectInstance *,FPCBlockerDistanceSort>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@HH$$QAPAV1@UFPCBlockerDistanceSort@@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__First$GSCopy$1$ = -8					; size = 4
__Val$GSCopy$1$ = -4					; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 12
??$_Push_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@HH$$QAPAV1@UFPCBlockerDistanceSort@@@Z PROC ; std::_Push_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>, COMDAT

; 2313 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR __Hole$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 14	 mov	 esi, DWORD PTR __Val$[ebp]
  00011	57		 push	 edi

; 2314 : 	for (_Diff _Idx = (_Hole - 1) / 2;

  00012	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00015	89 4d f8	 mov	 DWORD PTR __First$GSCopy$1$[ebp], ecx
  00018	99		 cdq
  00019	2b c2		 sub	 eax, edx
  0001b	89 75 fc	 mov	 DWORD PTR __Val$GSCopy$1$[ebp], esi
  0001e	8b f8		 mov	 edi, eax
  00020	d1 ff		 sar	 edi, 1

; 2316 : 		_Idx = (_Hole - 1) / 2)

  00022	39 5d 10	 cmp	 DWORD PTR __Top$[ebp], ebx
  00025	0f 8d d9 00 00
	00		 jge	 $LN28@Push_heap
  0002b	eb 03 8d 49 00	 npad	 5
$LL3@Push_heap:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00030	8b 0c b9	 mov	 ecx, DWORD PTR [ecx+edi*4]
; File a:\vs\vc\include\algorithm

; 2316 : 		_Idx = (_Hole - 1) / 2)

  00033	8b 36		 mov	 esi, DWORD PTR [esi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00035	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  0003a	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0003c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00040	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  00045	f3 0f 11 45 f0	 movss	 DWORD PTR $T2[ebp], xmm0
  0004a	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0004f	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  00054	f3 0f 11 45 f4	 movss	 DWORD PTR $T3[ebp], xmm0
  00059	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0005e	f3 0f 5c 45 20	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  00063	f3 0f 11 45 ec	 movss	 DWORD PTR $T1[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00068	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0006d	f3 0f 10 55 f0	 movss	 xmm2, DWORD PTR $T2[ebp]
  00072	f3 0f 10 65 f4	 movss	 xmm4, DWORD PTR $T3[ebp]
; File a:\vs\vc\include\algorithm

; 2318 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  00077	8b 4d f8	 mov	 ecx, DWORD PTR __First$GSCopy$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0007a	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0007e	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]
  00083	f3 0f 5c 5d 1c	 subss	 xmm3, DWORD PTR __Pred$[ebp+4]
  00088	f3 0f 5c 4d 18	 subss	 xmm1, DWORD PTR __Pred$[ebp]
  0008d	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00092	f3 0f 5c 45 20	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00097	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0009b	f3 0f 59 e4	 mulss	 xmm4, xmm4
  0009f	f3 0f 59 db	 mulss	 xmm3, xmm3
  000a3	f3 0f 59 c9	 mulss	 xmm1, xmm1
  000a7	f3 0f 58 e2	 addss	 xmm4, xmm2
  000ab	f3 0f 10 55 ec	 movss	 xmm2, DWORD PTR $T1[ebp]
  000b0	f3 0f 59 d2	 mulss	 xmm2, xmm2
  000b4	f3 0f 58 d9	 addss	 xmm3, xmm1
  000b8	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000bc	f3 0f 58 e2	 addss	 xmm4, xmm2
  000c0	f3 0f 58 d8	 addss	 xmm3, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  000c4	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 2316 : 		_Idx = (_Hole - 1) / 2)

  000c7	76 2c		 jbe	 SHORT $LN29@Push_heap

; 2318 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  000c9	8b 04 b9	 mov	 eax, DWORD PTR [ecx+edi*4]
  000cc	8b 75 fc	 mov	 esi, DWORD PTR __Val$GSCopy$1$[ebp]
  000cf	89 04 99	 mov	 DWORD PTR [ecx+ebx*4], eax
  000d2	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  000d5	99		 cdq

; 2319 : 		_Hole = _Idx;

  000d6	8b df		 mov	 ebx, edi
  000d8	2b c2		 sub	 eax, edx
  000da	8b f8		 mov	 edi, eax
  000dc	d1 ff		 sar	 edi, 1
  000de	39 5d 10	 cmp	 DWORD PTR __Top$[ebp], ebx
  000e1	0f 8c 49 ff ff
	ff		 jl	 $LL3@Push_heap

; 2320 : 		}
; 2321 : 
; 2322 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

  000e7	8b c6		 mov	 eax, esi
  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	89 04 99	 mov	 DWORD PTR [ecx+ebx*4], eax
  000f0	5b		 pop	 ebx

; 2323 : 	}

  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
$LN29@Push_heap:

; 2320 : 		}
; 2321 : 
; 2322 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

  000f5	8b 45 fc	 mov	 eax, DWORD PTR __Val$GSCopy$1$[ebp]
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi
  000fa	8b 00		 mov	 eax, DWORD PTR [eax]
  000fc	89 04 99	 mov	 DWORD PTR [ecx+ebx*4], eax
  000ff	5b		 pop	 ebx

; 2323 : 	}

  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
$LN28@Push_heap:

; 2320 : 		}
; 2321 : 
; 2322 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

  00104	8b 06		 mov	 eax, DWORD PTR [esi]
  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	89 04 99	 mov	 DWORD PTR [ecx+ebx*4], eax
  0010b	5b		 pop	 ebx

; 2323 : 	}

  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c3		 ret	 0
??$_Push_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@HH$$QAPAV1@UFPCBlockerDistanceSort@@@Z ENDP ; std::_Push_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@QAVCTerrain@@PAV1@@std@@YAPAPAVCTerrain@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@QAVCTerrain@@PAV1@@std@@YAPAPAVCTerrain@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CTerrain * const,CTerrain *>, COMDAT

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 402  : 	_DEBUG_RANGE(_First, _Last);
; 403  : 	_DEBUG_POINTER(_Dest);
; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 407  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_copy@QAVCTerrain@@PAV1@@std@@YAPAPAVCTerrain@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CTerrain * const,CTerrain *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@QAVCArea@@PAV1@@std@@YAPAPAVCArea@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@QAVCArea@@PAV1@@std@@YAPAPAVCArea@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CArea * const,CArea *>, COMDAT

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 402  : 	_DEBUG_RANGE(_First, _Last);
; 403  : 	_DEBUG_POINTER(_Dest);
; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 407  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_copy@QAVCArea@@PAV1@@std@@YAPAPAVCArea@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CArea * const,CArea *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move_backward@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_backward@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00@Z PROC ; std::_Move_backward<CGraphicObjectInstance * *,CGraphicObjectInstance * *>, COMDAT

; 2546 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2536 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	56		 push	 esi

; 2537 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2538 : 		_Count * sizeof (*_First));

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000d	2b c8		 sub	 ecx, eax
  0000f	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00012	51		 push	 ecx
  00013	2b f1		 sub	 esi, ecx
  00015	50		 push	 eax
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 _memmove
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2547 : 	return (_Move_backward(_First, _Last,
; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi

; 2549 : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_Move_backward@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00@Z ENDP ; std::_Move_backward<CGraphicObjectInstance * *,CGraphicObjectInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Val$1 = 12						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 12
??$_Pop_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z PROC ; std::_Pop_heap<CGraphicObjectInstance * *,FPCBlockerDistanceSort>, COMDAT

; 2413 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2395 : 	*_Dest = _Move(*_First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00006	f3 0f 7e 45 10	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  0000b	56		 push	 esi

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  0000f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00012	8b cc		 mov	 ecx, esp

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  00014	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00017	89 45 0c	 mov	 DWORD PTR __Val$1[ebp], eax

; 2395 : 	*_Dest = _Move(*_First);

  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  0001f	2b f2		 sub	 esi, edx
  00021	8b 45 18	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  00024	83 ee 04	 sub	 esi, 4
  00027	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0002b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0002e	8d 45 0c	 lea	 eax, DWORD PTR __Val$1[ebp]
  00031	50		 push	 eax
  00032	c1 fe 02	 sar	 esi, 2
  00035	56		 push	 esi
  00036	6a 00		 push	 0
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@HH$$QAPAV1@UFPCBlockerDistanceSort@@@Z ; std::_Adjust_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>
  0003e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2414 : 	_Pop_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2415 : 		_Val_type(_First));
; 2416 : 	}

  00041	5e		 pop	 esi
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??$_Pop_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z ENDP ; std::_Pop_heap<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Adjust_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@HH$$QAPAV1@UFPCBlockerDistanceSort@@@Z
_TEXT	SEGMENT
__Top$1$ = -28						; size = 4
$T1 = -24						; size = 4
__Val$GSCopy$1$ = -20					; size = 4
$T2 = -16						; size = 4
__Bottom$GSCopy$1$ = -12				; size = 4
$T3 = -8						; size = 4
__First$GSCopy$1$ = -4					; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 12
??$_Adjust_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@HH$$QAPAV1@UFPCBlockerDistanceSort@@@Z PROC ; std::_Adjust_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>, COMDAT

; 2368 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	8b 4d 10	 mov	 ecx, DWORD PTR __Bottom$[ebp]
  00009	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000c	53		 push	 ebx
  0000d	8b 5d 0c	 mov	 ebx, DWORD PTR __Hole$[ebp]
  00010	56		 push	 esi
  00011	8b 75 14	 mov	 esi, DWORD PTR __Val$[ebp]
  00014	57		 push	 edi

; 2369 : 	_Diff _Top = _Hole;
; 2370 : 	_Diff _Idx = 2 * _Hole + 2;

  00015	8d 3c 5d 02 00
	00 00		 lea	 edi, DWORD PTR [ebx*2+2]
  0001c	89 55 fc	 mov	 DWORD PTR __First$GSCopy$1$[ebp], edx
  0001f	89 4d f4	 mov	 DWORD PTR __Bottom$GSCopy$1$[ebp], ecx
  00022	89 75 ec	 mov	 DWORD PTR __Val$GSCopy$1$[ebp], esi
  00025	89 5d e4	 mov	 DWORD PTR __Top$1$[ebp], ebx

; 2371 : 
; 2372 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  00028	3b f9		 cmp	 edi, ecx
  0002a	0f 8d b9 00 00
	00		 jge	 $LN32@Adjust_hea
$LL5@Adjust_hea:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00030	8b 0c ba	 mov	 ecx, DWORD PTR [edx+edi*4]
; File a:\vs\vc\include\algorithm

; 2374 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  00033	8b 74 ba fc	 mov	 esi, DWORD PTR [edx+edi*4-4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00037	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  0003c	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0003e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00042	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  00047	f3 0f 11 45 e8	 movss	 DWORD PTR $T1[ebp], xmm0
  0004c	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00051	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  00056	f3 0f 11 45 f8	 movss	 DWORD PTR $T3[ebp], xmm0
  0005b	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00060	f3 0f 5c 45 20	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  00065	f3 0f 11 45 f0	 movss	 DWORD PTR $T2[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  0006a	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0006f	f3 0f 10 55 e8	 movss	 xmm2, DWORD PTR $T1[ebp]
  00074	f3 0f 10 65 f8	 movss	 xmm4, DWORD PTR $T3[ebp]
  00079	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0007d	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00081	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]
  00086	f3 0f 5c 5d 1c	 subss	 xmm3, DWORD PTR __Pred$[ebp+4]
  0008b	f3 0f 5c 4d 18	 subss	 xmm1, DWORD PTR __Pred$[ebp]
  00090	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00095	f3 0f 5c 45 20	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0009a	f3 0f 59 e4	 mulss	 xmm4, xmm4
  0009e	f3 0f 59 db	 mulss	 xmm3, xmm3
  000a2	f3 0f 59 c9	 mulss	 xmm1, xmm1
  000a6	f3 0f 58 e2	 addss	 xmm4, xmm2
  000aa	f3 0f 10 55 f0	 movss	 xmm2, DWORD PTR $T2[ebp]
  000af	f3 0f 59 d2	 mulss	 xmm2, xmm2
  000b3	f3 0f 58 d9	 addss	 xmm3, xmm1
  000b7	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000bb	f3 0f 58 e2	 addss	 xmm4, xmm2
  000bf	f3 0f 58 d8	 addss	 xmm3, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  000c3	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 2374 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  000c6	76 01		 jbe	 SHORT $LN2@Adjust_hea

; 2375 : 			--_Idx;

  000c8	4f		 dec	 edi
$LN2@Adjust_hea:

; 2376 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  000c9	8b 55 fc	 mov	 edx, DWORD PTR __First$GSCopy$1$[ebp]
  000cc	8b 4d f4	 mov	 ecx, DWORD PTR __Bottom$GSCopy$1$[ebp]
  000cf	8b 04 ba	 mov	 eax, DWORD PTR [edx+edi*4]
  000d2	89 04 9a	 mov	 DWORD PTR [edx+ebx*4], eax

; 2377 : 		_Hole = _Idx;

  000d5	8b df		 mov	 ebx, edi
  000d7	8d 3c 7d 02 00
	00 00		 lea	 edi, DWORD PTR [edi*2+2]
  000de	3b f9		 cmp	 edi, ecx
  000e0	0f 8c 4a ff ff
	ff		 jl	 $LL5@Adjust_hea
  000e6	8b 75 ec	 mov	 esi, DWORD PTR __Val$GSCopy$1$[ebp]
$LN32@Adjust_hea:

; 2378 : 		}
; 2379 : 
; 2380 : 	if (_Idx == _Bottom)

  000e9	75 0a		 jne	 SHORT $LN1@Adjust_hea

; 2381 : 		{	// only child at bottom, move _Hole down to it
; 2382 : 		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));

  000eb	8b 44 8a fc	 mov	 eax, DWORD PTR [edx+ecx*4-4]
  000ef	89 04 9a	 mov	 DWORD PTR [edx+ebx*4], eax

; 2383 : 		_Hole = _Bottom - 1;

  000f2	8d 59 ff	 lea	 ebx, DWORD PTR [ecx-1]
$LN1@Adjust_hea:

; 2384 : 		}
; 2385 : 	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);

  000f5	f3 0f 7e 45 18	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  000fa	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000fd	8b 45 20	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  00100	8b cc		 mov	 ecx, esp
  00102	56		 push	 esi
  00103	ff 75 e4	 push	 DWORD PTR __Top$1$[ebp]
  00106	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0010a	53		 push	 ebx
  0010b	52		 push	 edx
  0010c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0010f	e8 00 00 00 00	 call	 ??$_Push_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@HH$$QAPAV1@UFPCBlockerDistanceSort@@@Z ; std::_Push_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>
  00114	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2386 : 	}

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
??$_Adjust_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@HH$$QAPAV1@UFPCBlockerDistanceSort@@@Z ENDP ; std::_Adjust_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$_Move@AAPAVCGraphicObjectInstance@@@std@@YA$$QAPAVCGraphicObjectInstance@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAPAVCGraphicObjectInstance@@@std@@YA$$QAPAVCGraphicObjectInstance@@AAPAV1@@Z PROC ; std::_Move<CGraphicObjectInstance * &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAPAVCGraphicObjectInstance@@@std@@YA$$QAPAVCGraphicObjectInstance@@AAPAV1@@Z ENDP ; std::_Move<CGraphicObjectInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAPAVCGraphicObjectInstance@@@std@@YAAAPAPAVCGraphicObjectInstance@@AAPAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAPAVCGraphicObjectInstance@@@std@@YAAAPAPAVCGraphicObjectInstance@@AAPAPAV1@@Z PROC ; std::forward<CGraphicObjectInstance * * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAPAVCGraphicObjectInstance@@@std@@YAAAPAPAVCGraphicObjectInstance@@AAPAPAV1@@Z ENDP ; std::forward<CGraphicObjectInstance * * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$swap@PAVCGraphicObjectInstance@@@std@@YAXAAPAVCGraphicObjectInstance@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAVCGraphicObjectInstance@@@std@@YAXAAPAVCGraphicObjectInstance@@0@Z PROC ; std::swap<CGraphicObjectInstance *>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 55   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@PAVCGraphicObjectInstance@@@std@@YAXAAPAVCGraphicObjectInstance@@0@Z ENDP ; std::swap<CGraphicObjectInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Med3@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00UFPCBlockerDistanceSort@@@Z
_TEXT	SEGMENT
__Last$GSCopy$1$ = -16					; size = 4
$T1 = -12						; size = 4
$T2 = -12						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
$T5 = -8						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
$T8 = -4						; size = 4
$T9 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 12
??$_Med3@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00UFPCBlockerDistanceSort@@@Z PROC ; std::_Med3<CGraphicObjectInstance * *,FPCBlockerDistanceSort>, COMDAT

; 3032 : 	{	// sort median of three elements to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR __Mid$[ebp]

; 3033 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  00012	8b 33		 mov	 esi, DWORD PTR [ebx]
  00014	89 45 f0	 mov	 DWORD PTR __Last$GSCopy$1$[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00017	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00019	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  0001e	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00020	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00024	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  00029	f3 0f 11 45 f8	 movss	 DWORD PTR $T6[ebp], xmm0
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00033	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  00038	f3 0f 11 45 fc	 movss	 DWORD PTR $T9[ebp], xmm0
  0003d	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00042	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  00047	f3 0f 11 45 f4	 movss	 DWORD PTR $T3[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  0004c	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00051	f3 0f 10 55 f8	 movss	 xmm2, DWORD PTR $T6[ebp]
  00056	f3 0f 10 65 fc	 movss	 xmm4, DWORD PTR $T9[ebp]
  0005b	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0005f	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  00063	f3 0f 5c 5d 14	 subss	 xmm3, DWORD PTR __Pred$[ebp]
  00068	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0006d	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  00072	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00077	f3 0f 5c 4d 1c	 subss	 xmm1, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0007c	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00080	f3 0f 59 db	 mulss	 xmm3, xmm3
  00084	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00088	f3 0f 58 e2	 addss	 xmm4, xmm2
  0008c	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR $T3[ebp]
  00091	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00095	f3 0f 58 d8	 addss	 xmm3, xmm0
  00099	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0009d	f3 0f 58 e2	 addss	 xmm4, xmm2
  000a1	f3 0f 58 d9	 addss	 xmm3, xmm1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  000a5	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3033 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  000a8	76 08		 jbe	 SHORT $LN22@Med3
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  000aa	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 53   : 	_Left = _Move(_Right);

  000ac	8b 03		 mov	 eax, DWORD PTR [ebx]
  000ae	89 07		 mov	 DWORD PTR [edi], eax

; 54   : 	_Right = _Move(_Tmp);

  000b0	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN22@Med3:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  000b2	8b 4d f0	 mov	 ecx, DWORD PTR __Last$GSCopy$1$[ebp]
; File a:\vs\vc\include\algorithm

; 3035 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

  000b5	8b 37		 mov	 esi, DWORD PTR [edi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  000b7	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000b9	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  000be	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000c0	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000c4	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  000c9	f3 0f 11 45 f4	 movss	 DWORD PTR $T2[ebp], xmm0
  000ce	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000d3	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  000d8	f3 0f 11 45 f8	 movss	 DWORD PTR $T5[ebp], xmm0
  000dd	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000e2	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  000e7	f3 0f 11 45 fc	 movss	 DWORD PTR $T8[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  000ec	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000f1	f3 0f 10 55 f8	 movss	 xmm2, DWORD PTR $T5[ebp]
  000f6	f3 0f 10 65 f4	 movss	 xmm4, DWORD PTR $T2[ebp]
  000fb	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000ff	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  00103	f3 0f 5c 5d 14	 subss	 xmm3, DWORD PTR __Pred$[ebp]
  00108	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0010d	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  00112	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00117	f3 0f 5c 4d 1c	 subss	 xmm1, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0011c	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00120	f3 0f 59 db	 mulss	 xmm3, xmm3
  00124	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00128	f3 0f 58 e2	 addss	 xmm4, xmm2
  0012c	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR $T8[ebp]
  00131	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00135	f3 0f 58 d8	 addss	 xmm3, xmm0
  00139	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0013d	f3 0f 58 e2	 addss	 xmm4, xmm2
  00141	f3 0f 58 d9	 addss	 xmm3, xmm1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00145	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3035 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

  00148	0f 86 a6 00 00
	00		 jbe	 $LN70@Med3
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  0014e	8b 55 f0	 mov	 edx, DWORD PTR __Last$GSCopy$1$[ebp]

; 53   : 	_Left = _Move(_Right);

  00151	8b 07		 mov	 eax, DWORD PTR [edi]
  00153	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00155	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00157	89 0f		 mov	 DWORD PTR [edi], ecx
; File a:\vs\vc\include\algorithm

; 3038 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  00159	8b 33		 mov	 esi, DWORD PTR [ebx]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  0015b	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00160	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00162	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00166	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  0016b	f3 0f 11 45 f4	 movss	 DWORD PTR $T1[ebp], xmm0
  00170	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00175	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  0017a	f3 0f 11 45 f8	 movss	 DWORD PTR $T4[ebp], xmm0
  0017f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00184	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  00189	f3 0f 11 45 fc	 movss	 DWORD PTR $T7[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  0018e	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00193	f3 0f 10 55 f8	 movss	 xmm2, DWORD PTR $T4[ebp]
  00198	f3 0f 10 65 f4	 movss	 xmm4, DWORD PTR $T1[ebp]
  0019d	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001a1	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  001a5	f3 0f 5c 5d 14	 subss	 xmm3, DWORD PTR __Pred$[ebp]
  001aa	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001af	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  001b4	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  001b9	f3 0f 5c 4d 1c	 subss	 xmm1, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  001be	f3 0f 59 e4	 mulss	 xmm4, xmm4
  001c2	f3 0f 59 db	 mulss	 xmm3, xmm3
  001c6	f3 0f 59 c0	 mulss	 xmm0, xmm0
  001ca	f3 0f 58 e2	 addss	 xmm4, xmm2
  001ce	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR $T7[ebp]
  001d3	f3 0f 59 d2	 mulss	 xmm2, xmm2
  001d7	f3 0f 58 d8	 addss	 xmm3, xmm0
  001db	f3 0f 59 c9	 mulss	 xmm1, xmm1
  001df	f3 0f 58 e2	 addss	 xmm4, xmm2
  001e3	f3 0f 58 d9	 addss	 xmm3, xmm1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  001e7	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3038 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  001ea	76 08		 jbe	 SHORT $LN70@Med3
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  001ec	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 53   : 	_Left = _Move(_Right);

  001ee	8b 03		 mov	 eax, DWORD PTR [ebx]
  001f0	89 07		 mov	 DWORD PTR [edi], eax

; 54   : 	_Right = _Move(_Tmp);

  001f2	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN70@Med3:
  001f4	5f		 pop	 edi
  001f5	5e		 pop	 esi
  001f6	5b		 pop	 ebx
; File a:\vs\vc\include\algorithm

; 3041 : 	}

  001f7	8b e5		 mov	 esp, ebp
  001f9	5d		 pop	 ebp
  001fa	c3		 ret	 0
??$_Med3@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00UFPCBlockerDistanceSort@@@Z ENDP ; std::_Med3<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PBQAVCTerrain@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_copy@PBQAVCTerrain@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z PROC ; std::_Uninit_copy<CTerrain * const *,CTerrain * *,std::_Wrap_alloc<std::allocator<CTerrain *> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));
; 417  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_copy@PBQAVCTerrain@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z ENDP ; std::_Uninit_copy<CTerrain * const *,CTerrain * *,std::_Wrap_alloc<std::allocator<CTerrain *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PBQAVCArea@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_copy@PBQAVCArea@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z PROC ; std::_Uninit_copy<CArea * const *,CArea * *,std::_Wrap_alloc<std::allocator<CArea *> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));
; 417  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_copy@PBQAVCArea@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z ENDP ; std::_Uninit_copy<CArea * const *,CArea * *,std::_Wrap_alloc<std::allocator<CArea *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVCTerrain@@PAV1@PAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCTerrain@@PAV1@PAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CTerrain *,CTerrain *,CTerrain *>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 475  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAVCTerrain@@PAV1@PAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CTerrain *,CTerrain *,CTerrain *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVCArea@@PAV1@PAV1@@std@@YAPAPAVCArea@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCArea@@PAV1@PAV1@@std@@YAPAPAVCArea@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CArea *,CArea *,CArea *>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 475  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAVCArea@@PAV1@PAV1@@std@@YAPAPAVCArea@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CArea *,CArea *,CArea *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVCGraphicObjectInstance@@PAV1@PAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCGraphicObjectInstance@@PAV1@PAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CGraphicObjectInstance *,CGraphicObjectInstance *,CGraphicObjectInstance *>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 475  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAVCGraphicObjectInstance@@PAV1@PAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CGraphicObjectInstance *,CGraphicObjectInstance *,CGraphicObjectInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@PAV1@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@0@Z
_TEXT	SEGMENT
tv773 = -32						; size = 4
__First$GSCopy$1$ = -28					; size = 4
__Next$1$ = -24						; size = 4
__Next1$1$ = -20					; size = 4
$T1 = -16						; size = 4
__First1$1$ = -16					; size = 4
$T2 = -12						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
$T5 = -8						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
$T8 = -4						; size = 4
$T9 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 12
___formal$ = 28						; size = 4
??$_Insertion_sort1@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@PAV1@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@0@Z PROC ; std::_Insertion_sort1<CGraphicObjectInstance * *,FPCBlockerDistanceSort,CGraphicObjectInstance *>, COMDAT

; 2999 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 3000 : 	if (_First != _Last)

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	89 75 e4	 mov	 DWORD PTR __First$GSCopy$1$[ebp], esi
  00010	3b f0		 cmp	 esi, eax
  00012	0f 84 4a 02 00
	00		 je	 $LN6@Insertion_

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  00018	57		 push	 edi
  00019	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  0001c	89 7d e8	 mov	 DWORD PTR __Next$1$[ebp], edi
  0001f	3b f8		 cmp	 edi, eax
  00021	0f 84 3a 02 00
	00		 je	 $LN60@Insertion_
  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	2b c6		 sub	 eax, esi
  0002e	89 45 e0	 mov	 DWORD PTR tv773[ebp], eax
  00031	53		 push	 ebx
$LL7@Insertion_:

; 3002 : 			{	// order next element
; 3003 : 			_BidIt _Next1 = _Next;
; 3004 : 			_Ty _Val = _Move(*_Next);

  00032	8b 1f		 mov	 ebx, DWORD PTR [edi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00034	8b cb		 mov	 ecx, ebx
; File a:\vs\vc\include\algorithm

; 3006 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

  00036	8b 36		 mov	 esi, DWORD PTR [esi]
  00038	89 7d ec	 mov	 DWORD PTR __Next1$1$[ebp], edi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  0003b	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00040	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00042	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00046	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  0004b	f3 0f 11 45 f8	 movss	 DWORD PTR $T6[ebp], xmm0
  00050	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00055	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  0005a	f3 0f 11 45 f4	 movss	 DWORD PTR $T3[ebp], xmm0
  0005f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00064	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  00069	f3 0f 11 45 fc	 movss	 DWORD PTR $T9[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  0006e	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00073	f3 0f 10 55 f8	 movss	 xmm2, DWORD PTR $T6[ebp]
  00078	f3 0f 10 65 f4	 movss	 xmm4, DWORD PTR $T3[ebp]
  0007d	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00081	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00085	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]
  0008a	f3 0f 5c 5d 14	 subss	 xmm3, DWORD PTR __Pred$[ebp+4]
  0008f	f3 0f 5c 4d 10	 subss	 xmm1, DWORD PTR __Pred$[ebp]
  00094	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00099	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0009e	f3 0f 59 e4	 mulss	 xmm4, xmm4
  000a2	f3 0f 59 db	 mulss	 xmm3, xmm3
  000a6	f3 0f 59 c9	 mulss	 xmm1, xmm1
  000aa	f3 0f 58 e2	 addss	 xmm4, xmm2
  000ae	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR $T9[ebp]
  000b3	f3 0f 59 d2	 mulss	 xmm2, xmm2
  000b7	f3 0f 58 d9	 addss	 xmm3, xmm1
  000bb	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000bf	f3 0f 58 e2	 addss	 xmm4, xmm2
  000c3	f3 0f 58 d8	 addss	 xmm3, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  000c7	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3006 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

  000ca	76 2e		 jbe	 SHORT $LN5@Insertion_
; File a:\vs\vc\include\xutility

; 2536 : 	ptrdiff_t _Count = _Last - _First;

  000cc	8b 45 e0	 mov	 eax, DWORD PTR tv773[ebp]

; 2537 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2538 : 		_Count * sizeof (*_First));

  000cf	8b 75 e4	 mov	 esi, DWORD PTR __First$GSCopy$1$[ebp]
  000d2	83 c0 fc	 add	 eax, -4			; fffffffcH
  000d5	03 c7		 add	 eax, edi
  000d7	c1 f8 02	 sar	 eax, 2
  000da	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  000e1	8b c7		 mov	 eax, edi
  000e3	51		 push	 ecx
  000e4	2b c1		 sub	 eax, ecx
  000e6	83 c0 04	 add	 eax, 4
  000e9	56		 push	 esi
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 _memmove
  000f0	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\algorithm

; 3009 : 				*_First = _Move(_Val);

  000f3	89 1e		 mov	 DWORD PTR [esi], ebx

; 3010 : 				}
; 3011 : 			else

  000f5	e9 57 01 00 00	 jmp	 $LN4@Insertion_
$LN5@Insertion_:

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  000fa	8d 77 fc	 lea	 esi, DWORD PTR [edi-4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  000fd	8b cb		 mov	 ecx, ebx
; File a:\vs\vc\include\algorithm

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  000ff	89 75 f0	 mov	 DWORD PTR __First1$1$[ebp], esi

; 3015 : 					_Next1 = _First1)

  00102	8b 36		 mov	 esi, DWORD PTR [esi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00104	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00109	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0010b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0010f	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  00114	f3 0f 11 45 f8	 movss	 DWORD PTR $T5[ebp], xmm0
  00119	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0011e	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  00123	f3 0f 11 45 fc	 movss	 DWORD PTR $T7[ebp], xmm0
  00128	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0012d	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  00132	f3 0f 11 45 f4	 movss	 DWORD PTR $T2[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00137	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0013c	f3 0f 10 55 f8	 movss	 xmm2, DWORD PTR $T5[ebp]
  00141	f3 0f 10 65 fc	 movss	 xmm4, DWORD PTR $T7[ebp]
  00146	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0014a	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0014e	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]
  00153	f3 0f 5c 5d 14	 subss	 xmm3, DWORD PTR __Pred$[ebp+4]
  00158	f3 0f 5c 4d 10	 subss	 xmm1, DWORD PTR __Pred$[ebp]
  0015d	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00162	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00167	f3 0f 59 e4	 mulss	 xmm4, xmm4
  0016b	f3 0f 59 db	 mulss	 xmm3, xmm3
  0016f	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00173	f3 0f 58 e2	 addss	 xmm4, xmm2
  00177	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR $T2[ebp]
  0017c	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00180	f3 0f 58 d9	 addss	 xmm3, xmm1
  00184	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00188	f3 0f 58 e2	 addss	 xmm4, xmm2
  0018c	f3 0f 58 d8	 addss	 xmm3, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00190	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3015 : 					_Next1 = _First1)

  00193	0f 86 b0 00 00
	00		 jbe	 $LN1@Insertion_
  00199	8b 7d f0	 mov	 edi, DWORD PTR __First1$1$[ebp]
  0019c	8d 64 24 00	 npad	 4
$LL3@Insertion_:

; 3016 : 					*_Next1 = _Move(*_First1);	// move hole down

  001a0	8b 4d ec	 mov	 ecx, DWORD PTR __Next1$1$[ebp]
  001a3	8b 07		 mov	 eax, DWORD PTR [edi]
  001a5	89 7d ec	 mov	 DWORD PTR __Next1$1$[ebp], edi
  001a8	83 ef 04	 sub	 edi, 4
  001ab	89 01		 mov	 DWORD PTR [ecx], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  001ad	8b cb		 mov	 ecx, ebx
; File a:\vs\vc\include\algorithm

; 3015 : 					_Next1 = _First1)

  001af	8b 37		 mov	 esi, DWORD PTR [edi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  001b1	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  001b6	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001b8	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001bc	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  001c1	f3 0f 11 45 fc	 movss	 DWORD PTR $T8[ebp], xmm0
  001c6	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001cb	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  001d0	f3 0f 11 45 f0	 movss	 DWORD PTR $T1[ebp], xmm0
  001d5	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001da	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  001df	f3 0f 11 45 f8	 movss	 DWORD PTR $T4[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  001e4	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  001e9	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR $T8[ebp]
  001ee	f3 0f 10 65 f0	 movss	 xmm4, DWORD PTR $T1[ebp]
  001f3	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001f7	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  001fb	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]
  00200	f3 0f 5c 5d 14	 subss	 xmm3, DWORD PTR __Pred$[ebp+4]
  00205	f3 0f 5c 4d 10	 subss	 xmm1, DWORD PTR __Pred$[ebp]
  0020a	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0020f	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00214	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00218	f3 0f 59 db	 mulss	 xmm3, xmm3
  0021c	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00220	f3 0f 58 e2	 addss	 xmm4, xmm2
  00224	f3 0f 10 55 f8	 movss	 xmm2, DWORD PTR $T4[ebp]
  00229	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0022d	f3 0f 58 d9	 addss	 xmm3, xmm1
  00231	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00235	f3 0f 58 e2	 addss	 xmm4, xmm2
  00239	f3 0f 58 d8	 addss	 xmm3, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  0023d	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3015 : 					_Next1 = _First1)

  00240	0f 87 5a ff ff
	ff		 ja	 $LL3@Insertion_
  00246	8b 7d e8	 mov	 edi, DWORD PTR __Next$1$[ebp]
$LN1@Insertion_:

; 3017 : 				*_Next1 = _Move(_Val);	// insert element in hole

  00249	8b 4d ec	 mov	 ecx, DWORD PTR __Next1$1$[ebp]
  0024c	8b 75 e4	 mov	 esi, DWORD PTR __First$GSCopy$1$[ebp]
  0024f	89 19		 mov	 DWORD PTR [ecx], ebx
$LN4@Insertion_:

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  00251	83 c7 04	 add	 edi, 4
  00254	89 7d e8	 mov	 DWORD PTR __Next$1$[ebp], edi
  00257	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  0025a	0f 85 d2 fd ff
	ff		 jne	 $LL7@Insertion_
  00260	5b		 pop	 ebx
$LN60@Insertion_:
  00261	5f		 pop	 edi
$LN6@Insertion_:
  00262	5e		 pop	 esi

; 3018 : 				}
; 3019 : 			}
; 3020 : 	}

  00263	8b e5		 mov	 esp, ebp
  00265	5d		 pop	 ebp
  00266	c3		 ret	 0
??$_Insertion_sort1@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@PAV1@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@0@Z ENDP ; std::_Insertion_sort1<CGraphicObjectInstance * *,FPCBlockerDistanceSort,CGraphicObjectInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Sort_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Val$1 = 12						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 12
??$_Sort_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z PROC ; std::_Sort_heap<CGraphicObjectInstance * *,FPCBlockerDistanceSort>, COMDAT

; 2475 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2476 : 	for (; 1 < _Last - _First; --_Last)

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000b	2b f7		 sub	 esi, edi
  0000d	8b c6		 mov	 eax, esi
  0000f	83 e0 fc	 and	 eax, -4			; fffffffcH
  00012	83 f8 04	 cmp	 eax, 4
  00015	7e 4c		 jle	 SHORT $LN1@Sort_heap
  00017	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL3@Sort_heap:

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  00020	8b 44 37 fc	 mov	 eax, DWORD PTR [edi+esi-4]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00024	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00027	f3 0f 7e 45 10	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  0002c	8b cc		 mov	 ecx, esp

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  0002e	89 45 0c	 mov	 DWORD PTR __Val$1[ebp], eax

; 2395 : 	*_Dest = _Move(*_First);

  00031	8b 07		 mov	 eax, DWORD PTR [edi]
  00033	89 44 37 fc	 mov	 DWORD PTR [edi+esi-4], eax

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00037	83 c6 fc	 add	 esi, -4			; fffffffcH
  0003a	8b 45 18	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  0003d	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00041	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00044	8d 45 0c	 lea	 eax, DWORD PTR __Val$1[ebp]
  00047	50		 push	 eax
  00048	8b c6		 mov	 eax, esi
  0004a	c1 f8 02	 sar	 eax, 2
  0004d	50		 push	 eax
  0004e	6a 00		 push	 0
  00050	57		 push	 edi
  00051	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@HH$$QAPAV1@UFPCBlockerDistanceSort@@@Z ; std::_Adjust_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>

; 2476 : 	for (; 1 < _Last - _First; --_Last)

  00056	8b c6		 mov	 eax, esi

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00058	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2476 : 	for (; 1 < _Last - _First; --_Last)

  0005b	83 e0 fc	 and	 eax, -4			; fffffffcH
  0005e	83 f8 04	 cmp	 eax, 4
  00061	7f bd		 jg	 SHORT $LL3@Sort_heap
$LN1@Sort_heap:

; 2477 : 		_Pop_heap(_First, _Last, _Pred);
; 2478 : 	}

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
??$_Sort_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z ENDP ; std::_Sort_heap<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Make_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@PAH0@Z
_TEXT	SEGMENT
__Pred$4$ = -56						; size = 8
$T1 = -48						; size = 4
$T2 = -44						; size = 4
__Bottom$1$ = -40					; size = 4
__Val$3 = -36						; size = 4
__Pred$5$ = -32						; size = 4
$T4 = -28						; size = 4
__Hole$1$ = -24						; size = 4
tv508 = -20						; size = 4
__Hole$1$ = -16						; size = 4
__Pred$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 12
___formal$ = 28						; size = 4
___formal$ = 32						; size = 4
??$_Make_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@PAH0@Z PROC ; std::_Make_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>, COMDAT

; 2442 : 	{	// make nontrivial [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]

; 2443 : 	_Diff _Bottom = _Last - _First;

  0000e	2b f3		 sub	 esi, ebx
  00010	c1 fe 02	 sar	 esi, 2

; 2444 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  00013	8b c6		 mov	 eax, esi
  00015	89 75 d8	 mov	 DWORD PTR __Bottom$1$[ebp], esi
  00018	99		 cdq
  00019	2b c2		 sub	 eax, edx
  0001b	8b d0		 mov	 edx, eax
  0001d	d1 fa		 sar	 edx, 1
  0001f	57		 push	 edi
  00020	85 d2		 test	 edx, edx
  00022	0f 8e 43 01 00
	00		 jle	 $LN1@Make_heap
  00028	8d 3c 55 02 00
	00 00		 lea	 edi, DWORD PTR [edx*2+2]
  0002f	90		 npad	 1
$LL2@Make_heap:

; 2445 : 		{	// reheap top half, bottom to top
; 2446 : 		--_Hole;
; 2447 : 		_Ty _Val = _Move(*(_First + _Hole));

  00030	8b 44 93 fc	 mov	 eax, DWORD PTR [ebx+edx*4-4]
  00034	4a		 dec	 edx

; 2448 : 		_Adjust_heap(_First, _Hole, _Bottom,
; 2449 : 			_Move(_Val), _Pred);

  00035	f3 0f 7e 45 10	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  0003a	83 ef 02	 sub	 edi, 2
  0003d	89 45 dc	 mov	 DWORD PTR __Val$3[ebp], eax
  00040	8b ca		 mov	 ecx, edx
  00042	8b 45 18	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  00045	89 55 f0	 mov	 DWORD PTR __Hole$1$[ebp], edx
  00048	89 7d ec	 mov	 DWORD PTR tv508[ebp], edi
  0004b	66 0f d6 45 c8	 movq	 QWORD PTR __Pred$4$[ebp], xmm0
  00050	66 0f d6 45 f4	 movq	 QWORD PTR __Pred$[ebp], xmm0
  00055	89 45 e0	 mov	 DWORD PTR __Pred$5$[ebp], eax
  00058	89 45 fc	 mov	 DWORD PTR __Pred$[ebp+8], eax
  0005b	89 4d e8	 mov	 DWORD PTR __Hole$1$[ebp], ecx

; 2372 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  0005e	3b fe		 cmp	 edi, esi
  00060	0f 8d cb 00 00
	00		 jge	 $LN11@Make_heap
  00066	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL13@Make_heap:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00070	8b 0c bb	 mov	 ecx, DWORD PTR [ebx+edi*4]
; File a:\vs\vc\include\algorithm

; 2374 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  00073	8b 74 bb fc	 mov	 esi, DWORD PTR [ebx+edi*4-4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00077	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  0007c	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0007e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00082	f3 0f 5c 45 f4	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  00087	f3 0f 11 45 d0	 movss	 DWORD PTR $T1[ebp], xmm0
  0008c	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00091	f3 0f 5c 45 f8	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  00096	f3 0f 11 45 d4	 movss	 DWORD PTR $T2[ebp], xmm0
  0009b	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000a0	f3 0f 5c 45 fc	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  000a5	f3 0f 11 45 e4	 movss	 DWORD PTR $T4[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  000aa	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000af	f3 0f 10 55 d4	 movss	 xmm2, DWORD PTR $T2[ebp]
  000b4	f3 0f 10 65 d0	 movss	 xmm4, DWORD PTR $T1[ebp]
  000b9	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000bd	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  000c1	f3 0f 5c 5d f4	 subss	 xmm3, DWORD PTR __Pred$[ebp]
  000c6	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000cb	f3 0f 5c 45 f8	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  000d0	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  000d5	f3 0f 5c 4d fc	 subss	 xmm1, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000da	f3 0f 59 e4	 mulss	 xmm4, xmm4
  000de	f3 0f 59 db	 mulss	 xmm3, xmm3
  000e2	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000e6	f3 0f 58 e2	 addss	 xmm4, xmm2
  000ea	f3 0f 10 55 e4	 movss	 xmm2, DWORD PTR $T4[ebp]
  000ef	f3 0f 59 d2	 mulss	 xmm2, xmm2
  000f3	f3 0f 58 d8	 addss	 xmm3, xmm0
  000f7	f3 0f 59 c9	 mulss	 xmm1, xmm1
  000fb	f3 0f 58 e2	 addss	 xmm4, xmm2
  000ff	f3 0f 58 d9	 addss	 xmm3, xmm1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00103	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 2374 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  00106	76 01		 jbe	 SHORT $LN10@Make_heap

; 2375 : 			--_Idx;

  00108	4f		 dec	 edi
$LN10@Make_heap:

; 2376 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  00109	8b 4d e8	 mov	 ecx, DWORD PTR __Hole$1$[ebp]
  0010c	8b 04 bb	 mov	 eax, DWORD PTR [ebx+edi*4]
  0010f	8b 75 d8	 mov	 esi, DWORD PTR __Bottom$1$[ebp]
  00112	89 04 8b	 mov	 DWORD PTR [ebx+ecx*4], eax

; 2377 : 		_Hole = _Idx;

  00115	8b cf		 mov	 ecx, edi
  00117	8d 3c 7d 02 00
	00 00		 lea	 edi, DWORD PTR [edi*2+2]
  0011e	89 4d e8	 mov	 DWORD PTR __Hole$1$[ebp], ecx
  00121	3b fe		 cmp	 edi, esi
  00123	0f 8c 47 ff ff
	ff		 jl	 $LL13@Make_heap
  00129	f3 0f 7e 45 c8	 movq	 xmm0, QWORD PTR __Pred$4$[ebp]
  0012e	8b 55 f0	 mov	 edx, DWORD PTR __Hole$1$[ebp]
$LN11@Make_heap:

; 2378 : 		}
; 2379 : 
; 2380 : 	if (_Idx == _Bottom)

  00131	3b fe		 cmp	 edi, esi
  00133	75 0a		 jne	 SHORT $LN9@Make_heap

; 2381 : 		{	// only child at bottom, move _Hole down to it
; 2382 : 		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));

  00135	8b 44 b3 fc	 mov	 eax, DWORD PTR [ebx+esi*4-4]
  00139	89 04 8b	 mov	 DWORD PTR [ebx+ecx*4], eax

; 2383 : 		_Hole = _Bottom - 1;

  0013c	8d 4e ff	 lea	 ecx, DWORD PTR [esi-1]
$LN9@Make_heap:

; 2384 : 		}
; 2385 : 	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);

  0013f	8b 7d e0	 mov	 edi, DWORD PTR __Pred$5$[ebp]
  00142	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00145	8b c4		 mov	 eax, esp
  00147	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0014b	89 78 08	 mov	 DWORD PTR [eax+8], edi
  0014e	8d 45 dc	 lea	 eax, DWORD PTR __Val$3[ebp]
  00151	50		 push	 eax
  00152	52		 push	 edx
  00153	51		 push	 ecx
  00154	53		 push	 ebx
  00155	e8 00 00 00 00	 call	 ??$_Push_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@HH$$QAPAV1@UFPCBlockerDistanceSort@@@Z ; std::_Push_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>

; 2444 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  0015a	8b 55 f0	 mov	 edx, DWORD PTR __Hole$1$[ebp]

; 2384 : 		}
; 2385 : 	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);

  0015d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2444 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  00160	8b 7d ec	 mov	 edi, DWORD PTR tv508[ebp]
  00163	85 d2		 test	 edx, edx
  00165	0f 8f c5 fe ff
	ff		 jg	 $LL2@Make_heap
$LN1@Make_heap:

; 2450 : 		}
; 2451 : 	}

  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c3		 ret	 0
??$_Make_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@PAH0@Z ENDP ; std::_Make_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVCGraphicObjectInstance@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVCGraphicObjectInstance@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@@Z PROC ; std::_Val_type<CGraphicObjectInstance * *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAVCGraphicObjectInstance@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@@Z ENDP ; std::_Val_type<CGraphicObjectInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Dist_type@PAPAVCGraphicObjectInstance@@@std@@YAPAHPAPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAPAVCGraphicObjectInstance@@@std@@YAPAHPAPAVCGraphicObjectInstance@@@Z PROC ; std::_Dist_type<CGraphicObjectInstance * *>, COMDAT

; 706  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 707  : 	}

  00002	c3		 ret	 0
??$_Dist_type@PAPAVCGraphicObjectInstance@@@std@@YAPAHPAPAVCGraphicObjectInstance@@@Z ENDP ; std::_Dist_type<CGraphicObjectInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0AAPAPAVCGraphicObjectInstance@@AAPAPAV0@X@?$pair@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@QAE@AAPAPAVCGraphicObjectInstance@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAPAVCGraphicObjectInstance@@AAPAPAV0@X@?$pair@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@QAE@AAPAPAVCGraphicObjectInstance@@0@Z PROC ; std::pair<CGraphicObjectInstance * *,CGraphicObjectInstance * *>::pair<CGraphicObjectInstance * *,CGraphicObjectInstance * *><CGraphicObjectInstance * * &,CGraphicObjectInstance * * &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAPAPAVCGraphicObjectInstance@@AAPAPAV0@X@?$pair@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@QAE@AAPAPAVCGraphicObjectInstance@@0@Z ENDP ; std::pair<CGraphicObjectInstance * *,CGraphicObjectInstance * *>::pair<CGraphicObjectInstance * *,CGraphicObjectInstance * *><CGraphicObjectInstance * * &,CGraphicObjectInstance * * &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$iter_swap@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAXPAPAVCGraphicObjectInstance@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAXPAPAVCGraphicObjectInstance@@0@Z PROC ; std::iter_swap<CGraphicObjectInstance * *,CGraphicObjectInstance * *>, COMDAT

; 27   : 	{	// swap *_Left and *_Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 30   : 
; 31   : 		// TEMPLATE FUNCTION swap
; 32   : template<class _Ty,
; 33   : 	size_t _Size> inline
; 34   : 	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
; 35   : 		_NOEXCEPT_OP(_NOEXCEPT_OP(swap(*_Left, *_Right)))
; 36   : 	{	// exchange arrays stored at _Left and _Right
; 37   : 	if (&_Left != &_Right)
; 38   : 		{	// worth swapping, swap ranges
; 39   : 		_Ty *_First1 = _Left;
; 40   : 		_Ty *_Last1 = _First1 + _Size;
; 41   : 		_Ty *_First2 = _Right;
; 42   : 		for (; _First1 != _Last1; ++_First1, ++_First2)
; 43   : 			_STD iter_swap(_First1, _First2);
; 44   : 		}
; 45   : 	}
; 46   : 
; 47   : template<class _Ty> inline
; 48   : 	void swap(_Ty& _Left, _Ty& _Right)
; 49   : 		_NOEXCEPT_OP(is_nothrow_move_constructible<_Ty>::value
; 50   : 			&& is_nothrow_move_assignable<_Ty>::value)
; 51   : 	{	// exchange values stored at _Left and _Right
; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi

; 30   : 
; 31   : 		// TEMPLATE FUNCTION swap
; 32   : template<class _Ty,
; 33   : 	size_t _Size> inline
; 34   : 	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
; 35   : 		_NOEXCEPT_OP(_NOEXCEPT_OP(swap(*_Left, *_Right)))
; 36   : 	{	// exchange arrays stored at _Left and _Right
; 37   : 	if (&_Left != &_Right)
; 38   : 		{	// worth swapping, swap ranges
; 39   : 		_Ty *_First1 = _Left;
; 40   : 		_Ty *_Last1 = _First1 + _Size;
; 41   : 		_Ty *_First2 = _Right;
; 42   : 		for (; _First1 != _Last1; ++_First1, ++_First2)
; 43   : 			_STD iter_swap(_First1, _First2);
; 44   : 		}
; 45   : 	}
; 46   : 
; 47   : template<class _Ty> inline
; 48   : 	void swap(_Ty& _Left, _Ty& _Right)
; 49   : 		_NOEXCEPT_OP(is_nothrow_move_constructible<_Ty>::value
; 50   : 			&& is_nothrow_move_assignable<_Ty>::value)
; 51   : 	{	// exchange values stored at _Left and _Right
; 52   : 	_Ty _Tmp = _Move(_Left);

  0000a	8b 32		 mov	 esi, DWORD PTR [edx]

; 53   : 	_Left = _Move(_Right);

  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 28   : 	swap(*_Left, *_Right);
; 29   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$iter_swap@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAXPAPAVCGraphicObjectInstance@@0@Z ENDP ; std::iter_swap<CGraphicObjectInstance * *,CGraphicObjectInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Median@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00UFPCBlockerDistanceSort@@@Z
_TEXT	SEGMENT
tv177 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 12
??$_Median@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00UFPCBlockerDistanceSort@@@Z PROC ; std::_Median<CGraphicObjectInstance * *,FPCBlockerDistanceSort>, COMDAT

; 3046 : 	{	// sort median element to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3047 : 	if (40 < _Last - _First)

  00004	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00007	8b c2		 mov	 eax, edx

; 3050 : 		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);

  00009	f3 0f 7e 45 14	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00013	2b c6		 sub	 eax, esi
  00015	57		 push	 edi
  00016	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00019	c1 f8 02	 sar	 eax, 2
  0001c	8b cc		 mov	 ecx, esp
  0001e	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00022	83 f8 28	 cmp	 eax, 40			; 00000028H
  00025	0f 8e a6 00 00
	00		 jle	 $LN2@Median

; 3048 : 		{	// median of nine
; 3049 : 		size_t _Step = (_Last - _First + 1) / 8;

  0002b	40		 inc	 eax
  0002c	99		 cdq
  0002d	83 e2 07	 and	 edx, 7
  00030	03 c2		 add	 eax, edx
  00032	c1 f8 03	 sar	 eax, 3

; 3050 : 		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);

  00035	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0003c	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  00043	89 55 fc	 mov	 DWORD PTR tv177[ebp], edx
  00046	8b 45 1c	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  00049	8d 1c 37	 lea	 ebx, DWORD PTR [edi+esi]
  0004c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0004f	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  00052	50		 push	 eax
  00053	53		 push	 ebx
  00054	56		 push	 esi
  00055	e8 00 00 00 00	 call	 ??$_Med3@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00UFPCBlockerDistanceSort@@@Z ; std::_Med3<CGraphicObjectInstance * *,FPCBlockerDistanceSort>

; 3051 : 		_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  0005a	8b 5d 0c	 mov	 ebx, DWORD PTR __Mid$[ebp]
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	f3 0f 7e 45 14	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  00065	8b cc		 mov	 ecx, esp
  00067	8b 45 1c	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  0006a	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0006e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00071	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  00074	50		 push	 eax
  00075	8b c3		 mov	 eax, ebx
  00077	2b c7		 sub	 eax, edi
  00079	53		 push	 ebx
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ??$_Med3@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00UFPCBlockerDistanceSort@@@Z ; std::_Med3<CGraphicObjectInstance * *,FPCBlockerDistanceSort>

; 3052 : 		_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

  00080	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
  00086	f3 0f 7e 45 14	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  0008b	8b cc		 mov	 ecx, esp
  0008d	8b 45 1c	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  00090	8b f2		 mov	 esi, edx
  00092	2b f7		 sub	 esi, edi
  00094	52		 push	 edx
  00095	2b 55 fc	 sub	 edx, DWORD PTR tv177[ebp]
  00098	56		 push	 esi
  00099	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0009d	52		 push	 edx
  0009e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  000a1	e8 00 00 00 00	 call	 ??$_Med3@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00UFPCBlockerDistanceSort@@@Z ; std::_Med3<CGraphicObjectInstance * *,FPCBlockerDistanceSort>

; 3053 : 		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);

  000a6	f3 0f 7e 45 14	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ae	8b 45 1c	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  000b1	8b cc		 mov	 ecx, esp
  000b3	56		 push	 esi
  000b4	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  000b8	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  000bb	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000be	03 c7		 add	 eax, edi
  000c0	53		 push	 ebx
  000c1	50		 push	 eax

; 3054 : 		}
; 3055 : 	else
; 3056 : 		_Med3(_First, _Mid, _Last, _Pred);

  000c2	e8 00 00 00 00	 call	 ??$_Med3@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00UFPCBlockerDistanceSort@@@Z ; std::_Med3<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
  000c7	83 c4 18	 add	 esp, 24			; 00000018H

; 3057 : 	}

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
$LN2@Median:

; 3054 : 		}
; 3055 : 	else
; 3056 : 		_Med3(_First, _Mid, _Last, _Pred);

  000d1	8b 45 1c	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  000d4	52		 push	 edx
  000d5	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  000d8	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  000db	56		 push	 esi
  000dc	e8 00 00 00 00	 call	 ??$_Med3@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00UFPCBlockerDistanceSort@@@Z ; std::_Med3<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
  000e1	83 c4 18	 add	 esp, 24			; 00000018H

; 3057 : 	}

  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
??$_Median@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00UFPCBlockerDistanceSort@@@Z ENDP ; std::_Median<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@PAPAVCTerrain@@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@2@@std@@YAPAPAVCTerrain@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@PAPAVCTerrain@@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@2@@std@@YAPAPAVCTerrain@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,CTerrain * *,std::_Wrap_alloc<std::allocator<CTerrain *> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	2b c8		 sub	 ecx, eax
  0000b	c1 f9 02	 sar	 ecx, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 8d 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*4]
  00016	56		 push	 esi
  00017	50		 push	 eax
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@PAPAVCTerrain@@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@2@@std@@YAPAPAVCTerrain@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,CTerrain * *,std::_Wrap_alloc<std::allocator<CTerrain *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@PAPAVCArea@@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@2@@std@@YAPAPAVCArea@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@PAPAVCArea@@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@2@@std@@YAPAPAVCArea@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,CArea * *,std::_Wrap_alloc<std::allocator<CArea *> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	2b c8		 sub	 ecx, eax
  0000b	c1 f9 02	 sar	 ecx, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 8d 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*4]
  00016	56		 push	 esi
  00017	50		 push	 eax
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@PAPAVCArea@@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@2@@std@@YAPAPAVCArea@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,CArea * *,std::_Wrap_alloc<std::allocator<CArea *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVCTerrain@@PAPAV1@@std@@YAAAPAPAVCTerrain@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVCTerrain@@PAPAV1@@std@@YAAAPAPAVCTerrain@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<CTerrain * *,CTerrain * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAPAVCTerrain@@PAPAV1@@std@@YAAAPAPAVCTerrain@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<CTerrain * *,CTerrain * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVCTerrain@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVCTerrain@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z PROC ; std::_Uninit_move<CTerrain * *,CTerrain * *,std::_Wrap_alloc<std::allocator<CTerrain *> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAPAVCTerrain@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z ENDP ; std::_Uninit_move<CTerrain * *,CTerrain * *,std::_Wrap_alloc<std::allocator<CTerrain *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVCTerrain@@@std@@YAPAPAVCTerrain@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVCTerrain@@@std@@YAPAPAVCTerrain@@PAPAV1@@Z PROC ; std::_Unchecked<CTerrain * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVCTerrain@@@std@@YAPAPAVCTerrain@@PAPAV1@@Z ENDP ; std::_Unchecked<CTerrain * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVCArea@@PAPAV1@@std@@YAAAPAPAVCArea@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVCArea@@PAPAV1@@std@@YAAAPAPAVCArea@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<CArea * *,CArea * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAPAVCArea@@PAPAV1@@std@@YAAAPAPAVCArea@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<CArea * *,CArea * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVCArea@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVCArea@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z PROC ; std::_Uninit_move<CArea * *,CArea * *,std::_Wrap_alloc<std::allocator<CArea *> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAPAVCArea@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z ENDP ; std::_Uninit_move<CArea * *,CArea * *,std::_Wrap_alloc<std::allocator<CArea *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVCArea@@@std@@YAPAPAVCArea@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVCArea@@@std@@YAPAPAVCArea@@PAPAV1@@Z PROC ; std::_Unchecked<CArea * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVCArea@@@std@@YAPAPAVCArea@@PAPAV1@@Z ENDP ; std::_Unchecked<CArea * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAAAPAPAVCGraphicObjectInstance@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAAAPAPAVCGraphicObjectInstance@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<CGraphicObjectInstance * *,CGraphicObjectInstance * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAPAVCGraphicObjectInstance@@PAPAV1@@std@@YAAAPAPAVCGraphicObjectInstance@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<CGraphicObjectInstance * *,CGraphicObjectInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVCGraphicObjectInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVCGraphicObjectInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@@Z PROC ; std::_Uninit_move<CGraphicObjectInstance * *,CGraphicObjectInstance * *,std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAPAVCGraphicObjectInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@@Z ENDP ; std::_Uninit_move<CGraphicObjectInstance * *,CGraphicObjectInstance * *,std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVCGraphicObjectInstance@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVCGraphicObjectInstance@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@@Z PROC ; std::_Unchecked<CGraphicObjectInstance * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVCGraphicObjectInstance@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@@Z ENDP ; std::_Unchecked<CGraphicObjectInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCTerrain@@AAPAV1@@?$allocator@PAVCTerrain@@@std@@QAEXPAPAVCTerrain@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCTerrain@@AAPAV1@@?$allocator@PAVCTerrain@@@std@@QAEXPAPAVCTerrain@@AAPAV2@@Z PROC ; std::allocator<CTerrain *>::construct<CTerrain *,CTerrain * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCTerrain@@AAPAV1@@?$allocator@PAVCTerrain@@@std@@QAEXPAPAVCTerrain@@AAPAV2@@Z ENDP ; std::allocator<CTerrain *>::construct<CTerrain *,CTerrain * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVCTerrain@@IPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@IABQAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill_n@PAPAVCTerrain@@IPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@IABQAV1@@Z PROC ; std::_Fill_n<CTerrain * *,unsigned int,CTerrain *>, COMDAT

; 2631 : 	{	// copy _Val _Count times through [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	85 d2		 test	 edx, edx
  0000b	74 0f		 je	 SHORT $LN1@Fill_n
  0000d	56		 push	 esi
  0000e	8b 75 10	 mov	 esi, DWORD PTR __Val$[ebp]
$LL3@Fill_n:

; 2633 : 		*_Dest = _Val;

  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	89 08		 mov	 DWORD PTR [eax], ecx
  00015	83 c0 04	 add	 eax, 4
  00018	4a		 dec	 edx
  00019	75 f6		 jne	 SHORT $LL3@Fill_n
  0001b	5e		 pop	 esi
$LN1@Fill_n:

; 2634 : 	return (_Dest);
; 2635 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Fill_n@PAPAVCTerrain@@IPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@IABQAV1@@Z ENDP ; std::_Fill_n<CTerrain * *,unsigned int,CTerrain *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCArea@@AAPAV1@@?$allocator@PAVCArea@@@std@@QAEXPAPAVCArea@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCArea@@AAPAV1@@?$allocator@PAVCArea@@@std@@QAEXPAPAVCArea@@AAPAV2@@Z PROC ; std::allocator<CArea *>::construct<CArea *,CArea * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCArea@@AAPAV1@@?$allocator@PAVCArea@@@std@@QAEXPAPAVCArea@@AAPAV2@@Z ENDP ; std::allocator<CArea *>::construct<CArea *,CArea * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVCArea@@IPAV1@@std@@YAPAPAVCArea@@PAPAV1@IABQAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill_n@PAPAVCArea@@IPAV1@@std@@YAPAPAVCArea@@PAPAV1@IABQAV1@@Z PROC ; std::_Fill_n<CArea * *,unsigned int,CArea *>, COMDAT

; 2631 : 	{	// copy _Val _Count times through [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	85 d2		 test	 edx, edx
  0000b	74 0f		 je	 SHORT $LN1@Fill_n
  0000d	56		 push	 esi
  0000e	8b 75 10	 mov	 esi, DWORD PTR __Val$[ebp]
$LL3@Fill_n:

; 2633 : 		*_Dest = _Val;

  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	89 08		 mov	 DWORD PTR [eax], ecx
  00015	83 c0 04	 add	 eax, 4
  00018	4a		 dec	 edx
  00019	75 f6		 jne	 SHORT $LL3@Fill_n
  0001b	5e		 pop	 esi
$LN1@Fill_n:

; 2634 : 	return (_Dest);
; 2635 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Fill_n@PAPAVCArea@@IPAV1@@std@@YAPAPAVCArea@@PAPAV1@IABQAV1@@Z ENDP ; std::_Fill_n<CArea * *,unsigned int,CArea *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicObjectInstance@@AAPAV1@@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEXPAPAVCGraphicObjectInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCGraphicObjectInstance@@AAPAV1@@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEXPAPAVCGraphicObjectInstance@@AAPAV2@@Z PROC ; std::allocator<CGraphicObjectInstance *>::construct<CGraphicObjectInstance *,CGraphicObjectInstance * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCGraphicObjectInstance@@AAPAV1@@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEXPAPAVCGraphicObjectInstance@@AAPAV2@@Z ENDP ; std::allocator<CGraphicObjectInstance *>::construct<CGraphicObjectInstance *,CGraphicObjectInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Copy_impl@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_impl@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_impl<CArea * *,CArea * *>, COMDAT

; 2053 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2054 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi

; 2055 : 	_CSTD memmove(&*_Dest, &*_First,
; 2056 : 		_Count * sizeof (*_First));

  0000c	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	57		 push	 edi
  00013	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2057 : 	return (_Dest + _Count);

  00025	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 2058 : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Copy_impl@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_impl<CArea * *,CArea * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Copy_impl@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_impl@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_impl<CTerrain * *,CTerrain * *>, COMDAT

; 2053 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2054 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi

; 2055 : 	_CSTD memmove(&*_Dest, &*_First,
; 2056 : 		_Count * sizeof (*_First));

  0000c	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	57		 push	 edi
  00013	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2057 : 	return (_Dest + _Count);

  00025	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 2058 : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Copy_impl@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_impl<CTerrain * *,CTerrain * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Find@PAPAVCArea@@PAV1@@std@@YAPAPAVCArea@@PAPAV1@0ABQAV1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Find@PAPAVCArea@@PAV1@@std@@YAPAPAVCArea@@PAPAV1@0ABQAV1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Find<CArea * *,CArea *>, COMDAT

; 3024 : 	{	// find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3025 : 	for (; _First != _Last; ++_First)

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	3b c2		 cmp	 eax, edx
  0000b	74 10		 je	 SHORT $LN8@Find

; 3026 : 		if (*_First == _Val)

  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00010	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL4@Find:
  00012	39 08		 cmp	 DWORD PTR [eax], ecx
  00014	74 07		 je	 SHORT $LN8@Find

; 3025 : 	for (; _First != _Last; ++_First)

  00016	83 c0 04	 add	 eax, 4
  00019	3b c2		 cmp	 eax, edx
  0001b	75 f5		 jne	 SHORT $LL4@Find
$LN8@Find:

; 3027 : 			break;
; 3028 : 	return (_First);
; 3029 : 	}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Find@PAPAVCArea@@PAV1@@std@@YAPAPAVCArea@@PAPAV1@0ABQAV1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Find<CArea * *,CArea *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Find@PAPAVCTerrain@@PAV1@@std@@YAPAPAVCTerrain@@PAPAV1@0ABQAV1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Find@PAPAVCTerrain@@PAV1@@std@@YAPAPAVCTerrain@@PAPAV1@0ABQAV1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Find<CTerrain * *,CTerrain *>, COMDAT

; 3024 : 	{	// find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3025 : 	for (; _First != _Last; ++_First)

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	3b c2		 cmp	 eax, edx
  0000b	74 10		 je	 SHORT $LN8@Find

; 3026 : 		if (*_First == _Val)

  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00010	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL4@Find:
  00012	39 08		 cmp	 DWORD PTR [eax], ecx
  00014	74 07		 je	 SHORT $LN8@Find

; 3025 : 	for (; _First != _Last; ++_First)

  00016	83 c0 04	 add	 eax, 4
  00019	3b c2		 cmp	 eax, edx
  0001b	75 f5		 jne	 SHORT $LL4@Find
$LN8@Find:

; 3027 : 			break;
; 3028 : 	return (_First);
; 3029 : 	}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Find@PAPAVCTerrain@@PAV1@@std@@YAPAPAVCTerrain@@PAPAV1@0ABQAV1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Find<CTerrain * *,CTerrain *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Find@PAPAVCGraphicObjectInstance@@PAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@0ABQAV1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Find@PAPAVCGraphicObjectInstance@@PAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@0ABQAV1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Find<CGraphicObjectInstance * *,CGraphicObjectInstance *>, COMDAT

; 3024 : 	{	// find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3025 : 	for (; _First != _Last; ++_First)

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	3b c2		 cmp	 eax, edx
  0000b	74 10		 je	 SHORT $LN8@Find

; 3026 : 		if (*_First == _Val)

  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00010	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL4@Find:
  00012	39 08		 cmp	 DWORD PTR [eax], ecx
  00014	74 07		 je	 SHORT $LN8@Find

; 3025 : 	for (; _First != _Last; ++_First)

  00016	83 c0 04	 add	 eax, 4
  00019	3b c2		 cmp	 eax, edx
  0001b	75 f5		 jne	 SHORT $LL4@Find
$LN8@Find:

; 3027 : 			break;
; 3028 : 	return (_First);
; 3029 : 	}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Find@PAPAVCGraphicObjectInstance@@PAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@0ABQAV1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Find<CGraphicObjectInstance * *,CGraphicObjectInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 12
??$_Insertion_sort@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z PROC ; std::_Insertion_sort<CGraphicObjectInstance * *,FPCBlockerDistanceSort>, COMDAT

; 3025 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  00003	f3 0f 7e 45 10	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  00008	8b 45 18	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  0000b	6a 00		 push	 0
  0000d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00010	8b cc		 mov	 ecx, esp
  00012	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00015	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00019	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0001f	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@PAV1@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@0@Z ; std::_Insertion_sort1<CGraphicObjectInstance * *,FPCBlockerDistanceSort,CGraphicObjectInstance *>
  00024	83 c4 18	 add	 esp, 24			; 00000018H

; 3027 : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Insertion_sort@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z ENDP ; std::_Insertion_sort<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$sort_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 12
??$sort_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z PROC ; std::sort_heap<CGraphicObjectInstance * *,FPCBlockerDistanceSort>, COMDAT

; 2483 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2484 : 	_DEBUG_RANGE(_First, _Last);
; 2485 : 	_DEBUG_POINTER(_Pred);
; 2486 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2487 : 	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);

  00003	f3 0f 7e 45 10	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  00008	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000b	8b 45 18	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  0000e	8b cc		 mov	 ecx, esp
  00010	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00013	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0001d	e8 00 00 00 00	 call	 ??$_Sort_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z ; std::_Sort_heap<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
  00022	83 c4 14	 add	 esp, 20			; 00000014H

; 2488 : 	}

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$sort_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z ENDP ; std::sort_heap<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$make_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 12
??$make_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z PROC ; std::make_heap<CGraphicObjectInstance * *,FPCBlockerDistanceSort>, COMDAT

; 2456 : 	{	// make [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2457 : 	_DEBUG_RANGE(_First, _Last);
; 2458 : 	_DEBUG_POINTER(_Pred);
; 2459 : 	if (1 < _Last - _First)

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000b	83 e0 fc	 and	 eax, -4			; fffffffcH
  0000e	83 f8 04	 cmp	 eax, 4
  00011	7e 24		 jle	 SHORT $LN1@make_heap

; 2460 : 		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2461 : 			_Dist_type(_First), _Val_type(_First));

  00013	f3 0f 7e 45 10	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  00018	8b 45 18	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  0001b	6a 00		 push	 0
  0001d	6a 00		 push	 0
  0001f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00022	8b cc		 mov	 ecx, esp
  00024	52		 push	 edx
  00025	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00028	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0002c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0002f	e8 00 00 00 00	 call	 ??$_Make_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@PAH0@Z ; std::_Make_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>
  00034	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@make_heap:

; 2462 : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$make_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z ENDP ; std::make_heap<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YA?AU?$pair@PAPAVCGraphicObjectInstance@@PAPAV1@@0@PAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -36				; size = 4
$T1 = -32						; size = 4
$T2 = -32						; size = 4
__First$GSCopy$1$ = -28					; size = 4
__Last$GSCopy$1$ = -24					; size = 4
$T3 = -20						; size = 4
$T4 = -20						; size = 4
__Glast$1$ = -20					; size = 4
__Plast$1$ = -16					; size = 4
$T5 = -12						; size = 4
$T6 = -12						; size = 4
$T7 = -12						; size = 4
$T8 = -12						; size = 4
$T9 = -12						; size = 4
$T10 = -12						; size = 4
$T11 = -12						; size = 4
$T12 = -12						; size = 4
$T13 = -8						; size = 4
$T14 = -8						; size = 4
$T15 = -8						; size = 4
$T16 = -8						; size = 4
$T17 = -8						; size = 4
$T18 = -8						; size = 4
$T19 = -8						; size = 4
$T20 = -8						; size = 4
$T21 = -4						; size = 4
$T22 = -4						; size = 4
$T23 = -4						; size = 4
$T24 = -4						; size = 4
__Gfirst$1$ = -4					; size = 4
tv2612 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 12
??$_Unguarded_partition@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YA?AU?$pair@PAPAVCGraphicObjectInstance@@PAPAV1@@0@PAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z PROC ; std::_Unguarded_partition<CGraphicObjectInstance * *,FPCBlockerDistanceSort>, COMDAT

; 3063 : 	{	// partition [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3064 : 	_RanIt _Mid = _First + (_Last - _First) / 2;
; 3065 : 	_Median(_First, _Mid, _Last - 1, _Pred);

  00009	f3 0f 7e 45 14	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  0000e	89 45 dc	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  00011	53		 push	 ebx
  00012	8b 5d 10	 mov	 ebx, DWORD PTR __Last$[ebp]
  00015	8b c3		 mov	 eax, ebx
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR __First$[ebp]
  0001b	2b c6		 sub	 eax, esi
  0001d	c1 f8 02	 sar	 eax, 2
  00020	99		 cdq
  00021	57		 push	 edi
  00022	2b c2		 sub	 eax, edx
  00024	89 75 e4	 mov	 DWORD PTR __First$GSCopy$1$[ebp], esi
  00027	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0002a	d1 f8		 sar	 eax, 1
  0002c	8b cc		 mov	 ecx, esp
  0002e	89 5d e8	 mov	 DWORD PTR __Last$GSCopy$1$[ebp], ebx
  00031	8d 3c 86	 lea	 edi, DWORD PTR [esi+eax*4]
  00034	8b 45 1c	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  00037	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0003b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0003e	8d 43 fc	 lea	 eax, DWORD PTR [ebx-4]
  00041	50		 push	 eax
  00042	57		 push	 edi
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ??$_Median@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@00UFPCBlockerDistanceSort@@@Z ; std::_Median<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
  00049	83 c4 18	 add	 esp, 24			; 00000018H

; 3066 : 	_RanIt _Pfirst = _Mid;
; 3067 : 	_RanIt _Plast = _Pfirst + 1;

  0004c	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  0004f	89 55 f0	 mov	 DWORD PTR __Plast$1$[ebp], edx

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  00052	3b f7		 cmp	 esi, edi
  00054	0f 83 4f 01 00
	00		 jae	 $LN222@Unguarded_
  0005a	8b de		 mov	 ebx, esi
  0005c	8d 64 24 00	 npad	 4
$LL29@Unguarded_:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00060	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
; File a:\vs\vc\include\algorithm

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  00063	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00066	8b 37		 mov	 esi, DWORD PTR [edi]
  00068	89 45 fc	 mov	 DWORD PTR tv2612[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  0006b	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00070	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00072	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00076	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  0007b	f3 0f 11 45 f4	 movss	 DWORD PTR $T12[ebp], xmm0
  00080	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00085	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  0008a	f3 0f 11 45 ec	 movss	 DWORD PTR $T4[ebp], xmm0
  0008f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00094	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  00099	f3 0f 11 45 f8	 movss	 DWORD PTR $T20[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  0009e	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000a3	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR $T12[ebp]
  000a8	f3 0f 10 65 ec	 movss	 xmm4, DWORD PTR $T4[ebp]
  000ad	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000b1	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  000b5	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]
  000ba	f3 0f 5c 5d 18	 subss	 xmm3, DWORD PTR __Pred$[ebp+4]
  000bf	f3 0f 5c 4d 14	 subss	 xmm1, DWORD PTR __Pred$[ebp]
  000c4	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000c9	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000ce	f3 0f 59 e4	 mulss	 xmm4, xmm4
  000d2	f3 0f 59 db	 mulss	 xmm3, xmm3
  000d6	f3 0f 59 c9	 mulss	 xmm1, xmm1
  000da	f3 0f 58 e2	 addss	 xmm4, xmm2
  000de	f3 0f 10 55 f8	 movss	 xmm2, DWORD PTR $T20[ebp]
  000e3	f3 0f 59 d2	 mulss	 xmm2, xmm2
  000e7	f3 0f 58 d9	 addss	 xmm3, xmm1
  000eb	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000ef	f3 0f 58 e2	 addss	 xmm4, xmm2
  000f3	f3 0f 58 d8	 addss	 xmm3, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  000f7	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  000fa	0f 87 a3 00 00
	00		 ja	 $LN244@Unguarded_
  00100	8b 75 fc	 mov	 esi, DWORD PTR tv2612[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00103	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\algorithm

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  00105	8b 36		 mov	 esi, DWORD PTR [esi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00107	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  0010c	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0010e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00112	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  00117	f3 0f 11 45 f8	 movss	 DWORD PTR $T19[ebp], xmm0
  0011c	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00121	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  00126	f3 0f 11 45 f4	 movss	 DWORD PTR $T11[ebp], xmm0
  0012b	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00130	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  00135	f3 0f 11 45 ec	 movss	 DWORD PTR $T3[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  0013a	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0013f	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR $T11[ebp]
  00144	f3 0f 10 65 f8	 movss	 xmm4, DWORD PTR $T19[ebp]
  00149	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0014d	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  00151	f3 0f 5c 5d 14	 subss	 xmm3, DWORD PTR __Pred$[ebp]
  00156	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0015b	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  00160	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00165	f3 0f 5c 4d 1c	 subss	 xmm1, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0016a	f3 0f 59 e4	 mulss	 xmm4, xmm4
  0016e	f3 0f 59 db	 mulss	 xmm3, xmm3
  00172	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00176	f3 0f 58 e2	 addss	 xmm4, xmm2
  0017a	f3 0f 10 55 ec	 movss	 xmm2, DWORD PTR $T3[ebp]
  0017f	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00183	f3 0f 58 d8	 addss	 xmm3, xmm0
  00187	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0018b	f3 0f 58 e2	 addss	 xmm4, xmm2
  0018f	f3 0f 58 d9	 addss	 xmm3, xmm1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00193	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  00196	77 0b		 ja	 SHORT $LN244@Unguarded_

; 3072 : 		--_Pfirst;

  00198	8b 7d fc	 mov	 edi, DWORD PTR tv2612[ebp]
  0019b	3b df		 cmp	 ebx, edi
  0019d	0f 82 bd fe ff
	ff		 jb	 $LL29@Unguarded_
$LN244@Unguarded_:
  001a3	8b 55 f0	 mov	 edx, DWORD PTR __Plast$1$[ebp]
  001a6	8b 5d e8	 mov	 ebx, DWORD PTR __Last$GSCopy$1$[ebp]
$LN222@Unguarded_:

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  001a9	3b d3		 cmp	 edx, ebx
  001ab	0f 83 47 01 00
	00		 jae	 $LN245@Unguarded_
$LL27@Unguarded_:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  001b1	8b 0a		 mov	 ecx, DWORD PTR [edx]
; File a:\vs\vc\include\algorithm

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  001b3	8b 37		 mov	 esi, DWORD PTR [edi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  001b5	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  001ba	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001bc	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001c0	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  001c5	f3 0f 11 45 f8	 movss	 DWORD PTR $T18[ebp], xmm0
  001ca	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001cf	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  001d4	f3 0f 11 45 f4	 movss	 DWORD PTR $T10[ebp], xmm0
  001d9	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001de	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  001e3	f3 0f 11 45 fc	 movss	 DWORD PTR $T24[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  001e8	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  001ed	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR $T10[ebp]
  001f2	f3 0f 10 65 f8	 movss	 xmm4, DWORD PTR $T18[ebp]
  001f7	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001fb	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  001ff	f3 0f 5c 5d 14	 subss	 xmm3, DWORD PTR __Pred$[ebp]
  00204	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00209	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  0020e	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00213	f3 0f 5c 4d 1c	 subss	 xmm1, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00218	f3 0f 59 e4	 mulss	 xmm4, xmm4
  0021c	f3 0f 59 db	 mulss	 xmm3, xmm3
  00220	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00224	f3 0f 58 e2	 addss	 xmm4, xmm2
  00228	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR $T24[ebp]
  0022d	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00231	f3 0f 58 d8	 addss	 xmm3, xmm0
  00235	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00239	f3 0f 58 e2	 addss	 xmm4, xmm2
  0023d	f3 0f 58 d9	 addss	 xmm3, xmm1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00241	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  00244	0f 87 ab 00 00
	00		 ja	 $LN249@Unguarded_
  0024a	8b 45 f0	 mov	 eax, DWORD PTR __Plast$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  0024d	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\algorithm

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  0024f	8b 30		 mov	 esi, DWORD PTR [eax]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00251	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00256	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00258	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0025c	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  00261	f3 0f 11 45 f4	 movss	 DWORD PTR $T9[ebp], xmm0
  00266	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0026b	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  00270	f3 0f 11 45 f8	 movss	 DWORD PTR $T17[ebp], xmm0
  00275	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0027a	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  0027f	f3 0f 11 45 fc	 movss	 DWORD PTR $T23[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00284	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00289	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR $T9[ebp]
  0028e	f3 0f 10 65 f8	 movss	 xmm4, DWORD PTR $T17[ebp]
; File a:\vs\vc\include\algorithm

; 3076 : 		++_Plast;

  00293	8b 55 f0	 mov	 edx, DWORD PTR __Plast$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00296	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0029a	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]
  0029f	f3 0f 5c 5d 18	 subss	 xmm3, DWORD PTR __Pred$[ebp+4]
  002a4	f3 0f 5c 4d 14	 subss	 xmm1, DWORD PTR __Pred$[ebp]
  002a9	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002ae	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  002b3	f3 0f 59 d2	 mulss	 xmm2, xmm2
  002b7	f3 0f 59 e4	 mulss	 xmm4, xmm4
  002bb	f3 0f 59 db	 mulss	 xmm3, xmm3
  002bf	f3 0f 59 c9	 mulss	 xmm1, xmm1
  002c3	f3 0f 58 e2	 addss	 xmm4, xmm2
  002c7	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR $T23[ebp]
  002cc	f3 0f 59 d2	 mulss	 xmm2, xmm2
  002d0	f3 0f 58 d9	 addss	 xmm3, xmm1
  002d4	f3 0f 59 c0	 mulss	 xmm0, xmm0
  002d8	f3 0f 58 e2	 addss	 xmm4, xmm2
  002dc	f3 0f 58 d8	 addss	 xmm3, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  002e0	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  002e3	77 13		 ja	 SHORT $LN245@Unguarded_

; 3076 : 		++_Plast;

  002e5	83 c2 04	 add	 edx, 4
  002e8	89 55 f0	 mov	 DWORD PTR __Plast$1$[ebp], edx
  002eb	3b d3		 cmp	 edx, ebx
  002ed	0f 82 be fe ff
	ff		 jb	 $LL27@Unguarded_

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  002f3	eb 03		 jmp	 SHORT $LN245@Unguarded_
$LN249@Unguarded_:
  002f5	8b 55 f0	 mov	 edx, DWORD PTR __Plast$1$[ebp]
$LN245@Unguarded_:

; 3077 : 
; 3078 : 	_RanIt _Gfirst = _Plast;

  002f8	8b da		 mov	 ebx, edx

; 3079 : 	_RanIt _Glast = _Pfirst;

  002fa	8b d7		 mov	 edx, edi
  002fc	89 55 ec	 mov	 DWORD PTR __Glast$1$[ebp], edx
$LN252@Unguarded_:

; 3077 : 
; 3078 : 	_RanIt _Gfirst = _Plast;

  002ff	89 5d fc	 mov	 DWORD PTR __Gfirst$1$[ebp], ebx
$LL25@Unguarded_:

; 3083 : 		for (; _Gfirst < _Last; ++_Gfirst)

  00302	3b 5d e8	 cmp	 ebx, DWORD PTR __Last$GSCopy$1$[ebp]
  00305	0f 83 5e 01 00
	00		 jae	 $LN226@Unguarded_
  0030b	eb 03 8d 49 00	 npad	 5
$LL23@Unguarded_:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00310	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\algorithm

; 3084 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

  00312	8b 33		 mov	 esi, DWORD PTR [ebx]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00314	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00319	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0031b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0031f	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  00324	f3 0f 11 45 f4	 movss	 DWORD PTR $T8[ebp], xmm0
  00329	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0032e	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  00333	f3 0f 11 45 f8	 movss	 DWORD PTR $T16[ebp], xmm0
  00338	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0033d	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  00342	f3 0f 11 45 fc	 movss	 DWORD PTR $T22[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00347	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0034c	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR $T8[ebp]
  00351	f3 0f 10 65 f8	 movss	 xmm4, DWORD PTR $T16[ebp]
  00356	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0035a	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  0035e	f3 0f 5c 5d 14	 subss	 xmm3, DWORD PTR __Pred$[ebp]
  00363	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00368	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  0036d	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00372	f3 0f 5c 4d 1c	 subss	 xmm1, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00377	f3 0f 59 e4	 mulss	 xmm4, xmm4
  0037b	f3 0f 59 db	 mulss	 xmm3, xmm3
  0037f	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00383	f3 0f 58 e2	 addss	 xmm4, xmm2
  00387	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR $T22[ebp]
  0038c	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00390	f3 0f 58 d8	 addss	 xmm3, xmm0
  00394	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00398	f3 0f 58 e2	 addss	 xmm4, xmm2
  0039c	f3 0f 58 d9	 addss	 xmm3, xmm1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  003a0	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3084 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

  003a3	0f 87 ae 00 00
	00		 ja	 $LN22@Unguarded_
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  003a9	8b 0b		 mov	 ecx, DWORD PTR [ebx]
; File a:\vs\vc\include\algorithm

; 3086 : 			else if (_Pred(*_Gfirst, *_Pfirst))

  003ab	8b 37		 mov	 esi, DWORD PTR [edi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  003ad	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  003b2	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  003b4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  003b8	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  003bd	f3 0f 11 45 f8	 movss	 DWORD PTR $T15[ebp], xmm0
  003c2	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  003c7	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  003cc	f3 0f 11 45 f4	 movss	 DWORD PTR $T7[ebp], xmm0
  003d1	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  003d6	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  003db	f3 0f 11 45 fc	 movss	 DWORD PTR $T21[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  003e0	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  003e5	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR $T7[ebp]
  003ea	f3 0f 10 65 f8	 movss	 xmm4, DWORD PTR $T15[ebp]
  003ef	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  003f3	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  003f7	f3 0f 5c 5d 14	 subss	 xmm3, DWORD PTR __Pred$[ebp]
  003fc	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00401	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  00406	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  0040b	f3 0f 5c 4d 1c	 subss	 xmm1, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00410	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00414	f3 0f 59 db	 mulss	 xmm3, xmm3
  00418	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0041c	f3 0f 58 e2	 addss	 xmm4, xmm2
  00420	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR $T21[ebp]
  00425	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00429	f3 0f 58 d8	 addss	 xmm3, xmm0
  0042d	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00431	f3 0f 58 e2	 addss	 xmm4, xmm2
  00435	f3 0f 58 d9	 addss	 xmm3, xmm1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00439	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3086 : 			else if (_Pred(*_Gfirst, *_Pfirst))

  0043c	77 25		 ja	 SHORT $LN246@Unguarded_

; 3087 : 				break;
; 3088 : 			else if (_Plast++ != _Gfirst)

  0043e	8b 55 f0	 mov	 edx, DWORD PTR __Plast$1$[ebp]
  00441	8b c2		 mov	 eax, edx
  00443	83 c2 04	 add	 edx, 4
  00446	89 55 f0	 mov	 DWORD PTR __Plast$1$[ebp], edx
  00449	3b c3		 cmp	 eax, ebx
  0044b	74 0a		 je	 SHORT $LN22@Unguarded_
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  0044d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]

; 53   : 	_Left = _Move(_Right);

  00450	8b 03		 mov	 eax, DWORD PTR [ebx]
  00452	89 42 fc	 mov	 DWORD PTR [edx-4], eax

; 54   : 	_Right = _Move(_Tmp);

  00455	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN22@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3083 : 		for (; _Gfirst < _Last; ++_Gfirst)

  00457	83 c3 04	 add	 ebx, 4
  0045a	3b 5d e8	 cmp	 ebx, DWORD PTR __Last$GSCopy$1$[ebp]
  0045d	0f 82 ad fe ff
	ff		 jb	 $LL23@Unguarded_
$LN246@Unguarded_:
  00463	8b 55 ec	 mov	 edx, DWORD PTR __Glast$1$[ebp]
  00466	89 5d fc	 mov	 DWORD PTR __Gfirst$1$[ebp], ebx
$LN226@Unguarded_:

; 3090 : 		for (; _First < _Glast; --_Glast)

  00469	8b 45 e4	 mov	 eax, DWORD PTR __First$GSCopy$1$[ebp]
  0046c	3b d0		 cmp	 edx, eax
  0046e	0f 86 64 01 00
	00		 jbe	 $LN251@Unguarded_
  00474	8d 5a fc	 lea	 ebx, DWORD PTR [edx-4]
$LL15@Unguarded_:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00477	8b 0b		 mov	 ecx, DWORD PTR [ebx]
; File a:\vs\vc\include\algorithm

; 3091 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

  00479	8b 37		 mov	 esi, DWORD PTR [edi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  0047b	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00480	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00482	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00486	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  0048b	f3 0f 11 45 f8	 movss	 DWORD PTR $T14[ebp], xmm0
  00490	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00495	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  0049a	f3 0f 11 45 f4	 movss	 DWORD PTR $T6[ebp], xmm0
  0049f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  004a4	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  004a9	f3 0f 11 45 e0	 movss	 DWORD PTR $T2[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  004ae	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  004b3	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR $T6[ebp]
  004b8	f3 0f 10 65 f8	 movss	 xmm4, DWORD PTR $T14[ebp]
  004bd	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  004c1	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  004c5	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]
  004ca	f3 0f 5c 5d 18	 subss	 xmm3, DWORD PTR __Pred$[ebp+4]
  004cf	f3 0f 5c 4d 14	 subss	 xmm1, DWORD PTR __Pred$[ebp]
  004d4	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  004d9	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  004de	f3 0f 59 e4	 mulss	 xmm4, xmm4
  004e2	f3 0f 59 db	 mulss	 xmm3, xmm3
  004e6	f3 0f 59 c9	 mulss	 xmm1, xmm1
  004ea	f3 0f 58 e2	 addss	 xmm4, xmm2
  004ee	f3 0f 10 55 e0	 movss	 xmm2, DWORD PTR $T2[ebp]
  004f3	f3 0f 59 d2	 mulss	 xmm2, xmm2
  004f7	f3 0f 58 d9	 addss	 xmm3, xmm1
  004fb	f3 0f 59 c0	 mulss	 xmm0, xmm0
  004ff	f3 0f 58 e2	 addss	 xmm4, xmm2
  00503	f3 0f 58 d8	 addss	 xmm3, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00507	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3091 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

  0050a	0f 87 a4 00 00
	00		 ja	 $LN14@Unguarded_
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00510	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\algorithm

; 3093 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

  00512	8b 33		 mov	 esi, DWORD PTR [ebx]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00514	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00519	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0051b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0051f	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR __Pred$[ebp]
  00524	f3 0f 11 45 f8	 movss	 DWORD PTR $T13[ebp], xmm0
  00529	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0052e	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR __Pred$[ebp+4]
  00533	f3 0f 11 45 e0	 movss	 DWORD PTR $T1[ebp], xmm0
  00538	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0053d	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]
  00542	f3 0f 11 45 f4	 movss	 DWORD PTR $T5[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00547	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0054c	f3 0f 10 55 f8	 movss	 xmm2, DWORD PTR $T13[ebp]
  00551	f3 0f 10 65 e0	 movss	 xmm4, DWORD PTR $T1[ebp]
  00556	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0055a	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0055e	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]
  00563	f3 0f 5c 5d 18	 subss	 xmm3, DWORD PTR __Pred$[ebp+4]
  00568	f3 0f 5c 4d 14	 subss	 xmm1, DWORD PTR __Pred$[ebp]
  0056d	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00572	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR __Pred$[ebp+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00577	f3 0f 59 e4	 mulss	 xmm4, xmm4
  0057b	f3 0f 59 db	 mulss	 xmm3, xmm3
  0057f	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00583	f3 0f 58 e2	 addss	 xmm4, xmm2
  00587	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR $T5[ebp]
  0058c	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00590	f3 0f 58 d9	 addss	 xmm3, xmm1
  00594	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00598	f3 0f 58 e2	 addss	 xmm4, xmm2
  0059c	f3 0f 58 d8	 addss	 xmm3, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  005a0	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3093 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

  005a3	77 28		 ja	 SHORT $LN250@Unguarded_

; 3094 : 				break;
; 3095 : 			else if (--_Pfirst != _Glast - 1)

  005a5	83 ef 04	 sub	 edi, 4
  005a8	3b fb		 cmp	 edi, ebx
  005aa	74 08		 je	 SHORT $LN14@Unguarded_
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  005ac	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 53   : 	_Left = _Move(_Right);

  005ae	8b 03		 mov	 eax, DWORD PTR [ebx]
  005b0	89 07		 mov	 DWORD PTR [edi], eax

; 54   : 	_Right = _Move(_Tmp);

  005b2	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN14@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3090 : 		for (; _First < _Glast; --_Glast)

  005b4	8b 55 ec	 mov	 edx, DWORD PTR __Glast$1$[ebp]
  005b7	83 eb 04	 sub	 ebx, 4
  005ba	8b 45 e4	 mov	 eax, DWORD PTR __First$GSCopy$1$[ebp]
  005bd	83 ea 04	 sub	 edx, 4
  005c0	89 55 ec	 mov	 DWORD PTR __Glast$1$[ebp], edx
  005c3	3b c2		 cmp	 eax, edx
  005c5	0f 82 ac fe ff
	ff		 jb	 $LL15@Unguarded_
  005cb	eb 06		 jmp	 SHORT $LN247@Unguarded_
$LN250@Unguarded_:
  005cd	8b 55 ec	 mov	 edx, DWORD PTR __Glast$1$[ebp]
  005d0	8b 45 e4	 mov	 eax, DWORD PTR __First$GSCopy$1$[ebp]
$LN247@Unguarded_:
  005d3	8b 5d fc	 mov	 ebx, DWORD PTR __Gfirst$1$[ebp]

; 3096 : 				_STD iter_swap(_Pfirst, _Glast - 1);
; 3097 : 		if (_Glast == _First && _Gfirst == _Last)

  005d6	3b d0		 cmp	 edx, eax
$LN251@Unguarded_:
  005d8	75 34		 jne	 SHORT $LN6@Unguarded_
  005da	3b 5d e8	 cmp	 ebx, DWORD PTR __Last$GSCopy$1$[ebp]
  005dd	74 72		 je	 SHORT $LN228@Unguarded_

; 3099 : 
; 3100 : 		if (_Glast == _First)
; 3101 : 			{	// no room at bottom, rotate pivot upward
; 3102 : 			if (_Plast != _Gfirst)

  005df	8b 55 f0	 mov	 edx, DWORD PTR __Plast$1$[ebp]
  005e2	3b d3		 cmp	 edx, ebx
  005e4	74 08		 je	 SHORT $LN172@Unguarded_
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  005e6	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 53   : 	_Left = _Move(_Right);

  005e8	8b 02		 mov	 eax, DWORD PTR [edx]
  005ea	89 07		 mov	 DWORD PTR [edi], eax

; 54   : 	_Right = _Move(_Tmp);

  005ec	89 0a		 mov	 DWORD PTR [edx], ecx
$LN172@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3104 : 			++_Plast;

  005ee	83 c2 04	 add	 edx, 4

; 3105 : 			_STD iter_swap(_Pfirst++, _Gfirst++);

  005f1	8b f3		 mov	 esi, ebx
  005f3	89 55 f0	 mov	 DWORD PTR __Plast$1$[ebp], edx
  005f6	8b d7		 mov	 edx, edi
  005f8	83 c7 04	 add	 edi, 4
  005fb	83 c3 04	 add	 ebx, 4
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  005fe	8b 06		 mov	 eax, DWORD PTR [esi]
  00600	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00602	89 02		 mov	 DWORD PTR [edx], eax

; 29   : 	}

  00604	8b 55 ec	 mov	 edx, DWORD PTR __Glast$1$[ebp]

; 54   : 	_Right = _Move(_Tmp);

  00607	89 0e		 mov	 DWORD PTR [esi], ecx

; 29   : 	}

  00609	e9 f1 fc ff ff	 jmp	 $LN252@Unguarded_
$LN6@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3109 : 			if (--_Glast != --_Pfirst)

  0060e	83 ea 04	 sub	 edx, 4
  00611	89 55 ec	 mov	 DWORD PTR __Glast$1$[ebp], edx
  00614	3b 5d e8	 cmp	 ebx, DWORD PTR __Last$GSCopy$1$[ebp]
  00617	75 28		 jne	 SHORT $LN3@Unguarded_
  00619	83 ef 04	 sub	 edi, 4
  0061c	3b d7		 cmp	 edx, edi
  0061e	74 08		 je	 SHORT $LN192@Unguarded_
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00620	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 53   : 	_Left = _Move(_Right);

  00622	8b 07		 mov	 eax, DWORD PTR [edi]
  00624	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00626	89 0f		 mov	 DWORD PTR [edi], ecx
$LN192@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3111 : 			_STD iter_swap(_Pfirst, --_Plast);

  00628	8b 55 f0	 mov	 edx, DWORD PTR __Plast$1$[ebp]
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  0062b	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\algorithm

; 3111 : 			_STD iter_swap(_Pfirst, --_Plast);

  0062d	83 ea 04	 sub	 edx, 4
  00630	89 55 f0	 mov	 DWORD PTR __Plast$1$[ebp], edx
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00633	8b 02		 mov	 eax, DWORD PTR [edx]
  00635	89 07		 mov	 DWORD PTR [edi], eax

; 54   : 	_Right = _Move(_Tmp);

  00637	89 0a		 mov	 DWORD PTR [edx], ecx
; File a:\vs\vc\include\algorithm

; 3113 : 		else

  00639	8b 55 ec	 mov	 edx, DWORD PTR __Glast$1$[ebp]
  0063c	e9 c1 fc ff ff	 jmp	 $LL25@Unguarded_
$LN3@Unguarded_:
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00641	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 53   : 	_Left = _Move(_Right);

  00643	8b 02		 mov	 eax, DWORD PTR [edx]
  00645	89 03		 mov	 DWORD PTR [ebx], eax
; File a:\vs\vc\include\algorithm

; 3114 : 			_STD iter_swap(_Gfirst++, --_Glast);

  00647	83 c3 04	 add	 ebx, 4
; File a:\vs\vc\include\utility

; 54   : 	_Right = _Move(_Tmp);

  0064a	89 0a		 mov	 DWORD PTR [edx], ecx
; File a:\vs\vc\include\algorithm

; 3115 : 		}

  0064c	e9 ae fc ff ff	 jmp	 $LN252@Unguarded_
$LN228@Unguarded_:
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00651	8b 4d dc	 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  00654	8b 45 f0	 mov	 eax, DWORD PTR __Plast$1$[ebp]
  00657	89 39		 mov	 DWORD PTR [ecx], edi
; File a:\vs\vc\include\algorithm

; 3116 : 	}

  00659	5f		 pop	 edi
  0065a	5e		 pop	 esi
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  0065b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File a:\vs\vc\include\algorithm

; 3098 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

  0065e	8b c1		 mov	 eax, ecx

; 3116 : 	}

  00660	5b		 pop	 ebx
  00661	8b e5		 mov	 esp, ebp
  00663	5d		 pop	 ebp
  00664	c3		 ret	 0
??$_Unguarded_partition@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YA?AU?$pair@PAPAVCGraphicObjectInstance@@PAPAV1@@0@PAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z ENDP ; std::_Unguarded_partition<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEPAPAVCTerrain@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@1@0PAPAV2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEPAPAVCTerrain@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@1@0PAPAV2@@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > > >, COMDAT
; _this$ = ecx

; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	2b c8		 sub	 ecx, eax
  0000b	c1 f9 02	 sar	 ecx, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 8d 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*4]
  00016	56		 push	 esi
  00017	50		 push	 eax
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File a:\vs\vc\include\vector

; 1641 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEPAPAVCTerrain@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@1@0PAPAV2@@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEPAPAVCArea@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@1@0PAPAV2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEPAPAVCArea@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@1@0PAPAV2@@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > > >, COMDAT
; _this$ = ecx

; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	2b c8		 sub	 ecx, eax
  0000b	c1 f9 02	 sar	 ecx, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 8d 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*4]
  00016	56		 push	 esi
  00017	50		 push	 eax
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File a:\vs\vc\include\vector

; 1641 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEPAPAVCArea@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@1@0PAPAV2@@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCRotationDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCRotationDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CRotationDecorator *,NEffectUpdateDecorator::CRotationDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCRotationDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CRotationDecorator *,NEffectUpdateDecorator::CRotationDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCGravityDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCGravityDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CGravityDecorator *,NEffectUpdateDecorator::CGravityDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCGravityDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CGravityDecorator *,NEffectUpdateDecorator::CGravityDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CAirResistanceDecorator *,NEffectUpdateDecorator::CAirResistanceDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CAirResistanceDecorator *,NEffectUpdateDecorator::CAirResistanceDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCWDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCWDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCNullDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCNullDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CNullDecorator *,NEffectUpdateDecorator::CNullDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCNullDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CNullDecorator *,NEffectUpdateDecorator::CNullDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCHeaderDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCHeaderDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CHeaderDecorator *,NEffectUpdateDecorator::CHeaderDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCHeaderDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CHeaderDecorator *,NEffectUpdateDecorator::CHeaderDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCTerrain@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCTerrain@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CTerrain * *,CTerrain * *,std::_Wrap_alloc<std::allocator<CTerrain *> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_move@PAPAVCTerrain@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CTerrain * *,CTerrain * *,std::_Wrap_alloc<std::allocator<CTerrain *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCArea@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCArea@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CArea * *,CArea * *,std::_Wrap_alloc<std::allocator<CArea *> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_move@PAPAVCArea@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CArea * *,CArea * *,std::_Wrap_alloc<std::allocator<CArea *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCGraphicObjectInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCGraphicObjectInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CGraphicObjectInstance * *,CGraphicObjectInstance * *,std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_move@PAPAVCGraphicObjectInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CGraphicObjectInstance * *,CGraphicObjectInstance * *,std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CRotationDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CRotationDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCRotationDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCRotationDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CRotationDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCRotationDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CRotationDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCRotationDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCRotationDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCRotationDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CGravityDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CGravityDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCGravityDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCGravityDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CGravityDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCGravityDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CGravityDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCGravityDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCGravityDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCGravityDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CAirResistanceDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CAirResistanceDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CAirResistanceDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationRandomDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationRandomDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CNullDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CNullDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCNullDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCNullDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CNullDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCNullDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CNullDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCNullDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCNullDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCNullDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CHeaderDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CHeaderDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CHeaderDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CHeaderDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCHeaderDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCHeaderDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCHeaderDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAXPAPAVCTerrain@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAXPAPAVCTerrain@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTerrain *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAXPAPAVCTerrain@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTerrain *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAXPAPAVCArea@@0AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAXPAPAVCArea@@0AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CArea *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAXPAPAVCArea@@0AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CArea *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCGraphicObjectInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicObjectInstance@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCGraphicObjectInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicObjectInstance@@0@Z PROC ; std::_Ptr_cat<CGraphicObjectInstance *,CGraphicObjectInstance *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCGraphicObjectInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicObjectInstance@@0@Z ENDP ; std::_Ptr_cat<CGraphicObjectInstance *,CGraphicObjectInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CTerrain * *,CTerrain * *>, COMDAT

; 2428 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

  0000c	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	57		 push	 edi
  00013	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2432 : 	return (_Dest + _Count);

  00025	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 2433 : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Move@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CTerrain * *,CTerrain * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCTerrain@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SAXAAV?$allocator@PAVCTerrain@@@1@PAPAVCTerrain@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCTerrain@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SAXAAV?$allocator@PAVCTerrain@@@1@PAPAVCTerrain@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<CTerrain *> >::construct<CTerrain *,CTerrain * const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCTerrain@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SAXAAV?$allocator@PAVCTerrain@@@1@PAPAVCTerrain@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<CTerrain *> >::construct<CTerrain *,CTerrain * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@ABQAVCTerrain@@@std@@YAABQAVCTerrain@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVCTerrain@@@std@@YAABQAVCTerrain@@ABQAV1@@Z PROC ; std::forward<CTerrain * const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVCTerrain@@@std@@YAABQAVCTerrain@@ABQAV1@@Z ENDP ; std::forward<CTerrain * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCTerrain@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SAXAAV?$allocator@PAVCTerrain@@@1@PAPAVCTerrain@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCTerrain@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SAXAAV?$allocator@PAVCTerrain@@@1@PAPAVCTerrain@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<CTerrain *> >::construct<CTerrain *,CTerrain * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCTerrain@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SAXAAV?$allocator@PAVCTerrain@@@1@PAPAVCTerrain@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<CTerrain *> >::construct<CTerrain *,CTerrain * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAVCTerrain@@@std@@YAAAPAVCTerrain@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVCTerrain@@@std@@YAAAPAVCTerrain@@AAPAV1@@Z PROC ; std::forward<CTerrain * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVCTerrain@@@std@@YAAAPAVCTerrain@@AAPAV1@@Z ENDP ; std::forward<CTerrain * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@PAVCTerrain@@IPAV1@@std@@YAXPAPAVCTerrain@@IAAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_def_fill_n@PAVCTerrain@@IPAV1@@std@@YAXPAPAVCTerrain@@IAAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<CTerrain *,unsigned int,CTerrain *>, COMDAT

; 681  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 09		 je	 SHORT $LN5@Uninit_def
; File a:\vs\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000e	33 c0		 xor	 eax, eax
  00010	f3 ab		 rep stosd
  00012	5f		 pop	 edi
$LN5@Uninit_def:

; 683  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Uninit_def_fill_n@PAVCTerrain@@IPAV1@@std@@YAXPAPAVCTerrain@@IAAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<CTerrain *,unsigned int,CTerrain *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCTerrain@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTerrain@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCTerrain@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTerrain@@0@Z PROC ; std::_Ptr_cat<CTerrain *,CTerrain *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCTerrain@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTerrain@@0@Z ENDP ; std::_Ptr_cat<CTerrain *,CTerrain *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCTerrain@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVCTerrain@@PAPAV2@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCTerrain@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVCTerrain@@PAPAV2@@Z PROC ; std::_Ptr_cat<CTerrain *,CTerrain *>, COMDAT

; 453  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 454  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 455  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 456  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCTerrain@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVCTerrain@@PAPAV2@@Z ENDP ; std::_Ptr_cat<CTerrain *,CTerrain *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVCTerrain@@@std@@YAPAPAVCTerrain@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVCTerrain@@@std@@YAPAPAVCTerrain@@PAPAV1@@Z PROC ; std::_Val_type<CTerrain * *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAVCTerrain@@@std@@YAPAPAVCTerrain@@PAPAV1@@Z ENDP ; std::_Val_type<CTerrain * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CArea * *,CArea * *>, COMDAT

; 2428 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

  0000c	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	57		 push	 edi
  00013	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2432 : 	return (_Dest + _Count);

  00025	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 2433 : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Move@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CArea * *,CArea * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCArea@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SAXAAV?$allocator@PAVCArea@@@1@PAPAVCArea@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCArea@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SAXAAV?$allocator@PAVCArea@@@1@PAPAVCArea@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<CArea *> >::construct<CArea *,CArea * const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCArea@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SAXAAV?$allocator@PAVCArea@@@1@PAPAVCArea@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<CArea *> >::construct<CArea *,CArea * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@ABQAVCArea@@@std@@YAABQAVCArea@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVCArea@@@std@@YAABQAVCArea@@ABQAV1@@Z PROC ; std::forward<CArea * const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVCArea@@@std@@YAABQAVCArea@@ABQAV1@@Z ENDP ; std::forward<CArea * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCArea@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SAXAAV?$allocator@PAVCArea@@@1@PAPAVCArea@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCArea@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SAXAAV?$allocator@PAVCArea@@@1@PAPAVCArea@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<CArea *> >::construct<CArea *,CArea * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCArea@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SAXAAV?$allocator@PAVCArea@@@1@PAPAVCArea@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<CArea *> >::construct<CArea *,CArea * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAVCArea@@@std@@YAAAPAVCArea@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVCArea@@@std@@YAAAPAVCArea@@AAPAV1@@Z PROC ; std::forward<CArea * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVCArea@@@std@@YAAAPAVCArea@@AAPAV1@@Z ENDP ; std::forward<CArea * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@PAVCArea@@IPAV1@@std@@YAXPAPAVCArea@@IAAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_def_fill_n@PAVCArea@@IPAV1@@std@@YAXPAPAVCArea@@IAAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<CArea *,unsigned int,CArea *>, COMDAT

; 681  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 09		 je	 SHORT $LN5@Uninit_def
; File a:\vs\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000e	33 c0		 xor	 eax, eax
  00010	f3 ab		 rep stosd
  00012	5f		 pop	 edi
$LN5@Uninit_def:

; 683  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Uninit_def_fill_n@PAVCArea@@IPAV1@@std@@YAXPAPAVCArea@@IAAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<CArea *,unsigned int,CArea *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCArea@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCArea@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCArea@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCArea@@0@Z PROC ; std::_Ptr_cat<CArea *,CArea *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCArea@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCArea@@0@Z ENDP ; std::_Ptr_cat<CArea *,CArea *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCArea@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVCArea@@PAPAV2@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCArea@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVCArea@@PAPAV2@@Z PROC ; std::_Ptr_cat<CArea *,CArea *>, COMDAT

; 453  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 454  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 455  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 456  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCArea@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVCArea@@PAPAV2@@Z ENDP ; std::_Ptr_cat<CArea *,CArea *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVCArea@@@std@@YAPAPAVCArea@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVCArea@@@std@@YAPAPAVCArea@@PAPAV1@@Z PROC ; std::_Val_type<CArea * *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAVCArea@@@std@@YAPAPAVCArea@@PAPAV1@@Z ENDP ; std::_Val_type<CArea * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicObjectInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicObjectInstance@@@1@PAPAVCGraphicObjectInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCGraphicObjectInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicObjectInstance@@@1@PAPAVCGraphicObjectInstance@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<CGraphicObjectInstance *> >::construct<CGraphicObjectInstance *,CGraphicObjectInstance * const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCGraphicObjectInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicObjectInstance@@@1@PAPAVCGraphicObjectInstance@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<CGraphicObjectInstance *> >::construct<CGraphicObjectInstance *,CGraphicObjectInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@ABQAVCGraphicObjectInstance@@@std@@YAABQAVCGraphicObjectInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVCGraphicObjectInstance@@@std@@YAABQAVCGraphicObjectInstance@@ABQAV1@@Z PROC ; std::forward<CGraphicObjectInstance * const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVCGraphicObjectInstance@@@std@@YAABQAVCGraphicObjectInstance@@ABQAV1@@Z ENDP ; std::forward<CGraphicObjectInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicObjectInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicObjectInstance@@@1@PAPAVCGraphicObjectInstance@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCGraphicObjectInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicObjectInstance@@@1@PAPAVCGraphicObjectInstance@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<CGraphicObjectInstance *> >::construct<CGraphicObjectInstance *,CGraphicObjectInstance * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCGraphicObjectInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicObjectInstance@@@1@PAPAVCGraphicObjectInstance@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<CGraphicObjectInstance *> >::construct<CGraphicObjectInstance *,CGraphicObjectInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAVCGraphicObjectInstance@@@std@@YAAAPAVCGraphicObjectInstance@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVCGraphicObjectInstance@@@std@@YAAAPAVCGraphicObjectInstance@@AAPAV1@@Z PROC ; std::forward<CGraphicObjectInstance * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVCGraphicObjectInstance@@@std@@YAAAPAVCGraphicObjectInstance@@AAPAV1@@Z ENDP ; std::forward<CGraphicObjectInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Copy_impl@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_impl@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z PROC ; std::_Copy_impl<CArea * *,CArea * *>, COMDAT

; 2064 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2054 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi

; 2055 : 	_CSTD memmove(&*_Dest, &*_First,
; 2056 : 		_Count * sizeof (*_First));

  0000c	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	57		 push	 edi
  00013	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2057 : 	return (_Dest + _Count);

  00025	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 2065 : 	return (_Copy_impl(_First, _Last,
; 2066 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2067 : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Copy_impl@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z ENDP ; std::_Copy_impl<CArea * *,CArea * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Copy_impl@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_impl@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z PROC ; std::_Copy_impl<CTerrain * *,CTerrain * *>, COMDAT

; 2064 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2054 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi

; 2055 : 	_CSTD memmove(&*_Dest, &*_First,
; 2056 : 		_Count * sizeof (*_First));

  0000c	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	57		 push	 edi
  00013	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2057 : 	return (_Dest + _Count);

  00025	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 2065 : 	return (_Copy_impl(_First, _Last,
; 2066 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2067 : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Copy_impl@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z ENDP ; std::_Copy_impl<CTerrain * *,CTerrain * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAUFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA$$QAUFPushAreaToDeleteVector@CMapOutdoor@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA$$QAUFPushAreaToDeleteVector@CMapOutdoor@@AAU12@@Z PROC ; std::move<CMapOutdoor::FPushAreaToDeleteVector &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA$$QAUFPushAreaToDeleteVector@CMapOutdoor@@AAU12@@Z ENDP ; std::move<CMapOutdoor::FPushAreaToDeleteVector &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCArea@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YAXPAPAVCArea@@0AAUFPushAreaToDeleteVector@CMapOutdoor@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCArea@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YAXPAPAVCArea@@0AAUFPushAreaToDeleteVector@CMapOutdoor@@@Z PROC ; std::_For_each<CArea * *,CMapOutdoor::FPushAreaToDeleteVector>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 12		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Func$[ebp]
  00027	e8 00 00 00 00	 call	 ??RFPushAreaToDeleteVector@CMapOutdoor@@QAEXPAVCArea@@@Z ; CMapOutdoor::FPushAreaToDeleteVector::operator()
  0002c	47		 inc	 edi
  0002d	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00030	3b fb		 cmp	 edi, ebx
  00032	75 ee		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 25   : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_For_each@PAPAVCArea@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YAXPAPAVCArea@@0AAUFPushAreaToDeleteVector@CMapOutdoor@@@Z ENDP ; std::_For_each<CArea * *,CMapOutdoor::FPushAreaToDeleteVector>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAUFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA$$QAUFPushTerrainToDeleteVector@CMapOutdoor@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA$$QAUFPushTerrainToDeleteVector@CMapOutdoor@@AAU12@@Z PROC ; std::move<CMapOutdoor::FPushTerrainToDeleteVector &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA$$QAUFPushTerrainToDeleteVector@CMapOutdoor@@AAU12@@Z ENDP ; std::move<CMapOutdoor::FPushTerrainToDeleteVector &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCTerrain@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YAXPAPAVCTerrain@@0AAUFPushTerrainToDeleteVector@CMapOutdoor@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCTerrain@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YAXPAPAVCTerrain@@0AAUFPushTerrainToDeleteVector@CMapOutdoor@@@Z PROC ; std::_For_each<CTerrain * *,CMapOutdoor::FPushTerrainToDeleteVector>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 12		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Func$[ebp]
  00027	e8 00 00 00 00	 call	 ??RFPushTerrainToDeleteVector@CMapOutdoor@@QAEXPAVCTerrain@@@Z ; CMapOutdoor::FPushTerrainToDeleteVector::operator()
  0002c	47		 inc	 edi
  0002d	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00030	3b fb		 cmp	 edi, ebx
  00032	75 ee		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 25   : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_For_each@PAPAVCTerrain@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YAXPAPAVCTerrain@@0AAUFPushTerrainToDeleteVector@CMapOutdoor@@@Z ENDP ; std::_For_each<CTerrain * *,CMapOutdoor::FPushTerrainToDeleteVector>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCArea@@@Z@std@@YA$$QAP6AXPAVCArea@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCArea@@@Z@std@@YA$$QAP6AXPAVCArea@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(CArea *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCArea@@@Z@std@@YA$$QAP6AXPAVCArea@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(CArea *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCArea@@P6AXPAV1@@Z@std@@YAXPAPAVCArea@@0AAP6AXPAV1@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCArea@@P6AXPAV1@@Z@std@@YAXPAPAVCArea@@0AAP6AXPAV1@@Z@Z PROC ; std::_For_each<CArea * *,void (__cdecl*)(CArea *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCArea@@P6AXPAV1@@Z@std@@YAXPAPAVCArea@@0AAP6AXPAV1@@Z@Z ENDP ; std::_For_each<CArea * *,void (__cdecl*)(CArea *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCTerrain@@@Z@std@@YA$$QAP6AXPAVCTerrain@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCTerrain@@@Z@std@@YA$$QAP6AXPAVCTerrain@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(CTerrain *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCTerrain@@@Z@std@@YA$$QAP6AXPAVCTerrain@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(CTerrain *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCTerrain@@P6AXPAV1@@Z@std@@YAXPAPAVCTerrain@@0AAP6AXPAV1@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCTerrain@@P6AXPAV1@@Z@std@@YAXPAPAVCTerrain@@0AAP6AXPAV1@@Z@Z PROC ; std::_For_each<CTerrain * *,void (__cdecl*)(CTerrain *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCTerrain@@P6AXPAV1@@Z@std@@YAXPAPAVCTerrain@@0AAP6AXPAV1@@Z@Z ENDP ; std::_For_each<CTerrain * *,void (__cdecl*)(CTerrain *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@AAV10@PAPAVCArea@@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@AAV10@PAPAVCArea@@@Z PROC ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CArea *> > >, COMDAT

; 404  : 	{	// convert to checked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		this->_Ptr = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@AAV10@PAPAVCArea@@@Z ENDP ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CArea *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Find@PAPAVCArea@@PAV1@@std@@YAPAPAVCArea@@PAPAV1@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find@PAPAVCArea@@PAV1@@std@@YAPAPAVCArea@@PAPAV1@0ABQAV1@@Z PROC ; std::_Find<CArea * *,CArea *>, COMDAT

; 3034 : 	{	// find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3035 : 	// activate optimization for pointers to (const) bytes and integral values
; 3036 : 	typedef integral_constant<bool,
; 3037 : 		(  is_same<_InIt, char *>::value
; 3038 : 		|| is_same<_InIt, signed char *>::value
; 3039 : 		|| is_same<_InIt, unsigned char *>::value
; 3040 : 		|| is_same<_InIt, const char *>::value
; 3041 : 		|| is_same<_InIt, const signed char *>::value
; 3042 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3043 : 		&& is_integral<_Ty>::value
; 3044 : 	> _Memchr_opt;
; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 3025 : 	for (; _First != _Last; ++_First)

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	3b c2		 cmp	 eax, edx
  0000b	74 10		 je	 SHORT $LN10@Find

; 3026 : 		if (*_First == _Val)

  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00010	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL6@Find:
  00012	39 08		 cmp	 DWORD PTR [eax], ecx
  00014	74 07		 je	 SHORT $LN10@Find

; 3025 : 	for (; _First != _Last; ++_First)

  00016	83 c0 04	 add	 eax, 4
  00019	3b c2		 cmp	 eax, edx
  0001b	75 f5		 jne	 SHORT $LL6@Find
$LN10@Find:

; 3046 : 	}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Find@PAPAVCArea@@PAV1@@std@@YAPAPAVCArea@@PAPAV1@0ABQAV1@@Z ENDP ; std::_Find<CArea * *,CArea *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@YAPBQAVCArea@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@YAPBQAVCArea@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CArea *> > >, COMDAT

; 264  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 265  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 266  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@YAPBQAVCArea@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CArea *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CArea *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@YAPAPAVCArea@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CArea *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@AAV10@PAPAVCTerrain@@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@AAV10@PAPAVCTerrain@@@Z PROC ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CTerrain *> > >, COMDAT

; 404  : 	{	// convert to checked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		this->_Ptr = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@AAV10@PAPAVCTerrain@@@Z ENDP ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CTerrain *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Find@PAPAVCTerrain@@PAV1@@std@@YAPAPAVCTerrain@@PAPAV1@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find@PAPAVCTerrain@@PAV1@@std@@YAPAPAVCTerrain@@PAPAV1@0ABQAV1@@Z PROC ; std::_Find<CTerrain * *,CTerrain *>, COMDAT

; 3034 : 	{	// find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3035 : 	// activate optimization for pointers to (const) bytes and integral values
; 3036 : 	typedef integral_constant<bool,
; 3037 : 		(  is_same<_InIt, char *>::value
; 3038 : 		|| is_same<_InIt, signed char *>::value
; 3039 : 		|| is_same<_InIt, unsigned char *>::value
; 3040 : 		|| is_same<_InIt, const char *>::value
; 3041 : 		|| is_same<_InIt, const signed char *>::value
; 3042 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3043 : 		&& is_integral<_Ty>::value
; 3044 : 	> _Memchr_opt;
; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 3025 : 	for (; _First != _Last; ++_First)

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	3b c2		 cmp	 eax, edx
  0000b	74 10		 je	 SHORT $LN10@Find

; 3026 : 		if (*_First == _Val)

  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00010	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL6@Find:
  00012	39 08		 cmp	 DWORD PTR [eax], ecx
  00014	74 07		 je	 SHORT $LN10@Find

; 3025 : 	for (; _First != _Last; ++_First)

  00016	83 c0 04	 add	 eax, 4
  00019	3b c2		 cmp	 eax, edx
  0001b	75 f5		 jne	 SHORT $LL6@Find
$LN10@Find:

; 3046 : 	}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Find@PAPAVCTerrain@@PAV1@@std@@YAPAPAVCTerrain@@PAPAV1@0ABQAV1@@Z ENDP ; std::_Find<CTerrain * *,CTerrain *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@YAPBQAVCTerrain@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@YAPBQAVCTerrain@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CTerrain *> > >, COMDAT

; 264  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 265  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 266  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@YAPBQAVCTerrain@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CTerrain *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CTerrain *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@YAPAPAVCTerrain@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CTerrain *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@AAV10@PAPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@AAV10@PAPAVCGraphicObjectInstance@@@Z PROC ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >, COMDAT

; 404  : 	{	// convert to checked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		this->_Ptr = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@AAV10@PAPAVCGraphicObjectInstance@@@Z ENDP ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Find@PAPAVCGraphicObjectInstance@@PAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find@PAPAVCGraphicObjectInstance@@PAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@0ABQAV1@@Z PROC ; std::_Find<CGraphicObjectInstance * *,CGraphicObjectInstance *>, COMDAT

; 3034 : 	{	// find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3035 : 	// activate optimization for pointers to (const) bytes and integral values
; 3036 : 	typedef integral_constant<bool,
; 3037 : 		(  is_same<_InIt, char *>::value
; 3038 : 		|| is_same<_InIt, signed char *>::value
; 3039 : 		|| is_same<_InIt, unsigned char *>::value
; 3040 : 		|| is_same<_InIt, const char *>::value
; 3041 : 		|| is_same<_InIt, const signed char *>::value
; 3042 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3043 : 		&& is_integral<_Ty>::value
; 3044 : 	> _Memchr_opt;
; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 3025 : 	for (; _First != _Last; ++_First)

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	3b c2		 cmp	 eax, edx
  0000b	74 10		 je	 SHORT $LN10@Find

; 3026 : 		if (*_First == _Val)

  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00010	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL6@Find:
  00012	39 08		 cmp	 DWORD PTR [eax], ecx
  00014	74 07		 je	 SHORT $LN10@Find

; 3025 : 	for (; _First != _Last; ++_First)

  00016	83 c0 04	 add	 eax, 4
  00019	3b c2		 cmp	 eax, edx
  0001b	75 f5		 jne	 SHORT $LL6@Find
$LN10@Find:

; 3046 : 	}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Find@PAPAVCGraphicObjectInstance@@PAV1@@std@@YAPAPAVCGraphicObjectInstance@@PAPAV1@0ABQAV1@@Z ENDP ; std::_Find<CGraphicObjectInstance * *,CGraphicObjectInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ??_G?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEPAXI@Z PROC ; RangeTester<FGetShadowReceiverFromCollisionData>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 56   : 	virtual ~SpherePackCallback() {}

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7SpherePackCallback@@6B@
  00010	74 09		 je	 SHORT $LN8@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN8@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEPAXI@Z ENDP ; RangeTester<FGetShadowReceiverFromCollisionData>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?PointTest2dCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?PointTest2dCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<FGetShadowReceiverFromCollisionData>::PointTest2dCallback, COMDAT
; _this$ = ecx

; 50   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)

  00003	83 7d 10 02	 cmp	 DWORD PTR _state$[ebp], 2
  00007	74 0e		 je	 SHORT $LN1@PointTest2

; 56   : 		{
; 57   : #ifdef SPHERELIB_STRICT
; 58   : 			puts("FIND!!");
; 59   : #endif
; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00009	8b 45 0c	 mov	 eax, DWORD PTR _sphere$[ebp]
  0000c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000f	ff 70 44	 push	 DWORD PTR [eax+68]
  00012	e8 00 00 00 00	 call	 ??RFGetShadowReceiverFromCollisionData@@QAEXPAVCGraphicObjectInstance@@@Z ; FGetShadowReceiverFromCollisionData::operator()
$LN1@PointTest2:

; 61   : 		}
; 62   : 	}

  00017	5d		 pop	 ebp
  00018	c2 0c 00	 ret	 12			; 0000000cH
?PointTest2dCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<FGetShadowReceiverFromCollisionData>::PointTest2dCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?RangeTestCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_distance$ = 12						; size = 4
_sphere$ = 16						; size = 4
_state$ = 20						; size = 4
?RangeTestCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<FGetShadowReceiverFromCollisionData>::RangeTestCallback, COMDAT
; _this$ = ecx

; 40   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)

  00003	83 7d 14 02	 cmp	 DWORD PTR _state$[ebp], 2
  00007	74 0e		 je	 SHORT $LN1@RangeTestC

; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00009	8b 45 10	 mov	 eax, DWORD PTR _sphere$[ebp]
  0000c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000f	ff 70 44	 push	 DWORD PTR [eax+68]
  00012	e8 00 00 00 00	 call	 ??RFGetShadowReceiverFromCollisionData@@QAEXPAVCGraphicObjectInstance@@@Z ; FGetShadowReceiverFromCollisionData::operator()
$LN1@RangeTestC:

; 47   : 	}

  00017	5d		 pop	 ebp
  00018	c2 10 00	 ret	 16			; 00000010H
?RangeTestCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<FGetShadowReceiverFromCollisionData>::RangeTestCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?VisibilityCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?VisibilityCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<FGetShadowReceiverFromCollisionData>::VisibilityCallback, COMDAT
; _this$ = ecx

; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};

  00000	c2 0c 00	 ret	 12			; 0000000cH
?VisibilityCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<FGetShadowReceiverFromCollisionData>::VisibilityCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?RayTraceCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_pInstance$ = 16					; size = 4
_distance$ = 16						; size = 4
_sect$ = 20						; size = 4
_sphere$ = 24						; size = 4
?RayTraceCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z PROC ; RangeTester<FGetShadowReceiverFromCollisionData>::RayTraceCallback, COMDAT
; _this$ = ecx

; 27   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)

  00003	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  00008	0f 57 c0	 xorps	 xmm0, xmm0
  0000b	0f 2f c1	 comiss	 xmm0, xmm1
  0000e	73 06		 jae	 SHORT $LN1@RayTraceCa
  00010	0f 2f 4d 10	 comiss	 xmm1, DWORD PTR _distance$[ebp]
  00014	72 5b		 jb	 SHORT $LN8@RayTraceCa
$LN1@RayTraceCa:

; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00016	8b 45 18	 mov	 eax, DWORD PTR _sphere$[ebp]
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  0001e	8b 70 44	 mov	 esi, DWORD PTR [eax+68]
  00021	89 75 10	 mov	 DWORD PTR _pInstance$[ebp], esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 176  : 		if (!pInstance)

  00024	85 f6		 test	 esi, esi
  00026	74 47		 je	 SHORT $LN13@RayTraceCa

; 177  : 			return;
; 178  : 
; 179  : 		if (TREE_OBJECT == pInstance->GetType() || ACTOR_OBJECT == pInstance->GetType() || EFFECT_OBJECT == pInstance->GetType())

  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	8b ce		 mov	 ecx, esi
  0002c	ff 50 04	 call	 DWORD PTR [eax+4]
  0002f	3d a6 f7 c9 8a	 cmp	 eax, -1966475354	; 8ac9f7a6H
  00034	74 39		 je	 SHORT $LN13@RayTraceCa
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8b ce		 mov	 ecx, esi
  0003a	ff 50 04	 call	 DWORD PTR [eax+4]
  0003d	3d 24 6c a7 29	 cmp	 eax, 698838052		; 29a76c24H
  00042	74 2b		 je	 SHORT $LN13@RayTraceCa
  00044	8b 06		 mov	 eax, DWORD PTR [esi]
  00046	8b ce		 mov	 ecx, esi
  00048	ff 50 04	 call	 DWORD PTR [eax+4]
  0004b	3d c6 97 fa 1c	 cmp	 eax, 486184902		; 1cfa97c6H
  00050	74 1d		 je	 SHORT $LN13@RayTraceCa

; 180  : 			return;
; 181  : 		if (pInstance->CollisionDynamicSphere(*m_pdsi))

  00052	ff 77 08	 push	 DWORD PTR [edi+8]
  00055	8b ce		 mov	 ecx, esi
  00057	e8 00 00 00 00	 call	 ?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::CollisionDynamicSphere
  0005c	84 c0		 test	 al, al
  0005e	74 0f		 je	 SHORT $LN13@RayTraceCa

; 182  : 		{
; 183  : 			m_pkVct_pkShadowReceiver->push_back(pInstance);

  00060	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00063	8d 45 10	 lea	 eax, DWORD PTR _pInstance$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXABQAVCGraphicObjectInstance@@@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::push_back

; 184  : 			m_bCollide = true;

  0006c	c6 07 01	 mov	 BYTE PTR [edi], 1
$LN13@RayTraceCa:
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
$LN8@RayTraceCa:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 34   : 	};

  00071	5d		 pop	 ebp
  00072	c2 14 00	 ret	 20			; 00000014H
?RayTraceCallback@?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ENDP ; RangeTester<FGetShadowReceiverFromCollisionData>::RayTraceCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ??1?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAE@XZ
_TEXT	SEGMENT
??1?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAE@XZ PROC ; RangeTester<FGetShadowReceiverFromCollisionData>::~RangeTester<FGetShadowReceiverFromCollisionData>, COMDAT
; _this$ = ecx
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SpherePackCallback@@6B@
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 19   : 	{}

  00006	c3		 ret	 0
??1?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAE@XZ ENDP ; RangeTester<FGetShadowReceiverFromCollisionData>::~RangeTester<FGetShadowReceiverFromCollisionData>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ??0?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@QAE@PAUFGetShadowReceiverFromCollisionData@@M@Z
_TEXT	SEGMENT
_fn$ = 8						; size = 4
_distance$ = 12						; size = 4
??0?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@QAE@PAUFGetShadowReceiverFromCollisionData@@M@Z PROC ; RangeTester<FGetShadowReceiverFromCollisionData>::RangeTester<FGetShadowReceiverFromCollisionData>, COMDAT
; _this$ = ecx

; 16   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _fn$[ebp]
  00006	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _distance$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000e	8b c1		 mov	 eax, ecx
  00010	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@6B@
  00016	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??0?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@QAE@PAUFGetShadowReceiverFromCollisionData@@M@Z ENDP ; RangeTester<FGetShadowReceiverFromCollisionData>::RangeTester<FGetShadowReceiverFromCollisionData>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Sort@PAPAVCGraphicObjectInstance@@HUFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0HUFPCBlockerDistanceSort@@@Z
_TEXT	SEGMENT
__Mid$1 = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 12
??$_Sort@PAPAVCGraphicObjectInstance@@HUFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0HUFPCBlockerDistanceSort@@@Z PROC ; std::_Sort<CGraphicObjectInstance * *,int,FPCBlockerDistanceSort>, COMDAT

; 3122 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 3123 : 	_Diff _Count;
; 3124 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

  00008	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000b	8b c6		 mov	 eax, esi
  0000d	57		 push	 edi
  0000e	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00011	2b c7		 sub	 eax, edi
  00013	c1 f8 02	 sar	 eax, 2
  00016	83 f8 20	 cmp	 eax, 32			; 00000020H
  00019	0f 8e 96 00 00
	00		 jle	 $LN3@Sort
  0001f	8b 5d 10	 mov	 ebx, DWORD PTR __Ideal$[ebp]
$LL7@Sort:
  00022	85 db		 test	 ebx, ebx
  00024	0f 8e b7 00 00
	00		 jle	 $LN6@Sort

; 3125 : 		{	// divide and conquer by quicksort
; 3126 : 		pair<_RanIt, _RanIt> _Mid =
; 3127 : 			_Unguarded_partition(_First, _Last, _Pred);

  0002a	f3 0f 7e 45 14	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  0002f	8d 45 f8	 lea	 eax, DWORD PTR __Mid$1[ebp]
  00032	8b 4d 1c	 mov	 ecx, DWORD PTR __Pred$[ebp+8]
  00035	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00038	8b d4		 mov	 edx, esp
  0003a	56		 push	 esi
  0003b	57		 push	 edi
  0003c	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00040	50		 push	 eax
  00041	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00044	e8 00 00 00 00	 call	 ??$_Unguarded_partition@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YA?AU?$pair@PAPAVCGraphicObjectInstance@@PAPAV1@@0@PAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z ; std::_Unguarded_partition<CGraphicObjectInstance * *,FPCBlockerDistanceSort>

; 3128 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

  00049	8b c3		 mov	 eax, ebx

; 3129 : 
; 3130 : 		if (_Mid.first - _First < _Last - _Mid.second)
; 3131 : 			{	// loop on second half
; 3132 : 			_Sort(_First, _Mid.first, _Ideal, _Pred);

  0004b	f3 0f 7e 45 14	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  00050	99		 cdq
  00051	8b ce		 mov	 ecx, esi
  00053	2b c2		 sub	 eax, edx
  00055	83 c4 18	 add	 esp, 24			; 00000018H
  00058	8b d8		 mov	 ebx, eax
  0005a	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0005d	d1 fb		 sar	 ebx, 1
  0005f	8b c3		 mov	 eax, ebx
  00061	99		 cdq
  00062	2b c2		 sub	 eax, edx
  00064	8b 55 fc	 mov	 edx, DWORD PTR __Mid$1[ebp+4]
  00067	d1 f8		 sar	 eax, 1
  00069	2b ca		 sub	 ecx, edx
  0006b	03 d8		 add	 ebx, eax
  0006d	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00070	8b 45 f8	 mov	 eax, DWORD PTR __Mid$1[ebp]
  00073	2b c7		 sub	 eax, edi
  00075	83 e0 fc	 and	 eax, -4			; fffffffcH
  00078	3b c1		 cmp	 eax, ecx
  0007a	8b 45 1c	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  0007d	8b cc		 mov	 ecx, esp
  0007f	53		 push	 ebx
  00080	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00084	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00087	7d 0f		 jge	 SHORT $LN5@Sort
  00089	8b 45 f8	 mov	 eax, DWORD PTR __Mid$1[ebp]
  0008c	50		 push	 eax
  0008d	57		 push	 edi
  0008e	e8 00 00 00 00	 call	 ??$_Sort@PAPAVCGraphicObjectInstance@@HUFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0HUFPCBlockerDistanceSort@@@Z ; std::_Sort<CGraphicObjectInstance * *,int,FPCBlockerDistanceSort>

; 3133 : 			_First = _Mid.second;

  00093	8b 7d fc	 mov	 edi, DWORD PTR __Mid$1[ebp+4]

; 3134 : 			}
; 3135 : 		else

  00096	eb 0a		 jmp	 SHORT $LN34@Sort
$LN5@Sort:

; 3136 : 			{	// loop on first half
; 3137 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  00098	56		 push	 esi
  00099	52		 push	 edx
  0009a	e8 00 00 00 00	 call	 ??$_Sort@PAPAVCGraphicObjectInstance@@HUFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0HUFPCBlockerDistanceSort@@@Z ; std::_Sort<CGraphicObjectInstance * *,int,FPCBlockerDistanceSort>

; 3138 : 			_Last = _Mid.first;

  0009f	8b 75 f8	 mov	 esi, DWORD PTR __Mid$1[ebp]
$LN34@Sort:

; 3136 : 			{	// loop on first half
; 3137 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  000a2	8b c6		 mov	 eax, esi
  000a4	83 c4 18	 add	 esp, 24			; 00000018H
  000a7	2b c7		 sub	 eax, edi
  000a9	c1 f8 02	 sar	 eax, 2
  000ac	83 f8 20	 cmp	 eax, 32			; 00000020H
  000af	0f 8f 6d ff ff
	ff		 jg	 $LL7@Sort
$LN3@Sort:

; 3143 : 		{	// heap sort if too many divisions
; 3144 : 		_STD make_heap(_First, _Last, _Pred);
; 3145 : 		_STD sort_heap(_First, _Last, _Pred);
; 3146 : 		}
; 3147 : 	else if (1 < _Count)

  000b5	83 f8 01	 cmp	 eax, 1
  000b8	7e 20		 jle	 SHORT $LN27@Sort

; 2488 : 	}
; 2489 : 
; 2490 : 		// TEMPLATE FUNCTION sort_heap
; 2491 : template<class _RanIt> inline
; 2492 : 	void sort_heap(_RanIt _First, _RanIt _Last)
; 2493 : 	{	// order heap by repeatedly popping, using operator<
; 2494 : 	_STD sort_heap(_First, _Last, less<>());
; 2495 : 	}
; 2496 : 
; 2497 : 		// TEMPLATE FUNCTION lower_bound WITH PRED
; 2498 : template<class _FwdIt,
; 2499 : 	class _Ty,
; 2500 : 	class _Diff,
; 2501 : 	class _Pr> inline
; 2502 : 	_FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last,
; 2503 : 		const _Ty& _Val, _Pr _Pred, _Diff *)
; 2504 : 	{	// find first element not before _Val, using _Pred
; 2505 : 	_Diff _Count = 0;
; 2506 : 	_Distance(_First, _Last, _Count);
; 2507 : 
; 2508 : 	while (0 < _Count)
; 2509 : 		{	// divide and conquer, find half that contains answer
; 2510 : 		_Diff _Count2 = _Count / 2;
; 2511 : 		_FwdIt _Mid = _First;
; 2512 : 		_STD advance(_Mid, _Count2);
; 2513 : 
; 2514 : 		if (_Pred(*_Mid, _Val))
; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;
; 2519 : 			}
; 2520 : 		else
; 2521 : 			_Count = _Count2;
; 2522 : 		}
; 2523 : 	return (_First);
; 2524 : 	}
; 2525 : 
; 2526 : template<class _FwdIt,
; 2527 : 	class _Ty,
; 2528 : 	class _Pr> inline
; 2529 : 	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
; 2530 : 		const _Ty& _Val, _Pr _Pred)
; 2531 : 	{	// find first element not before _Val, using _Pred
; 2532 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2533 : 	return (_Rechecked(_First,
; 2534 : 		_Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2535 : 			_Dist_type(_First))));
; 2536 : 	}
; 2537 : 
; 2538 : 		// TEMPLATE FUNCTION lower_bound
; 2539 : template<class _FwdIt,
; 2540 : 	class _Ty> inline
; 2541 : 	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2542 : 	{	// find first element not before _Val, using operator<
; 2543 : 	return (_STD lower_bound(_First, _Last, _Val, less<>()));
; 2544 : 	}
; 2545 : 
; 2546 : 		// TEMPLATE FUNCTION upper_bound WITH PRED
; 2547 : template<class _FwdIt,
; 2548 : 	class _Ty,
; 2549 : 	class _Diff,
; 2550 : 	class _Pr> inline
; 2551 : 	_FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last,
; 2552 : 		const _Ty& _Val, _Pr _Pred, _Diff *)
; 2553 : 	{	// find first element that _Val is before, using _Pred
; 2554 : 	_Diff _Count = 0;
; 2555 : 	_Distance(_First, _Last, _Count);
; 2556 : 
; 2557 : 	while (0 < _Count)
; 2558 : 		{	// divide and conquer, find half that contains answer
; 2559 : 		_Diff _Count2 = _Count / 2;
; 2560 : 		_FwdIt _Mid = _First;
; 2561 : 		_STD advance(_Mid, _Count2);
; 2562 : 
; 2563 : 		if (!_Pred(_Val, *_Mid))
; 2564 : //		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))
; 2565 : 			{	// try top half
; 2566 : 			_First = ++_Mid;
; 2567 : 			_Count -= _Count2 + 1;
; 2568 : 			}
; 2569 : 		else
; 2570 : 			_Count = _Count2;
; 2571 : 		}
; 2572 : 	return (_First);
; 2573 : 	}
; 2574 : 
; 2575 : template<class _FwdIt,
; 2576 : 	class _Ty,
; 2577 : 	class _Pr> inline
; 2578 : 	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
; 2579 : 		const _Ty& _Val, _Pr _Pred)
; 2580 : 	{	// find first element that _Val is before, using _Pred
; 2581 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2582 : 	return (_Rechecked(_First,
; 2583 : 		_Upper_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2584 : 			_Dist_type(_First))));
; 2585 : 	}
; 2586 : 
; 2587 : 		// TEMPLATE FUNCTION upper_bound
; 2588 : template<class _FwdIt,
; 2589 : 	class _Ty> inline
; 2590 : 	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2591 : 	{	// find first element that _Val is before, using operator<
; 2592 : 	return (_STD upper_bound(_First, _Last, _Val, less<>()));
; 2593 : 	}
; 2594 : 
; 2595 : 		// TEMPLATE FUNCTION equal_range WITH PRED
; 2596 : template<class _FwdIt,
; 2597 : 	class _Ty,
; 2598 : 	class _Diff,
; 2599 : 	class _Pr> inline
; 2600 : 	pair<_FwdIt, _FwdIt>
; 2601 : 		_Equal_range(_FwdIt _First, _FwdIt _Last,
; 2602 : 			const _Ty& _Val, _Pr _Pred, _Diff *)
; 2603 : 	{	// find range equivalent to _Val, using _Pred
; 2604 : 	_Diff _Count = 0;
; 2605 : 	_Distance(_First, _Last, _Count);
; 2606 : 
; 2607 : 	while (0 < _Count)
; 2608 : 		{	// divide and conquer, check midpoint
; 2609 : 		_Diff _Count2 = _Count / 2;
; 2610 : 		_FwdIt _Mid = _First;
; 2611 : 		_STD advance(_Mid, _Count2);
; 2612 : 
; 2613 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2614 : 			{	// range begins above _Mid, loop
; 2615 : 			_First = ++_Mid;
; 2616 : 			_Count -= _Count2 + 1;
; 2617 : 			}
; 2618 : 		else if (_Pred(_Val, *_Mid))
; 2619 : 			_Count = _Count2;	// range in first half, loop
; 2620 : 		else
; 2621 : 			{	// range straddles _Mid, find each end and return
; 2622 : 			_FwdIt _First2 = _STD lower_bound(_First, _Mid, _Val, _Pred);
; 2623 : 			_STD advance(_First, _Count);
; 2624 : 			_FwdIt _Last2 = _STD upper_bound(++_Mid, _First, _Val, _Pred);
; 2625 : 			return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
; 2626 : 			}
; 2627 : 		}
; 2628 : 
; 2629 : 	return (pair<_FwdIt, _FwdIt>(_First, _First));	// empty range
; 2630 : 	}
; 2631 : 
; 2632 : template<class _FwdIt,
; 2633 : 	class _Ty,
; 2634 : 	class _Pr> inline
; 2635 : 	pair<_FwdIt, _FwdIt>
; 2636 : 		equal_range(_FwdIt _First, _FwdIt _Last,
; 2637 : 			const _Ty& _Val, _Pr _Pred)
; 2638 : 	{	// find range equivalent to _Val, using _Pred
; 2639 : 	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2640 : 	pair<_UNCHECKED_TYPE(_FwdIt), _UNCHECKED_TYPE(_FwdIt)> _Ans(
; 2641 : 		_Equal_range(_Unchecked(_First), _Unchecked(_Last),
; 2642 : 			_Val, _Pred, _Dist_type(_First)));
; 2643 : 	return (pair<_FwdIt, _FwdIt>(
; 2644 : 		_Rechecked(_First, _Ans.first),
; 2645 : 		_Rechecked(_Last, _Ans.second)));
; 2646 : 	}
; 2647 : 
; 2648 : 		// TEMPLATE FUNCTION equal_range
; 2649 : template<class _FwdIt,
; 2650 : 	class _Ty> inline
; 2651 : 	pair<_FwdIt, _FwdIt>
; 2652 : 		equal_range(_FwdIt _First, _FwdIt _Last,
; 2653 : 			const _Ty& _Val)
; 2654 : 	{	// find range equivalent to _Val, using operator<
; 2655 : 	return (_STD equal_range(_First, _Last, _Val, less<>()));
; 2656 : 	}
; 2657 : 
; 2658 : 		// TEMPLATE FUNCTION binary_search WITH PRED
; 2659 : template<class _FwdIt,
; 2660 : 	class _Ty,
; 2661 : 	class _Pr> inline
; 2662 : 	bool binary_search(_FwdIt _First, _FwdIt _Last,
; 2663 : 		const _Ty& _Val, _Pr _Pred)
; 2664 : 	{	// test if _Val equivalent to some element, using _Pred
; 2665 : 	_First = _STD lower_bound(_First, _Last, _Val, _Pred);
; 2666 : 	return (_First != _Last && !_Pred(_Val, *_First));
; 2667 : 	}
; 2668 : 
; 2669 : 		// TEMPLATE FUNCTION binary_search
; 2670 : template<class _FwdIt,
; 2671 : 	class _Ty> inline
; 2672 : 	bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2673 : 	{	// test if _Val equivalent to some element, using operator<
; 2674 : 	return (_STD binary_search(_First, _Last, _Val, less<>()));
; 2675 : 	}
; 2676 : 
; 2677 : 		// TEMPLATE FUNCTION merge WITH PRED
; 2678 : template<class _InIt1,
; 2679 : 	class _InIt2,
; 2680 : 	class _OutIt,
; 2681 : 	class _Pr> inline
; 2682 : 	_OutIt _Merge0(_InIt1 _First1, _InIt1 _Last1,
; 2683 : 		_InIt2 _First2, _InIt2 _Last2,
; 2684 : 		_OutIt _Dest, _Pr _Pred)
; 2685 : 	{	// copy merging ranges, both using _Pred
; 2686 : 	if (_First1 != _Last1 && _First2 != _Last2)
; 2687 : 		for (; ; )
; 2688 : 			{	// merge either first or second
; 2689 : 			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 2690 : 				{	// merge first
; 2691 : 				*_Dest++ = *_First2++;
; 2692 : 				if (_First2 == _Last2)
; 2693 : 					break;
; 2694 : 				}
; 2695 : 			else
; 2696 : 				{	// merge second
; 2697 : 				*_Dest++ = *_First1++;
; 2698 : 				if (_First1 == _Last1)
; 2699 : 					break;
; 2700 : 				}
; 2701 : 			}
; 2702 : 
; 2703 : 	_Dest = _Copy_impl(_First1, _Last1, _Dest);	// copy any tail
; 2704 : 	return (_Copy_impl(_First2, _Last2, _Dest));
; 2705 : 	}
; 2706 : 
; 2707 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2708 : template<class _InIt1,
; 2709 : 	class _InIt2,
; 2710 : 	class _OutIt,
; 2711 : 	class _Pr> inline
; 2712 : 	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
; 2713 : 		_InIt2 _First2, _InIt2 _Last2,
; 2714 : 		_OutIt _Dest, _Pr _Pred)
; 2715 : 	{	// copy merging ranges, both using _Pred
; 2716 : 	return (_Merge0(_Unchecked(_First1), _Unchecked(_Last1),
; 2717 : 		_Unchecked(_First2), _Unchecked(_Last2),
; 2718 : 		_Dest, _Pred));
; 2719 : 	}
; 2720 : 
; 2721 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2722 : template<class _InIt1,
; 2723 : 	class _InIt2,
; 2724 : 	class _OutIt,
; 2725 : 	class _Pr> inline
; 2726 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2727 : 		_InIt2 _First2, _InIt2 _Last2,
; 2728 : 		_OutIt _Dest, _Pr _Pred, input_iterator_tag,
; 2729 : 		input_iterator_tag, _Mutable_iterator_tag)
; 2730 : 	{	// copy merging ranges, both using _Pred, arbitrary iterators
; 2731 : 	return (_Merge0(_First1, _Last1,
; 2732 : 		_First2, _Last2,
; 2733 : 		_Dest, _Pred));
; 2734 : 	}
; 2735 : 
; 2736 : template<class _InIt1,
; 2737 : 	class _InIt2,
; 2738 : 	class _OutIt,
; 2739 : 	class _Pr> inline
; 2740 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2741 : 		_InIt2 _First2, _InIt2 _Last2,
; 2742 : 		_OutIt _Dest, _Pr _Pred, random_access_iterator_tag,
; 2743 : 		random_access_iterator_tag, random_access_iterator_tag)
; 2744 : 	{	// copy merging ranges, both using _Pred, random-access iterators
; 2745 : 	_OutIt _Ans = _Dest + (_Last1 - _First1)
; 2746 : 		+ (_Last2 - _First2);	// also checks range
; 2747 : 	_Merge0(_First1, _Last1,
; 2748 : 		_First2, _Last2,
; 2749 : 		_Dest, _Pred);
; 2750 : 	return (_Ans);
; 2751 : 	}
; 2752 : 
; 2753 : template<class _InIt1,
; 2754 : 	class _InIt2,
; 2755 : 	class _OutIt,
; 2756 : 	class _Pr> inline
; 2757 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2758 : 		_InIt2 _First2, _InIt2 _Last2,
; 2759 : 		_OutIt _Dest, _Pr _Pred, true_type)
; 2760 : 	{	// copy merging ranges, both using _Pred, checked dest
; 2761 : 	return (_Merge2(_First1, _Last1,
; 2762 : 		_First2, _Last2,
; 2763 : 		_Dest, _Pred, _Iter_cat(_First1),
; 2764 : 		_Iter_cat(_First2), _Iter_cat(_Dest)));
; 2765 : 	}
; 2766 : 
; 2767 : template<class _InIt1,
; 2768 : 	class _InIt2,
; 2769 : 	class _OutIt,
; 2770 : 	class _Pr> inline
; 2771 : _SCL_INSECURE_DEPRECATE
; 2772 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2773 : 		_InIt2 _First2, _InIt2 _Last2,
; 2774 : 		_OutIt _Dest, _Pr _Pred, false_type)
; 2775 : 	{	// copy merging ranges, both using _Pred, unchecked dest
; 2776 : 	return (_Merge2(_First1, _Last1,
; 2777 : 		_First2, _Last2,
; 2778 : 		_Dest, _Pred, _Iter_cat(_First1),
; 2779 : 		_Iter_cat(_First2), _Iter_cat(_Dest)));
; 2780 : 	}
; 2781 : 
; 2782 : template<class _InIt1,
; 2783 : 	class _InIt2,
; 2784 : 	class _OutIt,
; 2785 : 	class _Pr> inline
; 2786 : 	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
; 2787 : 		_InIt2 _First2, _InIt2 _Last2,
; 2788 : 		_OutIt _Dest, _Pr _Pred)
; 2789 : 	{	// copy merging ranges, both using _Pred
; 2790 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2791 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2792 : 	_DEBUG_POINTER(_Dest);
; 2793 : 	_DEBUG_POINTER(_Pred);
; 2794 : 	return (_Merge2(_Unchecked(_First1), _Unchecked(_Last1),
; 2795 : 		_Unchecked(_First2), _Unchecked(_Last2),
; 2796 : 		_Dest, _Pred, _Is_checked(_Dest)));
; 2797 : 	}
; 2798 : 
; 2799 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2800 : template<class _InIt1,
; 2801 : 	class _InIt2,
; 2802 : 	class _OutTy,
; 2803 : 	size_t _OutSize,
; 2804 : 	class _Pr> inline
; 2805 : 	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
; 2806 : 		_InIt2 _First2, _InIt2 _Last2,
; 2807 : 		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
; 2808 : 	{	// copy merging ranges, both using _Pred, array dest
; 2809 : 	return (_Unchecked(
; 2810 : 		_STD merge(_First1, _Last1,
; 2811 : 			_First2, _Last2,
; 2812 : 			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
; 2813 : 	}
; 2814 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2815 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2816 : 
; 2817 : 		// TEMPLATE FUNCTION merge
; 2818 : template<class _InIt1,
; 2819 : 	class _InIt2,
; 2820 : 	class _OutIt> inline
; 2821 : 	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
; 2822 : 		_InIt2 _First2, _InIt2 _Last2,
; 2823 : 		_OutIt _Dest)
; 2824 : 	{	// copy merging ranges, both using operator<
; 2825 : 	return (_STD merge(_First1, _Last1, _First2, _Last2, _Dest,
; 2826 : 		less<>()));
; 2827 : 	}
; 2828 : 
; 2829 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2830 : template<class _InIt1,
; 2831 : 	class _InIt2,
; 2832 : 	class _OutTy,
; 2833 : 	size_t _OutSize> inline
; 2834 : 	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
; 2835 : 		_InIt2 _First2, _InIt2 _Last2,
; 2836 : 		_OutTy (&_Dest)[_OutSize])
; 2837 : 	{	// copy merging ranges, both using operator<, array dest
; 2838 : 	return (_STD merge(_First1, _Last1, _First2, _Last2, _Dest,
; 2839 : 		less<>()));
; 2840 : 	}
; 2841 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2842 : 
; 2843 : 		// TEMPLATE FUNCTION inplace_merge WITH PRED
; 2844 : template<class _BidIt1,
; 2845 : 	class _BidIt2,
; 2846 : 	class _BidIt3,
; 2847 : 	class _Pr> inline
; 2848 : 	_BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
; 2849 : 		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
; 2850 : 	{	// merge backwards to _Dest, using _Pred
; 2851 : 	if (_First1 != _Last1 && _First2 != _Last2)
; 2852 : 		for (; ; )
; 2853 : 			{	// merge either first or second
; 2854 : 			if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))
; 2855 : 				{	// merge first
; 2856 : 				*--_Dest = _Move(*_Last1);
; 2857 : 				++_Last2;
; 2858 : 				if (_First1 == _Last1)
; 2859 : 					break;
; 2860 : 				}
; 2861 : 			else
; 2862 : 				{	// merge second
; 2863 : 				*--_Dest = _Move(*_Last2);
; 2864 : 				++_Last1;
; 2865 : 				if (_First2 == _Last2)
; 2866 : 					break;
; 2867 : 				}
; 2868 : 			}
; 2869 : 
; 2870 : 	_Dest = _Move_backward(_First2, _Last2, _Dest);	// move any tail
; 2871 : 	return (_Move_backward(_First1, _Last1, _Dest));
; 2872 : 	}
; 2873 : 
; 2874 : template<class _InIt1,
; 2875 : 	class _InIt2,
; 2876 : 	class _OutIt,
; 2877 : 	class _Pr> inline
; 2878 : 	_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
; 2879 : 		_InIt2 _First2, _InIt2 _Last2,
; 2880 : 		_OutIt _Dest, _Pr _Pred)
; 2881 : 	{	// move merging ranges, both using _Pred
; 2882 : 	if (_First1 != _Last1 && _First2 != _Last2)
; 2883 : 		for (; ; )
; 2884 : 			{	// merge either first or second
; 2885 : 			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 2886 : 				{	// merge first
; 2887 : 				*_Dest++ = _Move(*_First2++);
; 2888 : 				if (_First2 == _Last2)
; 2889 : 					break;
; 2890 : 				}
; 2891 : 			else
; 2892 : 				{	// merge second
; 2893 : 				*_Dest++ = _Move(*_First1++);
; 2894 : 				if (_First1 == _Last1)
; 2895 : 					break;
; 2896 : 				}
; 2897 : 			}
; 2898 : 
; 2899 : 	_Dest = _Move(_First1, _Last1, _Dest);	// move any tail
; 2900 : 	return (_Move(_First2, _Last2, _Dest));
; 2901 : 	}
; 2902 : 
; 2903 : template<class _BidIt,
; 2904 : 	class _Diff,
; 2905 : 	class _Ty,
; 2906 : 	class _Pr> inline
; 2907 : 	void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
; 2908 : 		_Diff _Count1, _Diff _Count2,
; 2909 : 			_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
; 2910 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
; 2911 : 	if (_Count1 == 0 || _Count2 == 0)
; 2912 : 		;	// do nothing
; 2913 : 	else if (_Count1 + _Count2 == 2)
; 2914 : 		{	// order two one-element partitions
; 2915 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))
; 2916 : 			_STD iter_swap(_First, _Mid);
; 2917 : 		}
; 2918 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
; 2919 : 		{	// buffer left partition, then merge
; 2920 : 		_Move(_First, _Mid, _Tempbuf._Init());
; 2921 : 		_Merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2922 : 			_Mid, _Last, _First, _Pred);
; 2923 : 		}
; 2924 : 	else if (_Count2 <= _Tempbuf._Maxlen())
; 2925 : 		{	// buffer right partition, then merge
; 2926 : 		_Move(_Mid, _Last, _Tempbuf._Init());
; 2927 : 		_Merge_backward(_First, _Mid,
; 2928 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last, _Pred);
; 2929 : 		}
; 2930 : 	else
; 2931 : 		{	// buffer too small, divide and conquer
; 2932 : 		_BidIt _Firstn, _Lastn;
; 2933 : 		_Diff _Count1n, _Count2n;
; 2934 : 		if (_Count2 < _Count1)
; 2935 : 			{	// left larger, cut it in half and partition right to match
; 2936 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2937 : 			_Firstn = _First;
; 2938 : 			_STD advance(_Firstn, _Count1n);
; 2939 : 			_Lastn = _STD lower_bound(_Mid, _Last, *_Firstn, _Pred);
; 2940 : 			_Distance(_Mid, _Lastn, _Count2n);
; 2941 : 			}
; 2942 : 		else
; 2943 : 			{	// right larger, cut it in half and partition left to match
; 2944 : 			_Count1n = 0, _Count2n = _Count2 / 2;
; 2945 : 			_Lastn = _Mid;
; 2946 : 			_STD advance(_Lastn, _Count2n);
; 2947 : 			_Firstn = _STD upper_bound(_First, _Mid, *_Lastn, _Pred);
; 2948 : 			_Distance(_First, _Firstn, _Count1n);
; 2949 : 			}
; 2950 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2951 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle
; 2952 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2953 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part
; 2954 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2955 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);
; 2956 : 		}
; 2957 : 	}
; 2958 : 
; 2959 : template<class _BidIt,
; 2960 : 	class _Diff,
; 2961 : 	class _Ty,
; 2962 : 	class _Pr> inline
; 2963 : 	void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred,
; 2964 : 		_Diff *, _Ty *)
; 2965 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
; 2966 : 	_Diff _Count1 = 0;
; 2967 : 	_Distance(_First, _Mid, _Count1);
; 2968 : 	_Diff _Count2 = 0;
; 2969 : 	_Distance(_Mid, _Last, _Count2);
; 2970 : 	_Temp_iterator<_Ty> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
; 2971 : 	_Buffered_merge(_First, _Mid, _Last,
; 2972 : 		_Count1, _Count2, _Tempbuf, _Pred);
; 2973 : 	}
; 2974 : 
; 2975 : template<class _BidIt,
; 2976 : 	class _Pr> inline
; 2977 : 	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
; 2978 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
; 2979 : 	_DEBUG_ORDER_PRED(_First, _Mid, _Pred);
; 2980 : 	_DEBUG_ORDER_PRED(_Mid, _Last, _Pred);
; 2981 : 	if (_First != _Mid && _Mid != _Last)
; 2982 : 		_Inplace_merge(
; 2983 : 			_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred,
; 2984 : 			_Dist_type(_First), _Val_type(_First));
; 2985 : 	}
; 2986 : 
; 2987 : 		// TEMPLATE FUNCTION inplace_merge
; 2988 : template<class _BidIt> inline
; 2989 : 	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
; 2990 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<
; 2991 : 	_STD inplace_merge(_First, _Mid, _Last, less<>());
; 2992 : 	}
; 2993 : 
; 2994 : 		// TEMPLATE FUNCTION sort WITH PRED
; 2995 : template<class _BidIt,
; 2996 : 	class _Pr,
; 2997 : 	class _Ty> inline
; 2998 : 	void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Pr _Pred, _Ty *)
; 2999 : 	{	// insertion sort [_First, _Last), using _Pred
; 3000 : 	if (_First != _Last)
; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )
; 3002 : 			{	// order next element
; 3003 : 			_BidIt _Next1 = _Next;
; 3004 : 			_Ty _Val = _Move(*_Next);
; 3005 : 
; 3006 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))
; 3007 : 				{	// found new earliest element, move to front
; 3008 : 				_Move_backward(_First, _Next, ++_Next1);
; 3009 : 				*_First = _Move(_Val);
; 3010 : 				}
; 3011 : 			else
; 3012 : 				{	// look for insertion point after first
; 3013 : 				for (_BidIt _First1 = _Next1;
; 3014 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3015 : 					_Next1 = _First1)
; 3016 : 					*_Next1 = _Move(*_First1);	// move hole down
; 3017 : 				*_Next1 = _Move(_Val);	// insert element in hole
; 3018 : 				}
; 3019 : 			}
; 3020 : 	}
; 3021 : 
; 3022 : template<class _BidIt,
; 3023 : 	class _Pr> inline
; 3024 : 	void _Insertion_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
; 3025 : 	{	// insertion sort [_First, _Last), using _Pred
; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  000ba	f3 0f 7e 45 14	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  000bf	8b 45 1c	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  000c2	6a 00		 push	 0
  000c4	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000c7	8b cc		 mov	 ecx, esp
  000c9	56		 push	 esi
  000ca	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  000ce	57		 push	 edi
  000cf	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  000d2	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@PAV1@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@0@Z ; std::_Insertion_sort1<CGraphicObjectInstance * *,FPCBlockerDistanceSort,CGraphicObjectInstance *>
  000d7	83 c4 18	 add	 esp, 24			; 00000018H
$LN27@Sort:

; 3148 : 		_Insertion_sort(_First, _Last, _Pred);	// small
; 3149 : 	}

  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5b		 pop	 ebx
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
$LN6@Sort:

; 3139 : 			}
; 3140 : 		}
; 3141 : 
; 3142 : 	if (_ISORT_MAX < _Count)

  000e1	83 f8 20	 cmp	 eax, 32			; 00000020H
  000e4	7e cf		 jle	 SHORT $LN3@Sort

; 2459 : 	if (1 < _Last - _First)

  000e6	8b c6		 mov	 eax, esi
  000e8	2b c7		 sub	 eax, edi
  000ea	83 e0 fc	 and	 eax, -4			; fffffffcH
  000ed	83 f8 04	 cmp	 eax, 4
  000f0	7e 22		 jle	 SHORT $LN10@Sort

; 2460 : 		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2461 : 			_Dist_type(_First), _Val_type(_First));

  000f2	f3 0f 7e 45 14	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  000f7	8b 45 1c	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  000fa	6a 00		 push	 0
  000fc	6a 00		 push	 0
  000fe	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00101	8b cc		 mov	 ecx, esp
  00103	56		 push	 esi
  00104	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00108	57		 push	 edi
  00109	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0010c	e8 00 00 00 00	 call	 ??$_Make_heap@PAPAVCGraphicObjectInstance@@HPAV1@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@PAH0@Z ; std::_Make_heap<CGraphicObjectInstance * *,int,CGraphicObjectInstance *,FPCBlockerDistanceSort>
  00111	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN10@Sort:

; 2462 : 	}
; 2463 : 
; 2464 : 		// TEMPLATE FUNCTION make_heap
; 2465 : template<class _RanIt> inline
; 2466 : 	void make_heap(_RanIt _First, _RanIt _Last)
; 2467 : 	{	// make [_First, _Last) into a heap, using operator<
; 2468 : 	_STD make_heap(_First, _Last, less<>());
; 2469 : 	}
; 2470 : 
; 2471 : 		// TEMPLATE FUNCTION sort_heap WITH PRED
; 2472 : template<class _RanIt,
; 2473 : 	class _Pr> inline
; 2474 : 	void _Sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
; 2475 : 	{	// order heap by repeatedly popping, using _Pred
; 2476 : 	for (; 1 < _Last - _First; --_Last)
; 2477 : 		_Pop_heap(_First, _Last, _Pred);
; 2478 : 	}
; 2479 : 
; 2480 : template<class _RanIt,
; 2481 : 	class _Pr> inline
; 2482 : 	void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
; 2483 : 	{	// order heap by repeatedly popping, using _Pred
; 2484 : 	_DEBUG_RANGE(_First, _Last);
; 2485 : 	_DEBUG_POINTER(_Pred);
; 2486 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2487 : 	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);

  00114	f3 0f 7e 45 14	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  00119	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0011c	8b 45 1c	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  0011f	8b cc		 mov	 ecx, esp
  00121	56		 push	 esi
  00122	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00126	57		 push	 edi
  00127	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0012a	e8 00 00 00 00	 call	 ??$_Sort_heap@PAPAVCGraphicObjectInstance@@UFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0UFPCBlockerDistanceSort@@@Z ; std::_Sort_heap<CGraphicObjectInstance * *,FPCBlockerDistanceSort>
  0012f	83 c4 14	 add	 esp, 20			; 00000014H

; 3148 : 		_Insertion_sort(_First, _Last, _Pred);	// small
; 3149 : 	}

  00132	5f		 pop	 edi
  00133	5e		 pop	 esi
  00134	5b		 pop	 ebx
  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
??$_Sort@PAPAVCGraphicObjectInstance@@HUFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0HUFPCBlockerDistanceSort@@@Z ENDP ; std::_Sort<CGraphicObjectInstance * *,int,FPCBlockerDistanceSort>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ??_G?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEPAXI@Z PROC ; RangeTester<FGetShadowReceiverFromHeightData>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 56   : 	virtual ~SpherePackCallback() {}

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7SpherePackCallback@@6B@
  00010	74 09		 je	 SHORT $LN8@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN8@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEPAXI@Z ENDP ; RangeTester<FGetShadowReceiverFromHeightData>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?PointTest2dCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?PointTest2dCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<FGetShadowReceiverFromHeightData>::PointTest2dCallback, COMDAT
; _this$ = ecx

; 50   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)

  00003	83 7d 10 02	 cmp	 DWORD PTR _state$[ebp], 2
  00007	74 0e		 je	 SHORT $LN1@PointTest2

; 56   : 		{
; 57   : #ifdef SPHERELIB_STRICT
; 58   : 			puts("FIND!!");
; 59   : #endif
; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00009	8b 45 0c	 mov	 eax, DWORD PTR _sphere$[ebp]
  0000c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000f	ff 70 44	 push	 DWORD PTR [eax+68]
  00012	e8 00 00 00 00	 call	 ??RFGetShadowReceiverFromHeightData@@QAEXPAVCGraphicObjectInstance@@@Z ; FGetShadowReceiverFromHeightData::operator()
$LN1@PointTest2:

; 61   : 		}
; 62   : 	}

  00017	5d		 pop	 ebp
  00018	c2 0c 00	 ret	 12			; 0000000cH
?PointTest2dCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<FGetShadowReceiverFromHeightData>::PointTest2dCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?RangeTestCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_distance$ = 12						; size = 4
_sphere$ = 16						; size = 4
_state$ = 20						; size = 4
?RangeTestCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<FGetShadowReceiverFromHeightData>::RangeTestCallback, COMDAT
; _this$ = ecx

; 40   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)

  00003	83 7d 14 02	 cmp	 DWORD PTR _state$[ebp], 2
  00007	74 0e		 je	 SHORT $LN1@RangeTestC

; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00009	8b 45 10	 mov	 eax, DWORD PTR _sphere$[ebp]
  0000c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000f	ff 70 44	 push	 DWORD PTR [eax+68]
  00012	e8 00 00 00 00	 call	 ??RFGetShadowReceiverFromHeightData@@QAEXPAVCGraphicObjectInstance@@@Z ; FGetShadowReceiverFromHeightData::operator()
$LN1@RangeTestC:

; 47   : 	}

  00017	5d		 pop	 ebp
  00018	c2 10 00	 ret	 16			; 00000010H
?RangeTestCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<FGetShadowReceiverFromHeightData>::RangeTestCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?VisibilityCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?VisibilityCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<FGetShadowReceiverFromHeightData>::VisibilityCallback, COMDAT
; _this$ = ecx

; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};

  00000	c2 0c 00	 ret	 12			; 0000000cH
?VisibilityCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<FGetShadowReceiverFromHeightData>::VisibilityCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?RayTraceCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_distance$ = 16						; size = 4
_sect$ = 20						; size = 4
_sphere$ = 24						; size = 4
?RayTraceCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z PROC ; RangeTester<FGetShadowReceiverFromHeightData>::RayTraceCallback, COMDAT
; _this$ = ecx

; 27   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)

  00003	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  00008	0f 57 c0	 xorps	 xmm0, xmm0
  0000b	0f 2f c1	 comiss	 xmm0, xmm1
  0000e	73 06		 jae	 SHORT $LN1@RayTraceCa
  00010	0f 2f 4d 10	 comiss	 xmm1, DWORD PTR _distance$[ebp]
  00014	72 0e		 jb	 SHORT $LN2@RayTraceCa
$LN1@RayTraceCa:

; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00016	8b 45 18	 mov	 eax, DWORD PTR _sphere$[ebp]
  00019	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001c	ff 70 44	 push	 DWORD PTR [eax+68]
  0001f	e8 00 00 00 00	 call	 ??RFGetShadowReceiverFromHeightData@@QAEXPAVCGraphicObjectInstance@@@Z ; FGetShadowReceiverFromHeightData::operator()
$LN2@RayTraceCa:

; 34   : 	};

  00024	5d		 pop	 ebp
  00025	c2 14 00	 ret	 20			; 00000014H
?RayTraceCallback@?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ENDP ; RangeTester<FGetShadowReceiverFromHeightData>::RayTraceCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ??1?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAE@XZ
_TEXT	SEGMENT
??1?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAE@XZ PROC ; RangeTester<FGetShadowReceiverFromHeightData>::~RangeTester<FGetShadowReceiverFromHeightData>, COMDAT
; _this$ = ecx
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SpherePackCallback@@6B@
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 19   : 	{}

  00006	c3		 ret	 0
??1?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAE@XZ ENDP ; RangeTester<FGetShadowReceiverFromHeightData>::~RangeTester<FGetShadowReceiverFromHeightData>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ??0?$RangeTester@UFGetShadowReceiverFromHeightData@@@@QAE@PAUFGetShadowReceiverFromHeightData@@M@Z
_TEXT	SEGMENT
_fn$ = 8						; size = 4
_distance$ = 12						; size = 4
??0?$RangeTester@UFGetShadowReceiverFromHeightData@@@@QAE@PAUFGetShadowReceiverFromHeightData@@M@Z PROC ; RangeTester<FGetShadowReceiverFromHeightData>::RangeTester<FGetShadowReceiverFromHeightData>, COMDAT
; _this$ = ecx

; 16   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _fn$[ebp]
  00006	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _distance$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000e	8b c1		 mov	 eax, ecx
  00010	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$RangeTester@UFGetShadowReceiverFromHeightData@@@@6B@
  00016	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??0?$RangeTester@UFGetShadowReceiverFromHeightData@@@@QAE@PAUFGetShadowReceiverFromHeightData@@M@Z ENDP ; RangeTester<FGetShadowReceiverFromHeightData>::RangeTester<FGetShadowReceiverFromHeightData>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVCTerrain@@@std@@YAPAPAVCTerrain@@IPAPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCTerrain@@@std@@YAPAPAVCTerrain@@IPAPAV1@@Z PROC ; std::_Allocate<CTerrain *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@PAVCTerrain@@@std@@YAPAPAVCTerrain@@IPAPAV1@@Z ENDP ; std::_Allocate<CTerrain *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVCArea@@@std@@YAPAPAVCArea@@IPAPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCArea@@@std@@YAPAPAVCArea@@IPAPAV1@@Z PROC ; std::_Allocate<CArea *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@PAVCArea@@@std@@YAPAPAVCArea@@IPAPAV1@@Z ENDP ; std::_Allocate<CArea *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVCGraphicObjectInstance@@@std@@YAPAPAVCGraphicObjectInstance@@IPAPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCGraphicObjectInstance@@@std@@YAPAPAVCGraphicObjectInstance@@IPAPAV1@@Z PROC ; std::_Allocate<CGraphicObjectInstance *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@PAVCGraphicObjectInstance@@@std@@YAPAPAVCGraphicObjectInstance@@IPAPAV1@@Z ENDP ; std::_Allocate<CGraphicObjectInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEPAPAVCTerrain@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEPAPAVCTerrain@@PAPAV2@00@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Umove<CTerrain * *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File a:\vs\vc\include\vector

; 1649 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEPAPAVCTerrain@@PAPAV2@00@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Umove<CTerrain * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEPAPAVCArea@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEPAPAVCArea@@PAPAV2@00@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Umove<CArea * *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File a:\vs\vc\include\vector

; 1649 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEPAPAVCArea@@PAPAV2@00@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Umove<CArea * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCGraphicObjectInstance@@@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEPAPAVCGraphicObjectInstance@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCGraphicObjectInstance@@@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEPAPAVCGraphicObjectInstance@@PAPAV2@00@Z PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Umove<CGraphicObjectInstance * *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File a:\vs\vc\include\vector

; 1649 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVCGraphicObjectInstance@@@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEPAPAVCGraphicObjectInstance@@PAPAV2@00@Z ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Umove<CGraphicObjectInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCRotationDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCRotationDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCRotationDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCGravityDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCGravityDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCGravityDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCNullDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCNullDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCNullDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCHeaderDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCHeaderDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCHeaderDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAXPAPAVCTerrain@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAXPAPAVCTerrain@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTerrain *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAXPAPAVCTerrain@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTerrain *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAXPAPAVCArea@@0AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAXPAPAVCArea@@0AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CArea *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAXPAPAVCArea@@0AAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CArea *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z PROC ; std::_Move<CTerrain * *,CTerrain * *>, COMDAT

; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

  0000c	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	57		 push	 edi
  00013	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2432 : 	return (_Dest + _Count);

  00025	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2442 : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Move@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z ENDP ; std::_Move<CTerrain * *,CTerrain * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCTerrain@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXPAPAVCTerrain@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCTerrain@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXPAPAVCTerrain@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CTerrain *> >::construct<CTerrain *,CTerrain * const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCTerrain@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXPAPAVCTerrain@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CTerrain *> >::construct<CTerrain *,CTerrain * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCTerrain@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXPAPAVCTerrain@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCTerrain@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXPAPAVCTerrain@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CTerrain *> >::construct<CTerrain *,CTerrain * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCTerrain@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXPAPAVCTerrain@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CTerrain *> >::construct<CTerrain *,CTerrain * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@QAVCTerrain@@@std@@YAPBQAVCTerrain@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVCTerrain@@@std@@YAPBQAVCTerrain@@ABQAV1@@Z PROC ; std::addressof<CTerrain * const>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@QAVCTerrain@@@std@@YAPBQAVCTerrain@@ABQAV1@@Z ENDP ; std::addressof<CTerrain * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAPAVCTerrain@@IU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAXPAPAVCTerrain@@IAAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAPAVCTerrain@@IU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAXPAPAVCTerrain@@IAAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<CTerrain * *,unsigned int,std::_Wrap_alloc<std::allocator<CTerrain *> > >, COMDAT

; 690  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 09		 je	 SHORT $LN11@Uninitiali
  0000a	57		 push	 edi
; File a:\vs\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

  0000b	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000e	33 c0		 xor	 eax, eax
  00010	f3 ab		 rep stosd
  00012	5f		 pop	 edi
$LN11@Uninitiali:

; 691  : 	_Uninit_def_fill_n(_First, _Count, _Al,
; 692  : 		_Val_type(_First), _Ptr_cat(_First, _First));
; 693  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Uninitialized_default_fill_n@PAPAVCTerrain@@IU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@YAXPAPAVCTerrain@@IAAU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<CTerrain * *,unsigned int,std::_Wrap_alloc<std::allocator<CTerrain *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z PROC ; std::_Move<CArea * *,CArea * *>, COMDAT

; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

  0000c	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	57		 push	 edi
  00013	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2432 : 	return (_Dest + _Count);

  00025	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2442 : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Move@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z ENDP ; std::_Move<CArea * *,CArea * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCArea@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEXPAPAVCArea@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCArea@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEXPAPAVCArea@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CArea *> >::construct<CArea *,CArea * const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCArea@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEXPAPAVCArea@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CArea *> >::construct<CArea *,CArea * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCArea@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEXPAPAVCArea@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCArea@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEXPAPAVCArea@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CArea *> >::construct<CArea *,CArea * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCArea@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEXPAPAVCArea@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CArea *> >::construct<CArea *,CArea * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@QAVCArea@@@std@@YAPBQAVCArea@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVCArea@@@std@@YAPBQAVCArea@@ABQAV1@@Z PROC ; std::addressof<CArea * const>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@QAVCArea@@@std@@YAPBQAVCArea@@ABQAV1@@Z ENDP ; std::addressof<CArea * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAPAVCArea@@IU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAXPAPAVCArea@@IAAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAPAVCArea@@IU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAXPAPAVCArea@@IAAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<CArea * *,unsigned int,std::_Wrap_alloc<std::allocator<CArea *> > >, COMDAT

; 690  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 09		 je	 SHORT $LN11@Uninitiali
  0000a	57		 push	 edi
; File a:\vs\vc\include\xmemory

; 682  : 	_Fill_n(_First, _Count, (_Valty)0);

  0000b	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000e	33 c0		 xor	 eax, eax
  00010	f3 ab		 rep stosd
  00012	5f		 pop	 edi
$LN11@Uninitiali:

; 691  : 	_Uninit_def_fill_n(_First, _Count, _Al,
; 692  : 		_Val_type(_First), _Ptr_cat(_First, _First));
; 693  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Uninitialized_default_fill_n@PAPAVCArea@@IU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@@std@@YAXPAPAVCArea@@IAAU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<CArea * *,unsigned int,std::_Wrap_alloc<std::allocator<CArea *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicObjectInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXPAPAVCGraphicObjectInstance@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCGraphicObjectInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXPAPAVCGraphicObjectInstance@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::construct<CGraphicObjectInstance *,CGraphicObjectInstance * const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCGraphicObjectInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXPAPAVCGraphicObjectInstance@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::construct<CGraphicObjectInstance *,CGraphicObjectInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicObjectInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXPAPAVCGraphicObjectInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCGraphicObjectInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXPAPAVCGraphicObjectInstance@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::construct<CGraphicObjectInstance *,CGraphicObjectInstance * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCGraphicObjectInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXPAPAVCGraphicObjectInstance@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::construct<CGraphicObjectInstance *,CGraphicObjectInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@QAVCGraphicObjectInstance@@@std@@YAPBQAVCGraphicObjectInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVCGraphicObjectInstance@@@std@@YAPBQAVCGraphicObjectInstance@@ABQAV1@@Z PROC ; std::addressof<CGraphicObjectInstance * const>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@QAVCGraphicObjectInstance@@@std@@YAPBQAVCGraphicObjectInstance@@ABQAV1@@Z ENDP ; std::addressof<CGraphicObjectInstance * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
;	COMDAT ??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@V10@00@Z PROC ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > > >, COMDAT

; 2074 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2054 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00009	2b c8		 sub	 ecx, eax
  0000b	56		 push	 esi
  0000c	c1 f9 02	 sar	 ecx, 2
  0000f	57		 push	 edi
; File a:\vs\vc\include\vector

; 396  : 	return (_Iter._Unchecked());

  00010	8b 7d 14	 mov	 edi, DWORD PTR __Dest$[ebp]
; File a:\vs\vc\include\xutility

; 2056 : 		_Count * sizeof (*_First));

  00013	8d 34 8d 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*4]
  0001a	56		 push	 esi
  0001b	50		 push	 eax
  0001c	57		 push	 edi
  0001d	e8 00 00 00 00	 call	 _memmove

; 2075 : 	return (_Rechecked(_Dest,
; 2076 : 		_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
; 2077 : 			_Unchecked(_Dest))));

  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2057 : 	return (_Dest + _Count);

  00025	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2075 : 	return (_Rechecked(_Dest,
; 2076 : 		_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
; 2077 : 			_Unchecked(_Dest))));

  0002b	89 08		 mov	 DWORD PTR [eax], ecx
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi

; 2078 : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@V10@00@Z ENDP ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
;	COMDAT ??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@V10@00@Z PROC ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > > >, COMDAT

; 2074 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2054 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00009	2b c8		 sub	 ecx, eax
  0000b	56		 push	 esi
  0000c	c1 f9 02	 sar	 ecx, 2
  0000f	57		 push	 edi
; File a:\vs\vc\include\vector

; 396  : 	return (_Iter._Unchecked());

  00010	8b 7d 14	 mov	 edi, DWORD PTR __Dest$[ebp]
; File a:\vs\vc\include\xutility

; 2056 : 		_Count * sizeof (*_First));

  00013	8d 34 8d 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*4]
  0001a	56		 push	 esi
  0001b	50		 push	 eax
  0001c	57		 push	 edi
  0001d	e8 00 00 00 00	 call	 _memmove

; 2075 : 	return (_Rechecked(_Dest,
; 2076 : 		_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
; 2077 : 			_Unchecked(_Dest))));

  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2057 : 	return (_Dest + _Count);

  00025	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2075 : 	return (_Rechecked(_Dest,
; 2076 : 		_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
; 2077 : 			_Unchecked(_Dest))));

  0002b	89 08		 mov	 DWORD PTR [eax], ecx
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi

; 2078 : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@V10@00@Z ENDP ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushAreaToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0U12@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 24
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushAreaToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0U12@@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,CMapOutdoor::FPushAreaToDeleteVector>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushAreaToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0U12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0002d	8b 75 0c	 mov	 esi, DWORD PTR __First$[ebp]
  00030	33 c9		 xor	 ecx, ecx
  00032	8b 5d 10	 mov	 ebx, DWORD PTR __Last$[ebp]
  00035	33 ff		 xor	 edi, edi
  00037	2b de		 sub	 ebx, esi
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	83 c3 03	 add	 ebx, 3
  00043	c1 eb 02	 shr	 ebx, 2
  00046	3b 75 10	 cmp	 esi, DWORD PTR __Last$[ebp]
  00049	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0004c	85 db		 test	 ebx, ebx
  0004e	74 12		 je	 SHORT $LN14@for_each
$LL16@for_each:

; 24   : 		_Func(*_First);

  00050	ff 36		 push	 DWORD PTR [esi]
  00052	8d 4d 14	 lea	 ecx, DWORD PTR __Func$[ebp]
  00055	e8 00 00 00 00	 call	 ??RFPushAreaToDeleteVector@CMapOutdoor@@QAEXPAVCArea@@@Z ; CMapOutdoor::FPushAreaToDeleteVector::operator()
  0005a	47		 inc	 edi
  0005b	8d 76 04	 lea	 esi, DWORD PTR [esi+4]

; 23   : 	for (; _First != _Last; ++_First)

  0005e	3b fb		 cmp	 edi, ebx
  00060	75 ee		 jne	 SHORT $LL16@for_each
$LN14@for_each:
  00062	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00065	f3 0f 7e 45 14	 movq	 xmm0, QWORD PTR __Func$[ebp]
  0006a	8b 45 1c	 mov	 eax, DWORD PTR __Func$[ebp+8]
  0006d	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00071	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00074	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00077	8d 45 20	 lea	 eax, DWORD PTR __Func$[ebp+12]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ??0?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CArea *,std::allocator<CArea *> >::vector<CArea *,std::allocator<CArea *> >
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00080	8b 45 20	 mov	 eax, DWORD PTR __Func$[ebp+12]
  00083	85 c0		 test	 eax, eax
  00085	74 09		 je	 SHORT $LN43@for_each
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008d	83 c4 04	 add	 esp, 4
$LN43@for_each:
; File a:\vs\vc\include\algorithm

; 35   : 	return (_STD move(_Func));

  00090	8b c6		 mov	 eax, esi

; 36   : 	}

  00092	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00095	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009c	59		 pop	 ecx
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushAreaToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0U12@@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Func$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1FPushAreaToDeleteVector@CMapOutdoor@@QAE@XZ
__ehhandler$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushAreaToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0U12@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushAreaToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0U12@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushAreaToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0U12@@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,CMapOutdoor::FPushAreaToDeleteVector>
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushTerrainToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0U12@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 24
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushTerrainToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0U12@@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,CMapOutdoor::FPushTerrainToDeleteVector>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushTerrainToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0U12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0002d	8b 75 0c	 mov	 esi, DWORD PTR __First$[ebp]
  00030	33 c9		 xor	 ecx, ecx
  00032	8b 5d 10	 mov	 ebx, DWORD PTR __Last$[ebp]
  00035	33 ff		 xor	 edi, edi
  00037	2b de		 sub	 ebx, esi
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	83 c3 03	 add	 ebx, 3
  00043	c1 eb 02	 shr	 ebx, 2
  00046	3b 75 10	 cmp	 esi, DWORD PTR __Last$[ebp]
  00049	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0004c	85 db		 test	 ebx, ebx
  0004e	74 12		 je	 SHORT $LN14@for_each
$LL16@for_each:

; 24   : 		_Func(*_First);

  00050	ff 36		 push	 DWORD PTR [esi]
  00052	8d 4d 14	 lea	 ecx, DWORD PTR __Func$[ebp]
  00055	e8 00 00 00 00	 call	 ??RFPushTerrainToDeleteVector@CMapOutdoor@@QAEXPAVCTerrain@@@Z ; CMapOutdoor::FPushTerrainToDeleteVector::operator()
  0005a	47		 inc	 edi
  0005b	8d 76 04	 lea	 esi, DWORD PTR [esi+4]

; 23   : 	for (; _First != _Last; ++_First)

  0005e	3b fb		 cmp	 edi, ebx
  00060	75 ee		 jne	 SHORT $LL16@for_each
$LN14@for_each:
  00062	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00065	f3 0f 7e 45 14	 movq	 xmm0, QWORD PTR __Func$[ebp]
  0006a	8b 45 1c	 mov	 eax, DWORD PTR __Func$[ebp+8]
  0006d	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00071	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00074	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00077	8d 45 20	 lea	 eax, DWORD PTR __Func$[ebp+12]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ??0?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::vector<CTerrain *,std::allocator<CTerrain *> >
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00080	8b 45 20	 mov	 eax, DWORD PTR __Func$[ebp+12]
  00083	85 c0		 test	 eax, eax
  00085	74 09		 je	 SHORT $LN43@for_each
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008d	83 c4 04	 add	 esp, 4
$LN43@for_each:
; File a:\vs\vc\include\algorithm

; 35   : 	return (_STD move(_Func));

  00090	8b c6		 mov	 eax, esi

; 36   : 	}

  00092	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00095	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009c	59		 pop	 ecx
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushTerrainToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0U12@@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Func$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1FPushTerrainToDeleteVector@CMapOutdoor@@QAE@XZ
__ehhandler$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushTerrainToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0U12@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushTerrainToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0U12@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushTerrainToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0U12@@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,CMapOutdoor::FPushTerrainToDeleteVector>
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@P6AXPAVCArea@@@Z@std@@YAP6AXPAVCArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@P6AXPAVCArea@@@Z@std@@YAP6AXPAVCArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,void (__cdecl*)(CArea *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@P6AXPAVCArea@@@Z@std@@YAP6AXPAVCArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,void (__cdecl*)(CArea *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@P6AXPAVCTerrain@@@Z@std@@YAP6AXPAVCTerrain@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@P6AXPAVCTerrain@@@Z@std@@YAP6AXPAVCTerrain@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,void (__cdecl*)(CTerrain *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@P6AXPAVCTerrain@@@Z@std@@YAP6AXPAVCTerrain@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,void (__cdecl*)(CTerrain *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@PAVCArea@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@V10@0ABQAVCArea@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@PAVCArea@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@V10@0ABQAVCArea@@@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,CArea *>, COMDAT

; 3051 : 	{	// find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3027 : 			break;
; 3028 : 	return (_First);
; 3029 : 	}
; 3030 : 
; 3031 : template<class _InIt,
; 3032 : 	class _Ty> inline
; 3033 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
; 3034 : 	{	// find first matching _Val
; 3035 : 	// activate optimization for pointers to (const) bytes and integral values
; 3036 : 	typedef integral_constant<bool,
; 3037 : 		(  is_same<_InIt, char *>::value
; 3038 : 		|| is_same<_InIt, signed char *>::value
; 3039 : 		|| is_same<_InIt, unsigned char *>::value
; 3040 : 		|| is_same<_InIt, const char *>::value
; 3041 : 		|| is_same<_InIt, const signed char *>::value
; 3042 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3043 : 		&& is_integral<_Ty>::value
; 3044 : 	> _Memchr_opt;
; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]

; 3025 : 	for (; _First != _Last; ++_First)

  00006	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	3b c8		 cmp	 ecx, eax
  0000b	74 10		 je	 SHORT $LN29@find

; 3026 : 		if (*_First == _Val)

  0000d	8b 55 14	 mov	 edx, DWORD PTR __Val$[ebp]
  00010	8b 12		 mov	 edx, DWORD PTR [edx]
$LL16@find:
  00012	39 11		 cmp	 DWORD PTR [ecx], edx
  00014	74 07		 je	 SHORT $LN29@find

; 3025 : 	for (; _First != _Last; ++_First)

  00016	83 c1 04	 add	 ecx, 4
  00019	3b c8		 cmp	 ecx, eax
  0001b	75 f5		 jne	 SHORT $LL16@find
$LN29@find:

; 3052 : 	_DEBUG_RANGE(_First, _Last);
; 3053 : 	return (_Rechecked(_First,
; 3054 : 		_Find(_Unchecked(_First), _Unchecked(_Last), _Val)));

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 3055 : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@PAVCArea@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@V10@0ABQAVCArea@@@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,CArea *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@PAVCTerrain@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@V10@0ABQAVCTerrain@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@PAVCTerrain@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@V10@0ABQAVCTerrain@@@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,CTerrain *>, COMDAT

; 3051 : 	{	// find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3027 : 			break;
; 3028 : 	return (_First);
; 3029 : 	}
; 3030 : 
; 3031 : template<class _InIt,
; 3032 : 	class _Ty> inline
; 3033 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
; 3034 : 	{	// find first matching _Val
; 3035 : 	// activate optimization for pointers to (const) bytes and integral values
; 3036 : 	typedef integral_constant<bool,
; 3037 : 		(  is_same<_InIt, char *>::value
; 3038 : 		|| is_same<_InIt, signed char *>::value
; 3039 : 		|| is_same<_InIt, unsigned char *>::value
; 3040 : 		|| is_same<_InIt, const char *>::value
; 3041 : 		|| is_same<_InIt, const signed char *>::value
; 3042 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3043 : 		&& is_integral<_Ty>::value
; 3044 : 	> _Memchr_opt;
; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]

; 3025 : 	for (; _First != _Last; ++_First)

  00006	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	3b c8		 cmp	 ecx, eax
  0000b	74 10		 je	 SHORT $LN29@find

; 3026 : 		if (*_First == _Val)

  0000d	8b 55 14	 mov	 edx, DWORD PTR __Val$[ebp]
  00010	8b 12		 mov	 edx, DWORD PTR [edx]
$LL16@find:
  00012	39 11		 cmp	 DWORD PTR [ecx], edx
  00014	74 07		 je	 SHORT $LN29@find

; 3025 : 	for (; _First != _Last; ++_First)

  00016	83 c1 04	 add	 ecx, 4
  00019	3b c8		 cmp	 ecx, eax
  0001b	75 f5		 jne	 SHORT $LL16@find
$LN29@find:

; 3052 : 	_DEBUG_RANGE(_First, _Last);
; 3053 : 	return (_Rechecked(_First,
; 3054 : 		_Find(_Unchecked(_First), _Unchecked(_Last), _Val)));

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 3055 : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@PAVCTerrain@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@V10@0ABQAVCTerrain@@@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,CTerrain *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@PAVCGraphicObjectInstance@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@V10@0ABQAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@PAVCGraphicObjectInstance@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@V10@0ABQAVCGraphicObjectInstance@@@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,CGraphicObjectInstance *>, COMDAT

; 3051 : 	{	// find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3027 : 			break;
; 3028 : 	return (_First);
; 3029 : 	}
; 3030 : 
; 3031 : template<class _InIt,
; 3032 : 	class _Ty> inline
; 3033 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
; 3034 : 	{	// find first matching _Val
; 3035 : 	// activate optimization for pointers to (const) bytes and integral values
; 3036 : 	typedef integral_constant<bool,
; 3037 : 		(  is_same<_InIt, char *>::value
; 3038 : 		|| is_same<_InIt, signed char *>::value
; 3039 : 		|| is_same<_InIt, unsigned char *>::value
; 3040 : 		|| is_same<_InIt, const char *>::value
; 3041 : 		|| is_same<_InIt, const signed char *>::value
; 3042 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3043 : 		&& is_integral<_Ty>::value
; 3044 : 	> _Memchr_opt;
; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]

; 3025 : 	for (; _First != _Last; ++_First)

  00006	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	3b c8		 cmp	 ecx, eax
  0000b	74 10		 je	 SHORT $LN29@find

; 3026 : 		if (*_First == _Val)

  0000d	8b 55 14	 mov	 edx, DWORD PTR __Val$[ebp]
  00010	8b 12		 mov	 edx, DWORD PTR [edx]
$LL16@find:
  00012	39 11		 cmp	 DWORD PTR [ecx], edx
  00014	74 07		 je	 SHORT $LN29@find

; 3025 : 	for (; _First != _Last; ++_First)

  00016	83 c1 04	 add	 ecx, 4
  00019	3b c8		 cmp	 ecx, eax
  0001b	75 f5		 jne	 SHORT $LL16@find
$LN29@find:

; 3052 : 	_DEBUG_RANGE(_First, _Last);
; 3053 : 	return (_Rechecked(_First,
; 3054 : 		_Find(_Unchecked(_First), _Unchecked(_Last), _Val)));

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 3055 : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@PAVCGraphicObjectInstance@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@V10@0ABQAVCGraphicObjectInstance@@@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,CGraphicObjectInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ??$ForInRange@UFGetShadowReceiverFromCollisionData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromCollisionData@@@Z
_TEXT	SEGMENT
_r$ = -24						; size = 12
__$EHRec$ = -12						; size = 12
_p$ = 8							; size = 4
_radius$ = 12						; size = 4
_pFunc$ = 16						; size = 4
??$ForInRange@UFGetShadowReceiverFromCollisionData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromCollisionData@@@Z PROC ; CCullingManager::ForInRange<FGetShadowReceiverFromCollisionData>, COMDAT
; _this$ = ecx

; 112  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$ForInRange@UFGetShadowReceiverFromCollisionData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromCollisionData@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 16   : 	{}

  00025	8b 45 10	 mov	 eax, DWORD PTR _pFunc$[ebp]
  00028	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], OFFSET ??_7?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@6B@
  0002f	89 45 ec	 mov	 DWORD PTR _r$[ebp+4], eax
  00032	c7 45 f0 00 00
	80 bf		 mov	 DWORD PTR _r$[ebp+8], -1082130432 ; bf800000H

; 113  : 		RangeTester<T> r(pFunc);
; 114  : 		m_Factory->RangeTest(p, radius, &r/*this*/);	

  00039	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _radius$[ebp]
  0003e	8d 45 e8	 lea	 eax, DWORD PTR _r$[ebp]
  00041	50		 push	 eax
  00042	51		 push	 ecx
  00043	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00046	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004b	ff 75 08	 push	 DWORD PTR _p$[ebp]
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00055	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest

; 115  : 	}

  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$ForInRange@UFGetShadowReceiverFromCollisionData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromCollisionData@@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _r$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAE@XZ ; RangeTester<FGetShadowReceiverFromCollisionData>::~RangeTester<FGetShadowReceiverFromCollisionData>
__ehhandler$??$ForInRange@UFGetShadowReceiverFromCollisionData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromCollisionData@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$ForInRange@UFGetShadowReceiverFromCollisionData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromCollisionData@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$ForInRange@UFGetShadowReceiverFromCollisionData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromCollisionData@@@Z ENDP ; CCullingManager::ForInRange<FGetShadowReceiverFromCollisionData>
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFPCBlockerDistanceSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0UFPCBlockerDistanceSort@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 12
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFPCBlockerDistanceSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0UFPCBlockerDistanceSort@@@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,FPCBlockerDistanceSort>, COMDAT

; 3154 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  00003	f3 0f 7e 45 10	 movq	 xmm0, QWORD PTR __Pred$[ebp]
  00008	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000b	8b 45 18	 mov	 eax, DWORD PTR __Pred$[ebp+8]
  0000e	8b cc		 mov	 ecx, esp
  00010	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00014	89 41 08	 mov	 DWORD PTR [ecx+8], eax
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  00017	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001a	8b d1		 mov	 edx, ecx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	2b d0		 sub	 edx, eax
  00021	c1 fa 02	 sar	 edx, 2
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  00024	52		 push	 edx
  00025	51		 push	 ecx
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??$_Sort@PAPAVCGraphicObjectInstance@@HUFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0HUFPCBlockerDistanceSort@@@Z ; std::_Sort<CGraphicObjectInstance * *,int,FPCBlockerDistanceSort>
  0002c	83 c4 18	 add	 esp, 24			; 00000018H

; 3158 : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFPCBlockerDistanceSort@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0UFPCBlockerDistanceSort@@@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,FPCBlockerDistanceSort>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ??_G?$RangeTester@UPCBlocker_SInstanceList@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$RangeTester@UPCBlocker_SInstanceList@@@@UAEPAXI@Z PROC ; RangeTester<PCBlocker_SInstanceList>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 56   : 	virtual ~SpherePackCallback() {}

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7SpherePackCallback@@6B@
  00010	74 09		 je	 SHORT $LN8@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN8@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G?$RangeTester@UPCBlocker_SInstanceList@@@@UAEPAXI@Z ENDP ; RangeTester<PCBlocker_SInstanceList>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?PointTest2dCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?PointTest2dCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<PCBlocker_SInstanceList>::PointTest2dCallback, COMDAT
; _this$ = ecx

; 50   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)

  00003	83 7d 10 02	 cmp	 DWORD PTR _state$[ebp], 2
  00007	74 0e		 je	 SHORT $LN1@PointTest2

; 56   : 		{
; 57   : #ifdef SPHERELIB_STRICT
; 58   : 			puts("FIND!!");
; 59   : #endif
; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00009	8b 45 0c	 mov	 eax, DWORD PTR _sphere$[ebp]
  0000c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000f	ff 70 44	 push	 DWORD PTR [eax+68]
  00012	e8 00 00 00 00	 call	 ??RPCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z ; PCBlocker_SInstanceList::operator()
$LN1@PointTest2:

; 61   : 		}
; 62   : 	}

  00017	5d		 pop	 ebp
  00018	c2 0c 00	 ret	 12			; 0000000cH
?PointTest2dCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<PCBlocker_SInstanceList>::PointTest2dCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?RangeTestCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_distance$ = 12						; size = 4
_sphere$ = 16						; size = 4
_state$ = 20						; size = 4
?RangeTestCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<PCBlocker_SInstanceList>::RangeTestCallback, COMDAT
; _this$ = ecx

; 40   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)

  00003	83 7d 14 02	 cmp	 DWORD PTR _state$[ebp], 2
  00007	74 0e		 je	 SHORT $LN1@RangeTestC

; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00009	8b 45 10	 mov	 eax, DWORD PTR _sphere$[ebp]
  0000c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000f	ff 70 44	 push	 DWORD PTR [eax+68]
  00012	e8 00 00 00 00	 call	 ??RPCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z ; PCBlocker_SInstanceList::operator()
$LN1@RangeTestC:

; 47   : 	}

  00017	5d		 pop	 ebp
  00018	c2 10 00	 ret	 16			; 00000010H
?RangeTestCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<PCBlocker_SInstanceList>::RangeTestCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?VisibilityCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?VisibilityCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<PCBlocker_SInstanceList>::VisibilityCallback, COMDAT
; _this$ = ecx

; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};

  00000	c2 0c 00	 ret	 12			; 0000000cH
?VisibilityCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<PCBlocker_SInstanceList>::VisibilityCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?RayTraceCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_distance$ = 16						; size = 4
_sect$ = 20						; size = 4
_sphere$ = 24						; size = 4
?RayTraceCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z PROC ; RangeTester<PCBlocker_SInstanceList>::RayTraceCallback, COMDAT
; _this$ = ecx

; 27   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)

  00003	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  00008	0f 57 c0	 xorps	 xmm0, xmm0
  0000b	0f 2f c1	 comiss	 xmm0, xmm1
  0000e	73 06		 jae	 SHORT $LN1@RayTraceCa
  00010	0f 2f 4d 10	 comiss	 xmm1, DWORD PTR _distance$[ebp]
  00014	72 0e		 jb	 SHORT $LN2@RayTraceCa
$LN1@RayTraceCa:

; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00016	8b 45 18	 mov	 eax, DWORD PTR _sphere$[ebp]
  00019	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001c	ff 70 44	 push	 DWORD PTR [eax+68]
  0001f	e8 00 00 00 00	 call	 ??RPCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z ; PCBlocker_SInstanceList::operator()
$LN2@RayTraceCa:

; 34   : 	};

  00024	5d		 pop	 ebp
  00025	c2 14 00	 ret	 20			; 00000014H
?RayTraceCallback@?$RangeTester@UPCBlocker_SInstanceList@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ENDP ; RangeTester<PCBlocker_SInstanceList>::RayTraceCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ??1?$RangeTester@UPCBlocker_SInstanceList@@@@UAE@XZ
_TEXT	SEGMENT
??1?$RangeTester@UPCBlocker_SInstanceList@@@@UAE@XZ PROC ; RangeTester<PCBlocker_SInstanceList>::~RangeTester<PCBlocker_SInstanceList>, COMDAT
; _this$ = ecx
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SpherePackCallback@@6B@
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 19   : 	{}

  00006	c3		 ret	 0
??1?$RangeTester@UPCBlocker_SInstanceList@@@@UAE@XZ ENDP ; RangeTester<PCBlocker_SInstanceList>::~RangeTester<PCBlocker_SInstanceList>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ??0?$RangeTester@UPCBlocker_SInstanceList@@@@QAE@PAUPCBlocker_SInstanceList@@M@Z
_TEXT	SEGMENT
_fn$ = 8						; size = 4
_distance$ = 12						; size = 4
??0?$RangeTester@UPCBlocker_SInstanceList@@@@QAE@PAUPCBlocker_SInstanceList@@M@Z PROC ; RangeTester<PCBlocker_SInstanceList>::RangeTester<PCBlocker_SInstanceList>, COMDAT
; _this$ = ecx

; 16   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _fn$[ebp]
  00006	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _distance$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000e	8b c1		 mov	 eax, ecx
  00010	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$RangeTester@UPCBlocker_SInstanceList@@@@6B@
  00016	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??0?$RangeTester@UPCBlocker_SInstanceList@@@@QAE@PAUPCBlocker_SInstanceList@@M@Z ENDP ; RangeTester<PCBlocker_SInstanceList>::RangeTester<PCBlocker_SInstanceList>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ??RPCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_pInstance$ = 8						; size = 4
??RPCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z PROC ; PCBlocker_SInstanceList::operator(), COMDAT
; _this$ = ecx

; 546  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 547  : 		if (!m_pCamera)

  00006	83 bf 10 08 00
	00 00		 cmp	 DWORD PTR [edi+2064], 0
  0000d	0f 84 9a 00 00
	00		 je	 $LN28@operator

; 548  : 			return;
; 549  : 
; 550  : 		if (!pInstance)

  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _pInstance$[ebp]
  00017	85 f6		 test	 esi, esi
  00019	0f 84 8d 00 00
	00		 je	 $LN29@operator

; 551  : 			return;
; 552  : 
; 553  : 		++m_dwInstCount;

  0001f	ff 07		 inc	 DWORD PTR [edi]
  00021	53		 push	 ebx

; 32   : 			return m_aDSI+0;

  00022	8b 9f 0c 08 00
	00		 mov	 ebx, DWORD PTR [edi+2060]

; 33   : 		}
; 34   : 		Iterator End()
; 35   : 		{
; 36   : 			return m_aDSI+4;

  00028	8d 43 70	 lea	 eax, DWORD PTR [ebx+112]

; 554  : 
; 555  : 		PCBlocker_CDynamicSphereInstanceVector::Iterator i;
; 556  : 
; 557  : 		for (i=m_pkDSIVector->Begin(); i!=m_pkDSIVector->End(); ++i)

  0002b	3b d8		 cmp	 ebx, eax
  0002d	74 7c		 je	 SHORT $LN30@operator
  0002f	90		 npad	 1
$LL10@operator:

; 558  : 		{
; 559  : 			CDynamicSphereInstance& rkDSI = *i;
; 560  : 			if (pInstance->CollisionDynamicSphere(rkDSI) )

  00030	53		 push	 ebx
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::CollisionDynamicSphere
  00038	84 c0		 test	 al, al
  0003a	74 3d		 je	 SHORT $LN9@operator

; 561  : 			{
; 562  : 				if (TREE_OBJECT == pInstance->GetType())

  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
  00040	ff 50 04	 call	 DWORD PTR [eax+4]
  00043	3d a6 f7 c9 8a	 cmp	 eax, -1966475354	; 8ac9f7a6H
  00048	74 46		 je	 SHORT $LN24@operator

; 563  : 				{
; 564  : 					__AppendPCBlocker(pInstance);
; 565  : 					return;
; 566  : 				}
; 567  : 				else if (THING_OBJECT == pInstance->GetType())

  0004a	8b 06		 mov	 eax, DWORD PTR [esi]
  0004c	8b ce		 mov	 ecx, esi
  0004e	ff 50 04	 call	 DWORD PTR [eax+4]
  00051	3d 13 1f f2 ad	 cmp	 eax, -1376641261	; adf21f13H
  00056	74 19		 je	 SHORT $LN31@operator

; 568  : 				{
; 569  : 					__AppendObject(pInstance);
; 570  : 				}
; 571  : 				else if (ACTOR_OBJECT == pInstance->GetType())

  00058	8b 06		 mov	 eax, DWORD PTR [esi]
  0005a	8b ce		 mov	 ecx, esi
  0005c	ff 50 04	 call	 DWORD PTR [eax+4]
  0005f	3d 24 6c a7 29	 cmp	 eax, 698838052		; 29a76c24H
  00064	75 13		 jne	 SHORT $LN9@operator

; 572  : 				{
; 573  : 					if (((CActorInstance *)pInstance)->IsBuilding())

  00066	8b ce		 mov	 ecx, esi
  00068	e8 00 00 00 00	 call	 ?IsBuilding@CActorInstance@@QAE_NXZ ; CActorInstance::IsBuilding
  0006d	84 c0		 test	 al, al
  0006f	74 08		 je	 SHORT $LN9@operator
$LN31@operator:

; 574  : 					{
; 575  : 						__AppendObject(pInstance);

  00071	56		 push	 esi
  00072	8b cf		 mov	 ecx, edi
  00074	e8 00 00 00 00	 call	 ?__AppendObject@PCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z ; PCBlocker_SInstanceList::__AppendObject
$LN9@operator:

; 33   : 		}
; 34   : 		Iterator End()
; 35   : 		{
; 36   : 			return m_aDSI+4;

  00079	8b 87 0c 08 00
	00		 mov	 eax, DWORD PTR [edi+2060]

; 554  : 
; 555  : 		PCBlocker_CDynamicSphereInstanceVector::Iterator i;
; 556  : 
; 557  : 		for (i=m_pkDSIVector->Begin(); i!=m_pkDSIVector->End(); ++i)

  0007f	83 c3 1c	 add	 ebx, 28			; 0000001cH

; 33   : 		}
; 34   : 		Iterator End()
; 35   : 		{
; 36   : 			return m_aDSI+4;

  00082	83 c0 70	 add	 eax, 112		; 00000070H

; 554  : 
; 555  : 		PCBlocker_CDynamicSphereInstanceVector::Iterator i;
; 556  : 
; 557  : 		for (i=m_pkDSIVector->Begin(); i!=m_pkDSIVector->End(); ++i)

  00085	3b d8		 cmp	 ebx, eax
  00087	75 a7		 jne	 SHORT $LL10@operator
  00089	5b		 pop	 ebx
  0008a	5e		 pop	 esi
  0008b	5f		 pop	 edi

; 576  : 					}
; 577  : 				}
; 578  : 			}
; 579  : 		}
; 580  : 	}

  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
$LN24@operator:

; 37   : 		}
; 38   : 
; 39   : 	private:
; 40   : 		CDynamicSphereInstance m_aDSI[4];
; 41   : };
; 42   : 
; 43   : 
; 44   : 
; 45   : 
; 46   : bool CMapOutdoor::Update(float fX, float fY, float fZ)
; 47   : {
; 48   : 	D3DXVECTOR3 v3Player(fX, fY, fZ);
; 49   : 
; 50   : 	m_v3Player=v3Player;
; 51   : 
; 52   : 
; 53   : 	DWORD t1=ELTimer_GetMSec();
; 54   : 
; 55   : 	int ix, iy;
; 56   : 	PR_FLOAT_TO_INT(fX, ix);
; 57   : 	if ( fY < 0 )
; 58   : 		fY = -fY;
; 59   : 	PR_FLOAT_TO_INT(fY, iy);
; 60   : 	
; 61   : 	short sCoordX = MINMAX(0, ix / CTerrainImpl::TERRAIN_XSIZE, m_sTerrainCountX - 1);
; 62   : 	short sCoordY = MINMAX(0, iy / CTerrainImpl::TERRAIN_YSIZE, m_sTerrainCountY - 1);
; 63   : #ifdef __PERFORMANCE_CHECKER__
; 64   : 	DWORD t2=ELTimer_GetMSec();
; 65   : #endif
; 66   : 
; 67   : 	bool bNeedInit = (m_PrevCoordinate.m_sTerrainCoordX == -1 || m_PrevCoordinate.m_sTerrainCoordY == -1);
; 68   : 
; 69   : 	if ( bNeedInit ||
; 70   : 		(m_CurCoordinate.m_sTerrainCoordX/LOAD_SIZE_WIDTH) != (sCoordX/LOAD_SIZE_WIDTH) || 
; 71   : 		(m_CurCoordinate.m_sTerrainCoordY/LOAD_SIZE_WIDTH) != (sCoordY/LOAD_SIZE_WIDTH) )
; 72   : 	{
; 73   : 		if (bNeedInit)
; 74   : 		{
; 75   : 			m_PrevCoordinate.m_sTerrainCoordX = sCoordX;
; 76   : 			m_PrevCoordinate.m_sTerrainCoordY = sCoordY;
; 77   : 		}
; 78   : 		else
; 79   : 		{
; 80   : 			m_PrevCoordinate.m_sTerrainCoordX = m_CurCoordinate.m_sTerrainCoordX;
; 81   : 			m_PrevCoordinate.m_sTerrainCoordY = m_CurCoordinate.m_sTerrainCoordY;
; 82   : 		}
; 83   : 		
; 84   : 		m_CurCoordinate.m_sTerrainCoordX = sCoordX;
; 85   : 		m_CurCoordinate.m_sTerrainCoordY = sCoordY;
; 86   : 		m_lCurCoordStartX = sCoordX * CTerrainImpl::TERRAIN_XSIZE;
; 87   : 		m_lCurCoordStartY = sCoordY * CTerrainImpl::TERRAIN_YSIZE;
; 88   : 
; 89   : 		WORD wCellCoordX = (ix % CTerrainImpl::TERRAIN_XSIZE) / CTerrainImpl::CELLSCALE;
; 90   : 		WORD wCellCoordY = (iy % CTerrainImpl::TERRAIN_YSIZE) / CTerrainImpl::CELLSCALE;
; 91   : 
; 92   : 		short sReferenceCoordMinX, sReferenceCoordMaxX, sReferenceCoordMinY, sReferenceCoordMaxY;
; 93   : 		sReferenceCoordMinX = max(m_CurCoordinate.m_sTerrainCoordX - LOAD_SIZE_WIDTH, 0);
; 94   : 		sReferenceCoordMaxX = min(m_CurCoordinate.m_sTerrainCoordX + LOAD_SIZE_WIDTH, m_sTerrainCountX - 1);
; 95   : 		sReferenceCoordMinY = max(m_CurCoordinate.m_sTerrainCoordY - LOAD_SIZE_WIDTH, 0);
; 96   : 		sReferenceCoordMaxY = min(m_CurCoordinate.m_sTerrainCoordY + LOAD_SIZE_WIDTH, m_sTerrainCountY - 1);
; 97   : 		
; 98   : 		for (WORD usY = sReferenceCoordMinY; usY <=sReferenceCoordMaxY; ++usY)
; 99   : 		{
; 100  : 			for (WORD usX = sReferenceCoordMinX; usX <= sReferenceCoordMaxX; ++usX)
; 101  : 			{
; 102  : 				LoadTerrain(usX, usY, wCellCoordX, wCellCoordY);
; 103  :   				LoadArea(usX, usY, wCellCoordX, wCellCoordY);
; 104  : 			}
; 105  : 		}
; 106  : 
; 107  : 		AssignTerrainPtr();
; 108  : 		m_lOldReadX = -1;
; 109  : 
; 110  : 		Tracenf("Update::Load spent %d ms\n", ELTimer_GetMSec() - t1);
; 111  : 	}
; 112  : #ifdef __PERFORMANCE_CHECKER__
; 113  : 	DWORD t3=ELTimer_GetMSec();
; 114  : #endif
; 115  : 	CSpeedTreeForestDirectX8::Instance().UpdateSystem(CTimer::Instance().GetCurrentSecond());
; 116  : #ifdef __PERFORMANCE_CHECKER__
; 117  : 	DWORD t4=ELTimer_GetMSec();
; 118  : #endif
; 119  : 	__UpdateGarvage();
; 120  : #ifdef __PERFORMANCE_CHECKER__
; 121  : 	DWORD t5=ELTimer_GetMSec();
; 122  : #endif
; 123  : 	UpdateTerrain(fX, fY);
; 124  : #ifdef __PERFORMANCE_CHECKER__
; 125  : 	DWORD t6=ELTimer_GetMSec();
; 126  : #endif
; 127  : 	__UpdateArea(v3Player);
; 128  : #ifdef __PERFORMANCE_CHECKER__
; 129  : 	DWORD t7=ELTimer_GetMSec();
; 130  : #endif
; 131  : 	UpdateSky();
; 132  : #ifdef __PERFORMANCE_CHECKER__	
; 133  : 	DWORD t8=ELTimer_GetMSec();
; 134  : #endif
; 135  : 	__HeightCache_Update();
; 136  : 
; 137  : #ifdef __PERFORMANCE_CHECKER__
; 138  : 	{
; 139  : 		static FILE* fp=fopen("perf_outdoor_update.txt", "w");
; 140  : 
; 141  : 		if (t8-t1>5)
; 142  : 		{
; 143  : 			fprintf(fp, "OD.Total %d (Time %f)\n", t3-t1, ELTimer_GetMSec()/1000.0f);
; 144  : 			fprintf(fp, "OD.INIT %d\n", t2-t1);
; 145  : 			fprintf(fp, "OD.LOAD %d\n", t3-t2);
; 146  : 			fprintf(fp, "OD.TREE %d\n", t4-t3);
; 147  : 			fprintf(fp, "OD.GVG %d\n", t5-t4);
; 148  : 			fprintf(fp, "OD.TRN %d\n", t6-t5);
; 149  : 			fprintf(fp, "OD.AREA %d\n", t7-t6);
; 150  : 			fprintf(fp, "OD.SKY %d\n", t8-t7);
; 151  : 			fflush(fp);
; 152  : 		}
; 153  : 	}
; 154  : #endif
; 155  : 	
; 156  : 	return true;
; 157  : }
; 158  : 
; 159  : void CMapOutdoor::UpdateSky()
; 160  : {
; 161  : 	m_SkyBox.Update();
; 162  : }
; 163  : 
; 164  : struct FGetShadowReceiverFromCollisionData
; 165  : {
; 166  : 	bool m_bCollide;
; 167  : 	std::vector<CGraphicObjectInstance *>* m_pkVct_pkShadowReceiver;
; 168  : 	CDynamicSphereInstance * m_pdsi;
; 169  : 	FGetShadowReceiverFromCollisionData(CDynamicSphereInstance * pdsi, std::vector<CGraphicObjectInstance *>* pkVct_pkShadowReceiver) : m_pdsi(pdsi), m_bCollide(false)
; 170  : 	{
; 171  : 		m_pkVct_pkShadowReceiver=pkVct_pkShadowReceiver;
; 172  : 		m_pkVct_pkShadowReceiver->clear();
; 173  : 	}
; 174  : 	void operator () (CGraphicObjectInstance * pInstance)
; 175  : 	{
; 176  : 		if (!pInstance)
; 177  : 			return;
; 178  : 
; 179  : 		if (TREE_OBJECT == pInstance->GetType() || ACTOR_OBJECT == pInstance->GetType() || EFFECT_OBJECT == pInstance->GetType())
; 180  : 			return;
; 181  : 		if (pInstance->CollisionDynamicSphere(*m_pdsi))
; 182  : 		{
; 183  : 			m_pkVct_pkShadowReceiver->push_back(pInstance);
; 184  : 			m_bCollide = true;
; 185  : 		}
; 186  : 	}
; 187  : };
; 188  : 
; 189  : 
; 190  : 
; 191  : struct FPCBlockerDistanceSort
; 192  : {
; 193  : 	D3DXVECTOR3 m_v3Eye;
; 194  : 	FPCBlockerDistanceSort(D3DXVECTOR3 & v3Eye) : m_v3Eye(v3Eye) { }
; 195  : 
; 196  : 	bool operator () (CGraphicObjectInstance * plhs, CGraphicObjectInstance * prhs) const
; 197  : 	{
; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));
; 199  : 	}
; 200  : };
; 201  : 
; 202  : void CMapOutdoor::UpdateAroundAmbience(float fX, float fY, float fZ)
; 203  : {
; 204  : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)
; 205  : 	{
; 206  : 		CArea * pArea;
; 207  : 		if (GetAreaPointer(i, &pArea))
; 208  : 			pArea->UpdateAroundAmbience(fX, fY, fZ);
; 209  : 	}
; 210  : }
; 211  : 
; 212  : void CMapOutdoor::__UpdateArea(D3DXVECTOR3& v3Player)
; 213  : {
; 214  : #ifdef WORLD_EDITOR
; 215  : 	__NEW_WorldEditor_UpdateArea();	
; 216  : #else
; 217  : 	__Game_UpdateArea(v3Player);
; 218  : #endif
; 219  : }
; 220  : 
; 221  : void CMapOutdoor::__Game_UpdateArea(D3DXVECTOR3& v3Player)
; 222  : {
; 223  : #ifdef __PERFORMANCE_CHECKER__
; 224  : 	DWORD t1=timeGetTime();
; 225  : #endif
; 226  : 	m_PCBlockerVector.clear();	
; 227  : 	m_ShadowReceiverVector.clear();
; 228  : #ifdef __PERFORMANCE_CHECKER__
; 229  : 	DWORD t2=timeGetTime();
; 230  : #endif
; 231  : 	CCameraManager& rCmrMgr=CCameraManager::Instance();
; 232  : 	CCamera * pCamera = rCmrMgr.GetCurrentCamera();
; 233  : 	if (!pCamera)
; 234  : 		return;
; 235  : 
; 236  : 	float fDistance = pCamera->GetDistance();	
; 237  : 
; 238  : 	D3DXVECTOR3 v3View= pCamera->GetView();		
; 239  : 	D3DXVECTOR3 v3Target = pCamera->GetTarget();
; 240  : 	D3DXVECTOR3 v3Eye= pCamera->GetEye();
; 241  : 
; 242  : 	D3DXVECTOR3 v3Light = D3DXVECTOR3(1.732f, 1.0f, -3.464f); //  
; 243  : 	v3Light *= 50.0f / D3DXVec3Length(&v3Light);
; 244  : 
; 245  : 	/*
; 246  : 	if (v3Target!=v3Player)
; 247  : 	{
; 248  : 		printf("%.2f %.2f %.2f -> target(%.2f %.2f %.2f) player(%.2f %.2f %.2f)\n",
; 249  : 		v3Eye.x, v3Eye.y, v3Eye.z,
; 250  : 		v3Target.x, v3Target.y, v3Target.z,
; 251  : 		v3Player.x, v3Player.y, v3Player.z
; 252  : 	);
; 253  : 	}
; 254  : 	*/
; 255  : #ifdef __PERFORMANCE_CHECKER__
; 256  : 	DWORD t3=timeGetTime();
; 257  : #endif
; 258  : 	__CollectShadowReceiver(v3Player, v3Light);
; 259  : #ifdef __PERFORMANCE_CHECKER__
; 260  : 	DWORD t4=timeGetTime();
; 261  : #endif
; 262  : 	__CollectCollisionPCBlocker(v3Eye, v3Player, fDistance);
; 263  : #ifdef __PERFORMANCE_CHECKER__
; 264  : 	DWORD t5=timeGetTime();
; 265  : #endif
; 266  : 	__CollectCollisionShadowReceiver(v3Player, v3Light);
; 267  : #ifdef __PERFORMANCE_CHECKER__
; 268  : 	DWORD t6=timeGetTime();
; 269  : #endif
; 270  : 	__UpdateAroundAreaList();
; 271  : 
; 272  : #ifdef __PERFORMANCE_CHECKER__
; 273  : 	DWORD t7=timeGetTime();
; 274  : 	{
; 275  : 		static FILE* fp=fopen("perf_area_update.txt", "w");
; 276  : 
; 277  : 		if (t7-t1>5)
; 278  : 		{
; 279  : 			fprintf(fp, "UA.Total %d (Time %f)\n", t3-t1, ELTimer_GetMSec()/1000.0f);
; 280  : 			fprintf(fp, "UA.Clear %d\n", t2-t1);
; 281  : 			fprintf(fp, "UA.Vector %d\n", t3-t2);
; 282  : 			fprintf(fp, "UA.Shadow %d\n", t4-t3);
; 283  : 			fprintf(fp, "UA.Blocker %d\n", t5-t4);
; 284  : 			fprintf(fp, "UA.ColliShadow %d\n", t6-t5);
; 285  : 			fprintf(fp, "UA.Area %d\n", t7-t6);			
; 286  : 			fflush(fp);
; 287  : 		}
; 288  : 	}
; 289  : #endif
; 290  : }
; 291  : #ifdef WORLD_EDITOR
; 292  : void CMapOutdoor::__NEW_WorldEditor_UpdateArea()
; 293  : {
; 294  : 	m_PCBlockerVector.clear();
; 295  : 	m_ShadowReceiverVector.clear();
; 296  : 	__UpdateAroundAreaList();
; 297  : 		
; 298  : }
; 299  : #endif
; 300  : void CMapOutdoor::__UpdateAroundAreaList()
; 301  : {
; 302  : #ifdef __PERFORMANCE_CHECKER__
; 303  : 	DWORD ft1=timeGetTime();
; 304  : #endif
; 305  : 	DWORD at[AROUND_AREA_NUM];
; 306  : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)
; 307  : 	{
; 308  : 		DWORD t1=timeGetTime();
; 309  : 		CArea * pArea;
; 310  : 		if (GetAreaPointer(i, &pArea))
; 311  : 			pArea->Update();
; 312  : 		DWORD t2=timeGetTime();
; 313  : 
; 314  : 		at[i]=t2-t1;
; 315  : 	}	
; 316  : #ifdef __PERFORMANCE_CHECKER__
; 317  : 	DWORD ft2=timeGetTime();
; 318  : 	if (ft2-ft1>5)
; 319  : 	{
; 320  : 		for (int i=0; i<AROUND_AREA_NUM; ++i)
; 321  : 			Tracef("Area %d %d\n", i, at[i]);
; 322  : 	}
; 323  : #endif
; 324  : }
; 325  : 
; 326  : 
; 327  : struct FGetShadowReceiverFromHeightData
; 328  : {
; 329  : 	enum
; 330  : 	{
; 331  : 		COLLECT_MAX = 100,
; 332  : 	};
; 333  : 	
; 334  : 	DWORD m_dwCollectOverCount;
; 335  : 	DWORD m_dwCollectCount;
; 336  : 	DWORD m_dwCheckCount;
; 337  : 	bool m_bReceiverFound;
; 338  : 	float m_fFromX, m_fFromY, m_fToX, m_fToY;
; 339  : 	float m_fReturnHeight;
; 340  : 
; 341  : 	CGraphicObjectInstance* m_apkShadowReceiver[COLLECT_MAX];
; 342  : 	
; 343  : 	FGetShadowReceiverFromHeightData(float fFromX, float fFromY, float fToX, float fToY) :
; 344  : 	m_fFromX(fFromX), m_fFromY(fFromY), m_fToX(fToX), m_fToY(fToY), m_bReceiverFound(false)
; 345  : 	{
; 346  : 		m_dwCheckCount=0;
; 347  : 		m_dwCollectOverCount=0;
; 348  : 		m_dwCollectCount=0;		
; 349  : 	}
; 350  : 
; 351  : 	CGraphicObjectInstance* GetCollectItem(UINT uIndex)
; 352  : 	{
; 353  : 		if (uIndex>=m_dwCollectCount)
; 354  : 			return NULL;
; 355  : 
; 356  : 		return m_apkShadowReceiver[uIndex];
; 357  : 	}
; 358  : 
; 359  : 	UINT GetCollectCount()
; 360  : 	{
; 361  : 		return m_dwCollectCount;
; 362  : 	}
; 363  : 
; 364  : 	void operator () (CGraphicObjectInstance * pInstance)
; 365  : 	{
; 366  : 		m_dwCheckCount++;
; 367  : 
; 368  : 		if (!pInstance)
; 369  : 			return;
; 370  : 
; 371  : 		if (m_fFromY < 0)
; 372  : 			m_fFromY = -m_fFromY;
; 373  : 		if (m_fToY < 0)
; 374  : 			m_fToY = -m_fToY;
; 375  : 		if (pInstance->GetObjectHeight(m_fFromX, m_fFromY, &m_fReturnHeight) ||
; 376  : 			pInstance->GetObjectHeight(m_fToX, m_fToY, &m_fReturnHeight))
; 377  : 		{
; 378  : 			if (m_dwCollectCount<COLLECT_MAX)
; 379  : 				m_apkShadowReceiver[m_dwCollectCount++]=pInstance;
; 380  : 			else
; 381  : 				m_dwCollectOverCount++;
; 382  : 
; 383  : 			m_bReceiverFound = true;
; 384  : 		}
; 385  : 	}
; 386  : };
; 387  : 
; 388  : 
; 389  : void CMapOutdoor::__CollectShadowReceiver(D3DXVECTOR3& v3Target, D3DXVECTOR3& v3Light)
; 390  : {
; 391  : 	CDynamicSphereInstance s;
; 392  : 	s.v3LastPosition = v3Target + v3Light;
; 393  : 	s.v3Position = s.v3LastPosition + v3Light;
; 394  : 	s.fRadius = 50.0f;
; 395  : 
; 396  : 	Vector3d aVector3d;
; 397  : 	aVector3d.Set(v3Target.x, v3Target.y, v3Target.z);
; 398  : 
; 399  : 	CCullingManager & rkCullingMgr = CCullingManager::Instance();
; 400  : 
; 401  : #ifdef __PERFORMANCE_CHECKER__
; 402  : 	DWORD t1=ELTimer_GetMSec();
; 403  : #endif
; 404  : 
; 405  : 	FGetShadowReceiverFromHeightData kGetShadowReceiverFromHeightData(v3Target.x, v3Target.y, s.v3Position.x, s.v3Position.y);
; 406  : 	rkCullingMgr.ForInRange(aVector3d, 10.0f, &kGetShadowReceiverFromHeightData);
; 407  : 
; 408  : #ifdef __PERFORMANCE_CHECKER__
; 409  : 	DWORD t2=ELTimer_GetMSec();
; 410  : #endif
; 411  : 
; 412  : 	if (kGetShadowReceiverFromHeightData.m_bReceiverFound)
; 413  : 	{
; 414  : 		for (UINT i=0; i<kGetShadowReceiverFromHeightData.GetCollectCount(); ++i)
; 415  : 		{
; 416  : 			CGraphicObjectInstance * pObjInstEach = kGetShadowReceiverFromHeightData.GetCollectItem(i);
; 417  : 			if (!__IsInShadowReceiverList(pObjInstEach))
; 418  : 				m_ShadowReceiverVector.push_back(pObjInstEach);	
; 419  : 		}
; 420  : 	}
; 421  : 
; 422  : #ifdef __PERFORMANCE_CHECKER__
; 423  : 	static FILE* fp=fopen("perf_shadow_collect.txt", "w");
; 424  : 	DWORD t3=ELTimer_GetMSec();
; 425  : 
; 426  : 	if (t3-t1>5)
; 427  : 	{
; 428  : 		fprintf(fp, "SC.Total %d (Time %f)\n", t3-t1, ELTimer_GetMSec()/1000.0f);
; 429  : 		fprintf(fp, "SC.Find %d\n", t2-t1);
; 430  : 		fprintf(fp, "SC.Push %d\n", t3-t2);
; 431  : 		fprintf(fp, "SC.Count (Collect %d, Over %d, Check %d)\n", 
; 432  : 			kGetShadowReceiverFromHeightData.m_dwCollectCount, 
; 433  : 			kGetShadowReceiverFromHeightData.m_dwCollectOverCount,
; 434  : 			kGetShadowReceiverFromHeightData.m_dwCheckCount);
; 435  : 		fflush(fp);
; 436  : 	}
; 437  : #endif
; 438  : }
; 439  : 
; 440  : 
; 441  : struct PCBlocker_SInstanceList
; 442  : {
; 443  : 	typedef CGraphicObjectInstance* Item;
; 444  : 	typedef Item* Iterator;
; 445  : 
; 446  : 	enum
; 447  : 	{
; 448  : 		CAPACITY = 512,
; 449  : 	};
; 450  : 
; 451  : 	DWORD m_dwInstCount;
; 452  : 	DWORD m_dwBlockerCount;
; 453  : 	DWORD m_dwBlockerOverCount;
; 454  : 
; 455  : 	Item m_apkPCBlocker[CAPACITY];
; 456  : 	
; 457  : 	PCBlocker_CDynamicSphereInstanceVector* m_pkDSIVector;
; 458  : 	
; 459  : 	CCamera * m_pCamera;
; 460  : 	D3DXVECTOR2 m_v2View;
; 461  : 	D3DXVECTOR2 m_v2Target;
; 462  : 	
; 463  : 	PCBlocker_SInstanceList(PCBlocker_CDynamicSphereInstanceVector* pkDSIVector)
; 464  : 	{		
; 465  : 		m_pCamera = CCameraManager::Instance().GetCurrentCamera();
; 466  : 		if (!m_pCamera)
; 467  : 			return;
; 468  : 
; 469  : 		D3DXVECTOR3 m_v3View = m_pCamera->GetView();
; 470  : 		D3DXVECTOR3 m_v3Target = m_pCamera->GetTarget();
; 471  : 
; 472  : 		m_v2View.x = m_v3View.x;
; 473  : 		m_v2View.y = m_v3View.y;
; 474  : 
; 475  : 		m_v2Target.x = m_v3Target.x;
; 476  : 		m_v2Target.y = m_v3Target.y;
; 477  : 
; 478  : 		m_pkDSIVector=pkDSIVector;
; 479  : 		m_dwBlockerCount=0;
; 480  : 		m_dwBlockerOverCount=0;
; 481  : 		m_dwInstCount=0;
; 482  : 	}
; 483  : 	~PCBlocker_SInstanceList()
; 484  : 	{
; 485  : #ifdef _DEBUG
; 486  : 		__DEBUG_ShowInstanceMaxCount();
; 487  : #endif
; 488  : 	}
; 489  : 	void __DEBUG_ShowInstanceMaxCount()
; 490  : 	{
; 491  : 		static DWORD s_dwInstMaxCount=0;
; 492  : 		if (s_dwInstMaxCount<m_dwInstCount)
; 493  : 		{
; 494  : 			s_dwInstMaxCount=m_dwInstCount;
; 495  : 			//Tracenf("PCBlocker MaxInstanceCount %d", m_dwInstCount);
; 496  : 		}
; 497  : 	}
; 498  : 	
; 499  : 	Iterator Begin()
; 500  : 	{
; 501  : 		return m_apkPCBlocker;
; 502  : 	}
; 503  : 	Iterator End()
; 504  : 	{
; 505  : 		return m_apkPCBlocker+m_dwBlockerCount;
; 506  : 	}
; 507  : 
; 508  : 	DWORD Size()
; 509  : 	{
; 510  : 		return m_dwBlockerCount;
; 511  : 	}
; 512  : 
; 513  : 	bool IsEmpty()
; 514  : 	{
; 515  : 		if (m_dwBlockerCount>0)
; 516  : 			return false;
; 517  : 
; 518  : 		return true;
; 519  : 	}
; 520  : 
; 521  : 	void __AppendPCBlocker(CGraphicObjectInstance * pInstance)
; 522  : 	{
; 523  : 		if (m_dwBlockerCount<CAPACITY)

  00090	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00093	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  00098	73 0e		 jae	 SHORT $LN20@operator

; 524  : 			m_apkPCBlocker[m_dwBlockerCount++]=pInstance;

  0009a	89 74 87 0c	 mov	 DWORD PTR [edi+eax*4+12], esi
  0009e	ff 47 04	 inc	 DWORD PTR [edi+4]
  000a1	5b		 pop	 ebx
  000a2	5e		 pop	 esi
  000a3	5f		 pop	 edi

; 576  : 					}
; 577  : 				}
; 578  : 			}
; 579  : 		}
; 580  : 	}

  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
$LN20@operator:

; 525  : 		else
; 526  : 			m_dwBlockerOverCount++;

  000a8	ff 47 08	 inc	 DWORD PTR [edi+8]
$LN30@operator:
  000ab	5b		 pop	 ebx
$LN29@operator:
  000ac	5e		 pop	 esi
$LN28@operator:
  000ad	5f		 pop	 edi

; 576  : 					}
; 577  : 				}
; 578  : 			}
; 579  : 		}
; 580  : 	}

  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
??RPCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z ENDP ; PCBlocker_SInstanceList::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?__AppendObject@PCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_fRadius$ = -20						; size = 4
_v3Center$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_pInstance$ = 8						; size = 4
?__AppendObject@PCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z PROC ; PCBlocker_SInstanceList::__AppendObject, COMDAT
; _this$ = ecx

; 530  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _pInstance$[ebp]
  00015	8b f1		 mov	 esi, ecx

; 531  : 		D3DXVECTOR3 v3Center;
; 532  : 		float fRadius;
; 533  : 		pInstance->GetBoundingSphere(v3Center, fRadius);

  00017	8d 4d ec	 lea	 ecx, DWORD PTR _fRadius$[ebp]
  0001a	51		 push	 ecx
  0001b	8d 4d f0	 lea	 ecx, DWORD PTR _v3Center$[ebp]
  0001e	8b 07		 mov	 eax, DWORD PTR [edi]
  00020	51		 push	 ecx
  00021	8b cf		 mov	 ecx, edi
  00023	ff 50 0c	 call	 DWORD PTR [eax+12]

; 534  : 
; 535  : 		D3DXVECTOR2 v2TargetToCenter;
; 536  : 		v2TargetToCenter.x = v3Center.x - m_v2Target.x;
; 537  : 		v2TargetToCenter.y = v3Center.y - m_v2Target.y;

  00026	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v3Center$[ebp+4]
  0002b	f3 0f 5c 86 20
	08 00 00	 subss	 xmm0, DWORD PTR [esi+2080]
  00033	f3 0f 10 55 f0	 movss	 xmm2, DWORD PTR _v3Center$[ebp]
  00038	f3 0f 5c 96 1c
	08 00 00	 subss	 xmm2, DWORD PTR [esi+2076]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;

  00040	f3 0f 10 8e 18
	08 00 00	 movss	 xmm1, DWORD PTR [esi+2072]
  00048	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0004c	f3 0f 10 86 14
	08 00 00	 movss	 xmm0, DWORD PTR [esi+2068]
  00054	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00058	f3 0f 58 c8	 addss	 xmm1, xmm0
  0005c	0f 57 c0	 xorps	 xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 538  : 		if (D3DXVec2Dot(&m_v2View, &v2TargetToCenter) <= 0)

  0005f	0f 2f c1	 comiss	 xmm0, xmm1
  00062	72 26		 jb	 SHORT $LN10@AppendObje

; 523  : 		if (m_dwBlockerCount<CAPACITY)

  00064	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00067	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  0006c	73 19		 jae	 SHORT $LN11@AppendObje

; 524  : 			m_apkPCBlocker[m_dwBlockerCount++]=pInstance;

  0006e	89 7c 86 0c	 mov	 DWORD PTR [esi+eax*4+12], edi
  00072	ff 46 04	 inc	 DWORD PTR [esi+4]
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 539  : 		{
; 540  : 			__AppendPCBlocker(pInstance);
; 541  : 			return;
; 542  : 		}
; 543  : 	}

  00077	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007a	33 cd		 xor	 ecx, ebp
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
$LN11@AppendObje:

; 525  : 		else
; 526  : 			m_dwBlockerOverCount++;

  00087	ff 46 08	 inc	 DWORD PTR [esi+8]
$LN10@AppendObje:

; 539  : 		{
; 540  : 			__AppendPCBlocker(pInstance);
; 541  : 			return;
; 542  : 		}
; 543  : 	}

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008d	5f		 pop	 edi
  0008e	33 cd		 xor	 ecx, ebp
  00090	5e		 pop	 esi
  00091	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 04 00	 ret	 4
?__AppendObject@PCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z ENDP ; PCBlocker_SInstanceList::__AppendObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?__AppendPCBlocker@PCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_pInstance$ = 8						; size = 4
?__AppendPCBlocker@PCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z PROC ; PCBlocker_SInstanceList::__AppendPCBlocker, COMDAT
; _this$ = ecx

; 522  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 523  : 		if (m_dwBlockerCount<CAPACITY)

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	81 fa 00 02 00
	00		 cmp	 edx, 512		; 00000200H
  0000c	73 0e		 jae	 SHORT $LN2@AppendPCBl

; 524  : 			m_apkPCBlocker[m_dwBlockerCount++]=pInstance;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _pInstance$[ebp]
  00011	89 44 91 0c	 mov	 DWORD PTR [ecx+edx*4+12], eax
  00015	ff 41 04	 inc	 DWORD PTR [ecx+4]

; 527  : 	}

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@AppendPCBl:

; 525  : 		else
; 526  : 			m_dwBlockerOverCount++;

  0001c	ff 41 08	 inc	 DWORD PTR [ecx+8]

; 527  : 	}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?__AppendPCBlocker@PCBlocker_SInstanceList@@QAEXPAVCGraphicObjectInstance@@@Z ENDP ; PCBlocker_SInstanceList::__AppendPCBlocker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?IsEmpty@PCBlocker_SInstanceList@@QAE_NXZ
_TEXT	SEGMENT
?IsEmpty@PCBlocker_SInstanceList@@QAE_NXZ PROC		; PCBlocker_SInstanceList::IsEmpty, COMDAT
; _this$ = ecx

; 515  : 		if (m_dwBlockerCount>0)

  00000	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00004	0f 96 c0	 setbe	 al

; 516  : 			return false;
; 517  : 
; 518  : 		return true;
; 519  : 	}

  00007	c3		 ret	 0
?IsEmpty@PCBlocker_SInstanceList@@QAE_NXZ ENDP		; PCBlocker_SInstanceList::IsEmpty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?End@PCBlocker_SInstanceList@@QAEPAPAVCGraphicObjectInstance@@XZ
_TEXT	SEGMENT
?End@PCBlocker_SInstanceList@@QAEPAPAVCGraphicObjectInstance@@XZ PROC ; PCBlocker_SInstanceList::End, COMDAT
; _this$ = ecx

; 505  : 		return m_apkPCBlocker+m_dwBlockerCount;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 03	 add	 eax, 3
  00006	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 506  : 	}

  00009	c3		 ret	 0
?End@PCBlocker_SInstanceList@@QAEPAPAVCGraphicObjectInstance@@XZ ENDP ; PCBlocker_SInstanceList::End
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?Begin@PCBlocker_SInstanceList@@QAEPAPAVCGraphicObjectInstance@@XZ
_TEXT	SEGMENT
?Begin@PCBlocker_SInstanceList@@QAEPAPAVCGraphicObjectInstance@@XZ PROC ; PCBlocker_SInstanceList::Begin, COMDAT
; _this$ = ecx

; 501  : 		return m_apkPCBlocker;

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]

; 502  : 	}

  00003	c3		 ret	 0
?Begin@PCBlocker_SInstanceList@@QAEPAPAVCGraphicObjectInstance@@XZ ENDP ; PCBlocker_SInstanceList::Begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ??1PCBlocker_SInstanceList@@QAE@XZ
_TEXT	SEGMENT
??1PCBlocker_SInstanceList@@QAE@XZ PROC			; PCBlocker_SInstanceList::~PCBlocker_SInstanceList, COMDAT
; _this$ = ecx

; 485  : #ifdef _DEBUG
; 486  : 		__DEBUG_ShowInstanceMaxCount();
; 487  : #endif
; 488  : 	}

  00000	c3		 ret	 0
??1PCBlocker_SInstanceList@@QAE@XZ ENDP			; PCBlocker_SInstanceList::~PCBlocker_SInstanceList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ??0PCBlocker_SInstanceList@@QAE@PAVPCBlocker_CDynamicSphereInstanceVector@@@Z
_TEXT	SEGMENT
_m_v3Target$ = -24					; size = 12
_m_v3View$ = -12					; size = 12
_pkDSIVector$ = 8					; size = 4
??0PCBlocker_SInstanceList@@QAE@PAVPCBlocker_CDynamicSphereInstanceVector@@@Z PROC ; PCBlocker_SInstanceList::PCBlocker_SInstanceList, COMDAT
; _this$ = ecx

; 463  : 	PCBlocker_SInstanceList(PCBlocker_CDynamicSphereInstanceVector* pkDSIVector)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 464  : 	{		
; 465  : 		m_pCamera = CCameraManager::Instance().GetCurrentCamera();

  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0000f	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera
  00014	89 86 10 08 00
	00		 mov	 DWORD PTR [esi+2064], eax

; 466  : 		if (!m_pCamera)

  0001a	85 c0		 test	 eax, eax
  0001c	74 71		 je	 SHORT $LN14@PCBlocker_

; 467  : 			return;
; 468  : 
; 469  : 		D3DXVECTOR3 m_v3View = m_pCamera->GetView();

  0001e	f3 0f 7e 40 54	 movq	 xmm0, QWORD PTR [eax+84]
  00023	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  00026	66 0f d6 45 f4	 movq	 QWORD PTR _m_v3View$[ebp], xmm0

; 470  : 		D3DXVECTOR3 m_v3Target = m_pCamera->GetTarget();

  0002b	f3 0f 7e 40 3c	 movq	 xmm0, QWORD PTR [eax+60]
  00030	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  00033	66 0f d6 45 e8	 movq	 QWORD PTR _m_v3Target$[ebp], xmm0

; 471  : 
; 472  : 		m_v2View.x = m_v3View.x;

  00038	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _m_v3View$[ebp]
  0003d	f3 0f 11 86 14
	08 00 00	 movss	 DWORD PTR [esi+2068], xmm0

; 473  : 		m_v2View.y = m_v3View.y;

  00045	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _m_v3View$[ebp+4]
  0004a	f3 0f 11 86 18
	08 00 00	 movss	 DWORD PTR [esi+2072], xmm0

; 474  : 
; 475  : 		m_v2Target.x = m_v3Target.x;

  00052	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _m_v3Target$[ebp]
  00057	f3 0f 11 86 1c
	08 00 00	 movss	 DWORD PTR [esi+2076], xmm0

; 476  : 		m_v2Target.y = m_v3Target.y;

  0005f	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _m_v3Target$[ebp+4]
  00064	89 45 f0	 mov	 DWORD PTR _m_v3Target$[ebp+8], eax

; 477  : 
; 478  : 		m_pkDSIVector=pkDSIVector;

  00067	8b 45 08	 mov	 eax, DWORD PTR _pkDSIVector$[ebp]
  0006a	89 4d fc	 mov	 DWORD PTR _m_v3View$[ebp+8], ecx
  0006d	f3 0f 11 86 20
	08 00 00	 movss	 DWORD PTR [esi+2080], xmm0
  00075	89 86 0c 08 00
	00		 mov	 DWORD PTR [esi+2060], eax

; 479  : 		m_dwBlockerCount=0;

  0007b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 480  : 		m_dwBlockerOverCount=0;

  00082	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 481  : 		m_dwInstCount=0;

  00089	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN14@PCBlocker_:

; 482  : 	}

  0008f	8b c6		 mov	 eax, esi
  00091	5e		 pop	 esi
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
??0PCBlocker_SInstanceList@@QAE@PAVPCBlocker_CDynamicSphereInstanceVector@@@Z ENDP ; PCBlocker_SInstanceList::PCBlocker_SInstanceList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ??$ForInRange@UFGetShadowReceiverFromHeightData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromHeightData@@@Z
_TEXT	SEGMENT
_r$ = -24						; size = 12
__$EHRec$ = -12						; size = 12
_p$ = 8							; size = 4
_radius$ = 12						; size = 4
_pFunc$ = 16						; size = 4
??$ForInRange@UFGetShadowReceiverFromHeightData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromHeightData@@@Z PROC ; CCullingManager::ForInRange<FGetShadowReceiverFromHeightData>, COMDAT
; _this$ = ecx

; 112  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$ForInRange@UFGetShadowReceiverFromHeightData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromHeightData@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 16   : 	{}

  00025	8b 45 10	 mov	 eax, DWORD PTR _pFunc$[ebp]
  00028	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], OFFSET ??_7?$RangeTester@UFGetShadowReceiverFromHeightData@@@@6B@
  0002f	89 45 ec	 mov	 DWORD PTR _r$[ebp+4], eax
  00032	c7 45 f0 00 00
	80 bf		 mov	 DWORD PTR _r$[ebp+8], -1082130432 ; bf800000H

; 113  : 		RangeTester<T> r(pFunc);
; 114  : 		m_Factory->RangeTest(p, radius, &r/*this*/);	

  00039	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _radius$[ebp]
  0003e	8d 45 e8	 lea	 eax, DWORD PTR _r$[ebp]
  00041	50		 push	 eax
  00042	51		 push	 ecx
  00043	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00046	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004b	ff 75 08	 push	 DWORD PTR _p$[ebp]
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00055	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest

; 115  : 	}

  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$ForInRange@UFGetShadowReceiverFromHeightData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromHeightData@@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _r$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAE@XZ ; RangeTester<FGetShadowReceiverFromHeightData>::~RangeTester<FGetShadowReceiverFromHeightData>
__ehhandler$??$ForInRange@UFGetShadowReceiverFromHeightData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromHeightData@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$ForInRange@UFGetShadowReceiverFromHeightData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromHeightData@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$ForInRange@UFGetShadowReceiverFromHeightData@@@CCullingManager@@QAEXABVVector3d@@MPAUFGetShadowReceiverFromHeightData@@@Z ENDP ; CCullingManager::ForInRange<FGetShadowReceiverFromHeightData>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ??RFGetShadowReceiverFromHeightData@@QAEXPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_pInstance$ = 8						; size = 4
??RFGetShadowReceiverFromHeightData@@QAEXPAVCGraphicObjectInstance@@@Z PROC ; FGetShadowReceiverFromHeightData::operator(), COMDAT
; _this$ = ecx

; 365  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 366  : 		m_dwCheckCount++;
; 367  : 
; 368  : 		if (!pInstance)

  00007	8b 7d 08	 mov	 edi, DWORD PTR _pInstance$[ebp]
  0000a	ff 46 08	 inc	 DWORD PTR [esi+8]
  0000d	85 ff		 test	 edi, edi
  0000f	0f 84 9c 00 00
	00		 je	 $LN4@operator

; 369  : 			return;
; 370  : 
; 371  : 		if (m_fFromY < 0)

  00015	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  0001a	0f 57 d2	 xorps	 xmm2, xmm2
  0001d	0f 2f d0	 comiss	 xmm2, xmm0
  00020	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  00028	76 08		 jbe	 SHORT $LN6@operator

; 372  : 			m_fFromY = -m_fFromY;

  0002a	0f 57 c1	 xorps	 xmm0, xmm1
  0002d	f3 0f 11 46 14	 movss	 DWORD PTR [esi+20], xmm0
$LN6@operator:

; 373  : 		if (m_fToY < 0)

  00032	f3 0f 10 46 1c	 movss	 xmm0, DWORD PTR [esi+28]
  00037	0f 2f d0	 comiss	 xmm2, xmm0
  0003a	76 08		 jbe	 SHORT $LN5@operator

; 374  : 			m_fToY = -m_fToY;

  0003c	0f 57 c1	 xorps	 xmm0, xmm1
  0003f	f3 0f 11 46 1c	 movss	 DWORD PTR [esi+28], xmm0
$LN5@operator:

; 375  : 		if (pInstance->GetObjectHeight(m_fFromX, m_fFromY, &m_fReturnHeight) ||
; 376  : 			pInstance->GetObjectHeight(m_fToX, m_fToY, &m_fReturnHeight))

  00044	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  00049	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  0004c	50		 push	 eax
  0004d	83 ec 08	 sub	 esp, 8
  00050	8b cf		 mov	 ecx, edi
  00052	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00058	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  0005d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00062	e8 00 00 00 00	 call	 ?GetObjectHeight@CGraphicObjectInstance@@QAE_NMMPAM@Z ; CGraphicObjectInstance::GetObjectHeight
  00067	84 c0		 test	 al, al
  00069	75 27		 jne	 SHORT $LN3@operator
  0006b	f3 0f 10 46 1c	 movss	 xmm0, DWORD PTR [esi+28]
  00070	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  00073	50		 push	 eax
  00074	83 ec 08	 sub	 esp, 8
  00077	8b cf		 mov	 ecx, edi
  00079	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0007f	f3 0f 10 46 18	 movss	 xmm0, DWORD PTR [esi+24]
  00084	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00089	e8 00 00 00 00	 call	 ?GetObjectHeight@CGraphicObjectInstance@@QAE_NMMPAM@Z ; CGraphicObjectInstance::GetObjectHeight
  0008e	84 c0		 test	 al, al
  00090	74 1f		 je	 SHORT $LN4@operator
$LN3@operator:

; 377  : 		{
; 378  : 			if (m_dwCollectCount<COLLECT_MAX)

  00092	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00095	83 f8 64	 cmp	 eax, 100		; 00000064H
  00098	73 11		 jae	 SHORT $LN2@operator

; 379  : 				m_apkShadowReceiver[m_dwCollectCount++]=pInstance;

  0009a	89 7c 86 24	 mov	 DWORD PTR [esi+eax*4+36], edi
  0009e	ff 46 04	 inc	 DWORD PTR [esi+4]
  000a1	5f		 pop	 edi

; 382  : 
; 383  : 			m_bReceiverFound = true;

  000a2	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1
  000a6	5e		 pop	 esi

; 384  : 		}
; 385  : 	}

  000a7	5d		 pop	 ebp
  000a8	c2 04 00	 ret	 4
$LN2@operator:

; 380  : 			else
; 381  : 				m_dwCollectOverCount++;

  000ab	ff 06		 inc	 DWORD PTR [esi]

; 382  : 
; 383  : 			m_bReceiverFound = true;

  000ad	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1
$LN4@operator:
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi

; 384  : 		}
; 385  : 	}

  000b3	5d		 pop	 ebp
  000b4	c2 04 00	 ret	 4
??RFGetShadowReceiverFromHeightData@@QAEXPAVCGraphicObjectInstance@@@Z ENDP ; FGetShadowReceiverFromHeightData::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?GetCollectCount@FGetShadowReceiverFromHeightData@@QAEIXZ
_TEXT	SEGMENT
?GetCollectCount@FGetShadowReceiverFromHeightData@@QAEIXZ PROC ; FGetShadowReceiverFromHeightData::GetCollectCount, COMDAT
; _this$ = ecx

; 361  : 		return m_dwCollectCount;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 362  : 	}

  00003	c3		 ret	 0
?GetCollectCount@FGetShadowReceiverFromHeightData@@QAEIXZ ENDP ; FGetShadowReceiverFromHeightData::GetCollectCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?GetCollectItem@FGetShadowReceiverFromHeightData@@QAEPAVCGraphicObjectInstance@@I@Z
_TEXT	SEGMENT
_uIndex$ = 8						; size = 4
?GetCollectItem@FGetShadowReceiverFromHeightData@@QAEPAVCGraphicObjectInstance@@I@Z PROC ; FGetShadowReceiverFromHeightData::GetCollectItem, COMDAT
; _this$ = ecx

; 352  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 353  : 		if (uIndex>=m_dwCollectCount)

  00003	8b 45 08	 mov	 eax, DWORD PTR _uIndex$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	72 06		 jb	 SHORT $LN1@GetCollect

; 354  : 			return NULL;

  0000b	33 c0		 xor	 eax, eax

; 357  : 	}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
$LN1@GetCollect:

; 355  : 
; 356  : 		return m_apkShadowReceiver[uIndex];

  00011	8b 44 81 24	 mov	 eax, DWORD PTR [ecx+eax*4+36]

; 357  : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?GetCollectItem@FGetShadowReceiverFromHeightData@@QAEPAVCGraphicObjectInstance@@I@Z ENDP ; FGetShadowReceiverFromHeightData::GetCollectItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ??0FGetShadowReceiverFromHeightData@@QAE@MMMM@Z
_TEXT	SEGMENT
_fFromX$ = 8						; size = 4
_fFromY$ = 12						; size = 4
_fToX$ = 16						; size = 4
_fToY$ = 20						; size = 4
??0FGetShadowReceiverFromHeightData@@QAE@MMMM@Z PROC	; FGetShadowReceiverFromHeightData::FGetShadowReceiverFromHeightData, COMDAT
; _this$ = ecx

; 345  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fFromX$[ebp]

; 346  : 		m_dwCheckCount=0;
; 347  : 		m_dwCollectOverCount=0;
; 348  : 		m_dwCollectCount=0;		
; 349  : 	}

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 41 10	 movss	 DWORD PTR [ecx+16], xmm0
  0000f	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fFromY$[ebp]
  00014	f3 0f 11 41 14	 movss	 DWORD PTR [ecx+20], xmm0
  00019	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fToX$[ebp]
  0001e	f3 0f 11 41 18	 movss	 DWORD PTR [ecx+24], xmm0
  00023	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fToY$[ebp]
  00028	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  0002c	f3 0f 11 41 1c	 movss	 DWORD PTR [ecx+28], xmm0
  00031	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00038	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0003e	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00045	5d		 pop	 ebp
  00046	c2 10 00	 ret	 16			; 00000010H
??0FGetShadowReceiverFromHeightData@@QAE@MMMM@Z ENDP	; FGetShadowReceiverFromHeightData::FGetShadowReceiverFromHeightData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ??RFPCBlockerDistanceSort@@QBE_NPAVCGraphicObjectInstance@@0@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
$T2 = -4						; size = 4
$T3 = 8							; size = 4
_plhs$ = 8						; size = 4
_prhs$ = 12						; size = 4
??RFPCBlockerDistanceSort@@QBE_NPAVCGraphicObjectInstance@@0@Z PROC ; FPCBlockerDistanceSort::operator(), COMDAT
; _this$ = ecx

; 197  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _plhs$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _prhs$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00014	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00018	f3 0f 5c 06	 subss	 xmm0, DWORD PTR [esi]
  0001c	f3 0f 11 45 fc	 movss	 DWORD PTR $T2[ebp], xmm0
  00021	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00026	f3 0f 5c 46 04	 subss	 xmm0, DWORD PTR [esi+4]
  0002b	f3 0f 11 45 08	 movss	 DWORD PTR $T3[ebp], xmm0
  00030	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00035	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]
  0003a	f3 0f 11 45 f8	 movss	 DWORD PTR $T1[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  0003f	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00044	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR $T2[ebp]
  00049	f3 0f 10 65 08	 movss	 xmm4, DWORD PTR $T3[ebp]
  0004e	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00052	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00056	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]
  0005b	f3 0f 5c 5e 04	 subss	 xmm3, DWORD PTR [esi+4]
  00060	f3 0f 5c 0e	 subss	 xmm1, DWORD PTR [esi]
  00064	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  00069	33 c0		 xor	 eax, eax
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0006b	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00070	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00074	5e		 pop	 esi
  00075	f3 0f 59 db	 mulss	 xmm3, xmm3
  00079	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0007d	f3 0f 58 e2	 addss	 xmm4, xmm2
  00081	f3 0f 10 55 f8	 movss	 xmm2, DWORD PTR $T1[ebp]
  00086	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0008a	f3 0f 58 d9	 addss	 xmm3, xmm1
  0008e	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00092	f3 0f 58 e2	 addss	 xmm4, xmm2
  00096	f3 0f 58 d8	 addss	 xmm3, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 198  : 		return D3DXVec3LengthSq(&(plhs->GetPosition() - m_v3Eye)) > D3DXVec3LengthSq(&(prhs->GetPosition() - m_v3Eye));

  0009a	0f 2f e3	 comiss	 xmm4, xmm3
  0009d	0f 97 c0	 seta	 al

; 199  : 	}

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c2 08 00	 ret	 8
??RFPCBlockerDistanceSort@@QBE_NPAVCGraphicObjectInstance@@0@Z ENDP ; FPCBlockerDistanceSort::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ??0FPCBlockerDistanceSort@@QAE@AAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_v3Eye$ = 8						; size = 4
??0FPCBlockerDistanceSort@@QAE@AAUD3DXVECTOR3@@@Z PROC	; FPCBlockerDistanceSort::FPCBlockerDistanceSort, COMDAT
; _this$ = ecx

; 194  : 	FPCBlockerDistanceSort(D3DXVECTOR3 & v3Eye) : m_v3Eye(v3Eye) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _v3Eye$[ebp]
  00006	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0000a	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0000e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00011	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00014	8b c1		 mov	 eax, ecx
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0FPCBlockerDistanceSort@@QAE@AAUD3DXVECTOR3@@@Z ENDP	; FPCBlockerDistanceSort::FPCBlockerDistanceSort
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ??RFGetShadowReceiverFromCollisionData@@QAEXPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_pInstance$ = 8						; size = 4
??RFGetShadowReceiverFromCollisionData@@QAEXPAVCGraphicObjectInstance@@@Z PROC ; FGetShadowReceiverFromCollisionData::operator(), COMDAT
; _this$ = ecx

; 175  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 176  : 		if (!pInstance)

  00004	8b 75 08	 mov	 esi, DWORD PTR _pInstance$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	74 47		 je	 SHORT $LN2@operator

; 177  : 			return;
; 178  : 
; 179  : 		if (TREE_OBJECT == pInstance->GetType() || ACTOR_OBJECT == pInstance->GetType() || EFFECT_OBJECT == pInstance->GetType())

  0000e	8b 06		 mov	 eax, DWORD PTR [esi]
  00010	8b ce		 mov	 ecx, esi
  00012	ff 50 04	 call	 DWORD PTR [eax+4]
  00015	3d a6 f7 c9 8a	 cmp	 eax, -1966475354	; 8ac9f7a6H
  0001a	74 39		 je	 SHORT $LN2@operator
  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	8b ce		 mov	 ecx, esi
  00020	ff 50 04	 call	 DWORD PTR [eax+4]
  00023	3d 24 6c a7 29	 cmp	 eax, 698838052		; 29a76c24H
  00028	74 2b		 je	 SHORT $LN2@operator
  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	8b ce		 mov	 ecx, esi
  0002e	ff 50 04	 call	 DWORD PTR [eax+4]
  00031	3d c6 97 fa 1c	 cmp	 eax, 486184902		; 1cfa97c6H
  00036	74 1d		 je	 SHORT $LN2@operator

; 180  : 			return;
; 181  : 		if (pInstance->CollisionDynamicSphere(*m_pdsi))

  00038	ff 77 08	 push	 DWORD PTR [edi+8]
  0003b	8b ce		 mov	 ecx, esi
  0003d	e8 00 00 00 00	 call	 ?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::CollisionDynamicSphere
  00042	84 c0		 test	 al, al
  00044	74 0f		 je	 SHORT $LN2@operator

; 182  : 		{
; 183  : 			m_pkVct_pkShadowReceiver->push_back(pInstance);

  00046	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00049	8d 45 08	 lea	 eax, DWORD PTR _pInstance$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXABQAVCGraphicObjectInstance@@@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::push_back

; 184  : 			m_bCollide = true;

  00052	c6 07 01	 mov	 BYTE PTR [edi], 1
$LN2@operator:
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 185  : 		}
; 186  : 	}

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
??RFGetShadowReceiverFromCollisionData@@QAEXPAVCGraphicObjectInstance@@@Z ENDP ; FGetShadowReceiverFromCollisionData::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ??0FGetShadowReceiverFromCollisionData@@QAE@PAUCDynamicSphereInstance@@PAV?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@Z
_TEXT	SEGMENT
_pdsi$ = 8						; size = 4
_pkVct_pkShadowReceiver$ = 12				; size = 4
??0FGetShadowReceiverFromCollisionData@@QAE@PAUCDynamicSphereInstance@@PAV?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@Z PROC ; FGetShadowReceiverFromCollisionData::FGetShadowReceiverFromCollisionData, COMDAT
; _this$ = ecx

; 170  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 171  : 		m_pkVct_pkShadowReceiver=pkVct_pkShadowReceiver;

  00003	8b 55 0c	 mov	 edx, DWORD PTR _pkVct_pkShadowReceiver$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _pdsi$[ebp]
  00009	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0000c	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0000f	89 51 04	 mov	 DWORD PTR [ecx+4], edx
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 173  : 	}

  00017	8b c1		 mov	 eax, ecx
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
??0FGetShadowReceiverFromCollisionData@@QAE@PAUCDynamicSphereInstance@@PAV?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@Z ENDP ; FGetShadowReceiverFromCollisionData::FGetShadowReceiverFromCollisionData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?End@PCBlocker_CDynamicSphereInstanceVector@@QAEPAUCDynamicSphereInstance@@XZ
_TEXT	SEGMENT
?End@PCBlocker_CDynamicSphereInstanceVector@@QAEPAUCDynamicSphereInstance@@XZ PROC ; PCBlocker_CDynamicSphereInstanceVector::End, COMDAT
; _this$ = ecx

; 36   : 			return m_aDSI+4;

  00000	8d 41 70	 lea	 eax, DWORD PTR [ecx+112]

; 37   : 		}

  00003	c3		 ret	 0
?End@PCBlocker_CDynamicSphereInstanceVector@@QAEPAUCDynamicSphereInstance@@XZ ENDP ; PCBlocker_CDynamicSphereInstanceVector::End
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?Begin@PCBlocker_CDynamicSphereInstanceVector@@QAEPAUCDynamicSphereInstance@@XZ
_TEXT	SEGMENT
?Begin@PCBlocker_CDynamicSphereInstanceVector@@QAEPAUCDynamicSphereInstance@@XZ PROC ; PCBlocker_CDynamicSphereInstanceVector::Begin, COMDAT
; _this$ = ecx

; 32   : 			return m_aDSI+0;

  00000	8b c1		 mov	 eax, ecx

; 33   : 		}

  00002	c3		 ret	 0
?Begin@PCBlocker_CDynamicSphereInstanceVector@@QAEPAUCDynamicSphereInstance@@XZ ENDP ; PCBlocker_CDynamicSphereInstanceVector::Begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ??1PCBlocker_CDynamicSphereInstanceVector@@QAE@XZ
_TEXT	SEGMENT
??1PCBlocker_CDynamicSphereInstanceVector@@QAE@XZ PROC	; PCBlocker_CDynamicSphereInstanceVector::~PCBlocker_CDynamicSphereInstanceVector, COMDAT
; _this$ = ecx

; 28   : 		}

  00000	c3		 ret	 0
??1PCBlocker_CDynamicSphereInstanceVector@@QAE@XZ ENDP	; PCBlocker_CDynamicSphereInstanceVector::~PCBlocker_CDynamicSphereInstanceVector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ??0PCBlocker_CDynamicSphereInstanceVector@@QAE@XZ
_TEXT	SEGMENT
??0PCBlocker_CDynamicSphereInstanceVector@@QAE@XZ PROC	; PCBlocker_CDynamicSphereInstanceVector::PCBlocker_CDynamicSphereInstanceVector, COMDAT
; _this$ = ecx

; 24   : 		{
; 25   : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0PCBlocker_CDynamicSphereInstanceVector@@QAE@XZ ENDP	; PCBlocker_CDynamicSphereInstanceVector::PCBlocker_CDynamicSphereInstanceVector
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::~vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::~vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::allocator<NEffectUpdateDecorator::CRotationDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::allocator<NEffectUpdateDecorator::CRotationDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::~vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::~vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::~vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::~vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::allocator<NEffectUpdateDecorator::CGravityDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::allocator<NEffectUpdateDecorator::CGravityDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::~vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::~vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::~vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::~vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::~vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::~vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::~vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::~vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::allocator<NEffectUpdateDecorator::CNullDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::allocator<NEffectUpdateDecorator::CNullDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::~vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::~vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::~vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::~vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::allocator<NEffectUpdateDecorator::CHeaderDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::allocator<NEffectUpdateDecorator::CHeaderDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::~vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::~vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0FPushAreaToDeleteVector@CMapOutdoor@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0FPushAreaToDeleteVector@CMapOutdoor@@QAE@ABU01@@Z PROC ; CMapOutdoor::FPushAreaToDeleteVector::FPushAreaToDeleteVector, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  0000d	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00011	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00014	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00017	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??0?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CArea *,std::allocator<CArea *> >::vector<CArea *,std::allocator<CArea *> >
  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0FPushAreaToDeleteVector@CMapOutdoor@@QAE@ABU01@@Z ENDP ; CMapOutdoor::FPushAreaToDeleteVector::FPushAreaToDeleteVector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1FPushAreaToDeleteVector@CMapOutdoor@@QAE@XZ
_TEXT	SEGMENT
??1FPushAreaToDeleteVector@CMapOutdoor@@QAE@XZ PROC	; CMapOutdoor::FPushAreaToDeleteVector::~FPushAreaToDeleteVector, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00006	85 c0		 test	 eax, eax
  00008	74 1e		 je	 SHORT $LN5@FPushAreaT
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00013	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 1630 : 			this->_Mylast = pointer();

  0001a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1631 : 			this->_Myend = pointer();

  00021	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN5@FPushAreaT:
  00028	5e		 pop	 esi
  00029	c3		 ret	 0
??1FPushAreaToDeleteVector@CMapOutdoor@@QAE@XZ ENDP	; CMapOutdoor::FPushAreaToDeleteVector::~FPushAreaToDeleteVector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ??RFPushAreaToDeleteVector@CMapOutdoor@@QAEXPAVCArea@@@Z
_TEXT	SEGMENT
_wReferenceCoordY$1$ = -16				; size = 4
_wReferenceCoordX$1$ = -12				; size = 4
_wCoordY$ = -8						; size = 2
_wCoordX$ = -4						; size = 2
_pArea$ = 8						; size = 4
??RFPushAreaToDeleteVector@CMapOutdoor@@QAEXPAVCArea@@@Z PROC ; CMapOutdoor::FPushAreaToDeleteVector::operator(), COMDAT
; _this$ = ecx

; 793  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	56		 push	 esi
; File a:\vs\vc\include\xutility

; 3025 : 	for (; _First != _Last; ++_First)

  0000a	8b 75 08	 mov	 esi, DWORD PTR _pArea$[ebp]
  0000d	57		 push	 edi
; File a:\vs\vc\include\vector

; 396  : 	return (_Iter._Unchecked());

  0000e	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
; File a:\vs\vc\include\xutility

; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

  00011	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 3025 : 	for (; _First != _Last; ++_First)

  00014	3b c2		 cmp	 eax, edx
  00016	74 13		 je	 SHORT $LN134@operator
$LL48@operator:

; 3026 : 		if (*_First == _Val)

  00018	39 30		 cmp	 DWORD PTR [eax], esi
  0001a	74 07		 je	 SHORT $LN131@operator

; 3025 : 	for (; _First != _Last; ++_First)

  0001c	83 c0 04	 add	 eax, 4
  0001f	3b c2		 cmp	 eax, edx
  00021	75 f5		 jne	 SHORT $LL48@operator
$LN131@operator:
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00023	3b c2		 cmp	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 795  : 	if (aIterator != m_ReturnAreaVector.end())

  00025	0f 85 ab 00 00
	00		 jne	 $LN3@operator
$LN134@operator:

; 796  : 		return;
; 797  : 
; 798  : 	WORD wReferenceCoordX = m_CurCoordinate.m_sTerrainCoordX;

  0002b	0f b7 43 08	 movzx	 eax, WORD PTR [ebx+8]

; 799  : 	WORD wReferenceCoordY = m_CurCoordinate.m_sTerrainCoordY;
; 800  : 	
; 801  : 	WORD wCoordX, wCoordY;
; 802  : 	pArea->GetCoordinate(&wCoordX, &wCoordY);

  0002f	8b ce		 mov	 ecx, esi
  00031	89 45 f4	 mov	 DWORD PTR _wReferenceCoordX$1$[ebp], eax
  00034	0f b7 43 0a	 movzx	 eax, WORD PTR [ebx+10]
  00038	89 45 f0	 mov	 DWORD PTR _wReferenceCoordY$1$[ebp], eax
  0003b	8d 45 f8	 lea	 eax, DWORD PTR _wCoordY$[ebp]
  0003e	50		 push	 eax
  0003f	8d 45 fc	 lea	 eax, DWORD PTR _wCoordX$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?GetCoordinate@CArea@@QAEXPAG0@Z ; CArea::GetCoordinate

; 803  : 	
; 804  : 	switch(m_eLRDeleteDir)

  00048	8b 03		 mov	 eax, DWORD PTR [ebx]
  0004a	83 e8 00	 sub	 eax, 0
  0004d	74 14		 je	 SHORT $LN11@operator
  0004f	48		 dec	 eax
  00050	75 2f		 jne	 SHORT $LN10@operator

; 809  : 		break;
; 810  : 	case DELETE_RIGHT:
; 811  : 		if (wCoordX > wReferenceCoordX + LOAD_SIZE_WIDTH)

  00052	8b 45 f4	 mov	 eax, DWORD PTR _wReferenceCoordX$1$[ebp]
  00055	0f b7 c8	 movzx	 ecx, ax
  00058	0f b7 45 fc	 movzx	 eax, WORD PTR _wCoordX$[ebp]
  0005c	41		 inc	 ecx
  0005d	3b c1		 cmp	 eax, ecx
  0005f	7e 20		 jle	 SHORT $LN10@operator

; 812  : 			m_ReturnAreaVector.push_back(pArea);
; 813  : 		break;

  00061	eb 0f		 jmp	 SHORT $LN135@operator
$LN11@operator:

; 805  : 	{
; 806  : 	case DELETE_LEFT:
; 807  : 		if (wCoordX < wReferenceCoordX - LOAD_SIZE_WIDTH)

  00063	8b 45 f4	 mov	 eax, DWORD PTR _wReferenceCoordX$1$[ebp]
  00066	0f b7 c8	 movzx	 ecx, ax
  00069	0f b7 45 fc	 movzx	 eax, WORD PTR _wCoordX$[ebp]
  0006d	49		 dec	 ecx
  0006e	3b c1		 cmp	 eax, ecx
  00070	7d 0f		 jge	 SHORT $LN10@operator
$LN135@operator:

; 808  : 			m_ReturnAreaVector.push_back(pArea);

  00072	8d 45 08	 lea	 eax, DWORD PTR _pArea$[ebp]
  00075	50		 push	 eax
  00076	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  00079	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXABQAVCArea@@@Z ; std::vector<CArea *,std::allocator<CArea *> >::push_back
  0007e	8b 75 08	 mov	 esi, DWORD PTR _pArea$[ebp]
$LN10@operator:
; File a:\vs\vc\include\vector

; 396  : 	return (_Iter._Unchecked());

  00081	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
; File a:\vs\vc\include\xutility

; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

  00084	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 3025 : 	for (; _First != _Last; ++_First)

  00087	3b c1		 cmp	 eax, ecx
  00089	74 14		 je	 SHORT $LN137@operator
  0008b	eb 03 8d 49 00	 npad	 5
$LL100@operator:

; 3026 : 		if (*_First == _Val)

  00090	39 30		 cmp	 DWORD PTR [eax], esi
  00092	74 07		 je	 SHORT $LN132@operator

; 3025 : 	for (; _First != _Last; ++_First)

  00094	83 c0 04	 add	 eax, 4
  00097	3b c1		 cmp	 eax, ecx
  00099	75 f5		 jne	 SHORT $LL100@operator
$LN132@operator:
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0009b	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 817  : 	if (aIterator != m_ReturnAreaVector.end())

  0009d	75 37		 jne	 SHORT $LN3@operator
$LN137@operator:

; 818  : 		return;
; 819  : 
; 820  : 	switch(m_eTBDeleteDir)

  0009f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000a2	83 e8 02	 sub	 eax, 2
  000a5	74 14		 je	 SHORT $LN4@operator
  000a7	48		 dec	 eax
  000a8	75 2c		 jne	 SHORT $LN3@operator

; 825  : 		break;
; 826  : 	case DELETE_BOTTOM:
; 827  : 		if (wCoordY > wReferenceCoordY + LOAD_SIZE_WIDTH)

  000aa	8b 45 f0	 mov	 eax, DWORD PTR _wReferenceCoordY$1$[ebp]
  000ad	0f b7 d0	 movzx	 edx, ax
  000b0	0f b7 45 f8	 movzx	 eax, WORD PTR _wCoordY$[ebp]
  000b4	42		 inc	 edx
  000b5	3b c2		 cmp	 eax, edx
  000b7	7e 1d		 jle	 SHORT $LN3@operator

; 828  : 			m_ReturnAreaVector.push_back(pArea);
; 829  : 		break;

  000b9	eb 0f		 jmp	 SHORT $LN138@operator
$LN4@operator:

; 821  : 	{
; 822  : 	case DELETE_TOP:
; 823  : 		if (wCoordY < wReferenceCoordY - LOAD_SIZE_WIDTH)

  000bb	8b 45 f0	 mov	 eax, DWORD PTR _wReferenceCoordY$1$[ebp]
  000be	0f b7 c8	 movzx	 ecx, ax
  000c1	0f b7 45 f8	 movzx	 eax, WORD PTR _wCoordY$[ebp]
  000c5	49		 dec	 ecx
  000c6	3b c1		 cmp	 eax, ecx
  000c8	7d 0c		 jge	 SHORT $LN3@operator
$LN138@operator:

; 824  : 			m_ReturnAreaVector.push_back(pArea);

  000ca	8d 45 08	 lea	 eax, DWORD PTR _pArea$[ebp]
  000cd	50		 push	 eax
  000ce	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  000d1	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXABQAVCArea@@@Z ; std::vector<CArea *,std::allocator<CArea *> >::push_back
$LN3@operator:
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx

; 830  : 	}
; 831  : }

  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 04 00	 ret	 4
??RFPushAreaToDeleteVector@CMapOutdoor@@QAEXPAVCArea@@@Z ENDP ; CMapOutdoor::FPushAreaToDeleteVector::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
;	COMDAT ??0FPushAreaToDeleteVector@CMapOutdoor@@QAE@W4EDeleteDir@FPushToDeleteVector@1@0USOutdoorMapCoordinate@@@Z
_TEXT	SEGMENT
_eLRDeleteDir$ = 8					; size = 4
_eTBDeleteDir$ = 12					; size = 4
_CurCoord$ = 16						; size = 4
??0FPushAreaToDeleteVector@CMapOutdoor@@QAE@W4EDeleteDir@FPushToDeleteVector@1@0USOutdoorMapCoordinate@@@Z PROC ; CMapOutdoor::FPushAreaToDeleteVector::FPushAreaToDeleteVector, COMDAT
; _this$ = ecx

; 537  : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 512  : 				m_eLRDeleteDir = eLRDeleteDir;

  00003	8b 45 08	 mov	 eax, DWORD PTR _eLRDeleteDir$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 513  : 				m_eTBDeleteDir = eTBDeleteDir;

  00008	8b 45 0c	 mov	 eax, DWORD PTR _eTBDeleteDir$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 514  : 				m_CurCoordinate = CurCoord;

  0000e	8b 45 10	 mov	 eax, DWORD PTR _CurCoord$[ebp]
  00011	89 41 08	 mov	 DWORD PTR [ecx+8], eax
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00014	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 483  : 		_Mylast = pointer();

  0001b	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 484  : 		_Myend = pointer();

  00022	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00029	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0002c	89 41 10	 mov	 DWORD PTR [ecx+16], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 539  : 			}

  0002f	8b c1		 mov	 eax, ecx
  00031	5d		 pop	 ebp
  00032	c2 0c 00	 ret	 12			; 0000000cH
??0FPushAreaToDeleteVector@CMapOutdoor@@QAE@W4EDeleteDir@FPushToDeleteVector@1@0USOutdoorMapCoordinate@@@Z ENDP ; CMapOutdoor::FPushAreaToDeleteVector::FPushAreaToDeleteVector
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0FPushTerrainToDeleteVector@CMapOutdoor@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0FPushTerrainToDeleteVector@CMapOutdoor@@QAE@ABU01@@Z PROC ; CMapOutdoor::FPushTerrainToDeleteVector::FPushTerrainToDeleteVector, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  0000d	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00011	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00014	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00017	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??0?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::vector<CTerrain *,std::allocator<CTerrain *> >
  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0FPushTerrainToDeleteVector@CMapOutdoor@@QAE@ABU01@@Z ENDP ; CMapOutdoor::FPushTerrainToDeleteVector::FPushTerrainToDeleteVector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1FPushTerrainToDeleteVector@CMapOutdoor@@QAE@XZ
_TEXT	SEGMENT
??1FPushTerrainToDeleteVector@CMapOutdoor@@QAE@XZ PROC	; CMapOutdoor::FPushTerrainToDeleteVector::~FPushTerrainToDeleteVector, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00006	85 c0		 test	 eax, eax
  00008	74 1e		 je	 SHORT $LN5@FPushTerra
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00013	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 1630 : 			this->_Mylast = pointer();

  0001a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1631 : 			this->_Myend = pointer();

  00021	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN5@FPushTerra:
  00028	5e		 pop	 esi
  00029	c3		 ret	 0
??1FPushTerrainToDeleteVector@CMapOutdoor@@QAE@XZ ENDP	; CMapOutdoor::FPushTerrainToDeleteVector::~FPushTerrainToDeleteVector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\areaterrain.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\areaterrain.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ??RFPushTerrainToDeleteVector@CMapOutdoor@@QAEXPAVCTerrain@@@Z
_TEXT	SEGMENT
_wCoordY$1$ = -8					; size = 4
_wReferenceCoordY$1$ = -4				; size = 4
_pTerrain$ = 8						; size = 4
??RFPushTerrainToDeleteVector@CMapOutdoor@@QAEXPAVCTerrain@@@Z PROC ; CMapOutdoor::FPushTerrainToDeleteVector::operator(), COMDAT
; _this$ = ecx

; 751  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 3025 : 	for (; _First != _Last; ++_First)

  00003	8b 55 08	 mov	 edx, DWORD PTR _pTerrain$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 751  : {

  00006	83 ec 08	 sub	 esp, 8
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
; File a:\vs\vc\include\vector

; 396  : 	return (_Iter._Unchecked());

  0000e	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]
; File a:\vs\vc\include\xutility

; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

  00011	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 3025 : 	for (; _First != _Last; ++_First)

  00014	3b c6		 cmp	 eax, esi
  00016	74 13		 je	 SHORT $LN136@operator
$LL48@operator:

; 3026 : 		if (*_First == _Val)

  00018	39 10		 cmp	 DWORD PTR [eax], edx
  0001a	74 07		 je	 SHORT $LN133@operator

; 3025 : 	for (; _First != _Last; ++_First)

  0001c	83 c0 04	 add	 eax, 4
  0001f	3b c6		 cmp	 eax, esi
  00021	75 f5		 jne	 SHORT $LL48@operator
$LN133@operator:
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00023	3b c6		 cmp	 eax, esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 753  : 	if (aIterator != m_ReturnTerrainVector.end())

  00025	0f 85 95 00 00
	00		 jne	 $LN3@operator
$LN136@operator:

; 757  : 	WORD wReferenceCoordY = m_CurCoordinate.m_sTerrainCoordY;

  0002b	0f b7 43 0a	 movzx	 eax, WORD PTR [ebx+10]
  0002f	0f b7 4b 08	 movzx	 ecx, WORD PTR [ebx+8]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\areaterrain.h

; 92   : 			*usCoordX = m_wX;

  00033	0f b7 b2 6c a5
	06 00		 movzx	 esi, WORD PTR [edx+435564]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 757  : 	WORD wReferenceCoordY = m_CurCoordinate.m_sTerrainCoordY;

  0003a	89 45 fc	 mov	 DWORD PTR _wReferenceCoordY$1$[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\areaterrain.h

; 93   : 			*usCoordY = m_wY;

  0003d	0f b7 82 6e a5
	06 00		 movzx	 eax, WORD PTR [edx+435566]
  00044	89 45 f8	 mov	 DWORD PTR _wCoordY$1$[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 763  : 	switch(m_eLRDeleteDir)

  00047	8b 03		 mov	 eax, DWORD PTR [ebx]
  00049	83 e8 00	 sub	 eax, 0
  0004c	74 0a		 je	 SHORT $LN11@operator
  0004e	48		 dec	 eax
  0004f	75 1b		 jne	 SHORT $LN10@operator

; 768  : 		break;
; 769  : 	case DELETE_RIGHT:
; 770  : 		if (wCoordX > wReferenceCoordX + LOAD_SIZE_WIDTH)

  00051	41		 inc	 ecx
  00052	3b f1		 cmp	 esi, ecx
  00054	7e 16		 jle	 SHORT $LN10@operator

; 771  : 			m_ReturnTerrainVector.push_back(pTerrain);
; 772  : 		break;

  00056	eb 05		 jmp	 SHORT $LN137@operator
$LN11@operator:

; 764  : 	{
; 765  : 	case DELETE_LEFT:
; 766  : 		if (wCoordX < wReferenceCoordX - LOAD_SIZE_WIDTH)

  00058	49		 dec	 ecx
  00059	3b f1		 cmp	 esi, ecx
  0005b	7d 0f		 jge	 SHORT $LN10@operator
$LN137@operator:

; 767  : 			m_ReturnTerrainVector.push_back(pTerrain);

  0005d	8d 45 08	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00060	50		 push	 eax
  00061	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  00064	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXABQAVCTerrain@@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::push_back
  00069	8b 55 08	 mov	 edx, DWORD PTR _pTerrain$[ebp]
$LN10@operator:
; File a:\vs\vc\include\vector

; 396  : 	return (_Iter._Unchecked());

  0006c	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
; File a:\vs\vc\include\xutility

; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

  0006f	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 3025 : 	for (; _First != _Last; ++_First)

  00072	3b c1		 cmp	 eax, ecx
  00074	74 0f		 je	 SHORT $LN139@operator
$LL102@operator:

; 3026 : 		if (*_First == _Val)

  00076	39 10		 cmp	 DWORD PTR [eax], edx
  00078	74 07		 je	 SHORT $LN134@operator

; 3025 : 	for (; _First != _Last; ++_First)

  0007a	83 c0 04	 add	 eax, 4
  0007d	3b c1		 cmp	 eax, ecx
  0007f	75 f5		 jne	 SHORT $LL102@operator
$LN134@operator:
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00081	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 776  : 	if (aIterator != m_ReturnTerrainVector.end())

  00083	75 3b		 jne	 SHORT $LN3@operator
$LN139@operator:

; 777  : 		return;
; 778  : 
; 779  : 	switch(m_eTBDeleteDir)

  00085	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00088	83 e8 02	 sub	 eax, 2
  0008b	74 16		 je	 SHORT $LN4@operator
  0008d	48		 dec	 eax
  0008e	75 30		 jne	 SHORT $LN3@operator

; 784  : 		break;
; 785  : 	case DELETE_BOTTOM:
; 786  : 		if (wCoordY > wReferenceCoordY + LOAD_SIZE_WIDTH)

  00090	8b 45 fc	 mov	 eax, DWORD PTR _wReferenceCoordY$1$[ebp]
  00093	0f b7 d0	 movzx	 edx, ax
  00096	8b 45 f8	 mov	 eax, DWORD PTR _wCoordY$1$[ebp]
  00099	42		 inc	 edx
  0009a	0f b7 c0	 movzx	 eax, ax
  0009d	3b c2		 cmp	 eax, edx
  0009f	7e 1f		 jle	 SHORT $LN3@operator

; 787  : 			m_ReturnTerrainVector.push_back(pTerrain);
; 788  : 		break;

  000a1	eb 11		 jmp	 SHORT $LN140@operator
$LN4@operator:

; 780  : 	{
; 781  : 	case DELETE_TOP:
; 782  : 		if (wCoordY < wReferenceCoordY - LOAD_SIZE_WIDTH)

  000a3	8b 45 fc	 mov	 eax, DWORD PTR _wReferenceCoordY$1$[ebp]
  000a6	0f b7 c8	 movzx	 ecx, ax
  000a9	8b 45 f8	 mov	 eax, DWORD PTR _wCoordY$1$[ebp]
  000ac	49		 dec	 ecx
  000ad	0f b7 c0	 movzx	 eax, ax
  000b0	3b c1		 cmp	 eax, ecx
  000b2	7d 0c		 jge	 SHORT $LN3@operator
$LN140@operator:

; 783  : 			m_ReturnTerrainVector.push_back(pTerrain);

  000b4	8d 45 08	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  000b7	50		 push	 eax
  000b8	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  000bb	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXABQAVCTerrain@@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::push_back
$LN3@operator:
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx

; 789  : 	}
; 790  : }

  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c2 04 00	 ret	 4
??RFPushTerrainToDeleteVector@CMapOutdoor@@QAEXPAVCTerrain@@@Z ENDP ; CMapOutdoor::FPushTerrainToDeleteVector::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
;	COMDAT ??0FPushTerrainToDeleteVector@CMapOutdoor@@QAE@W4EDeleteDir@FPushToDeleteVector@1@0USOutdoorMapCoordinate@@@Z
_TEXT	SEGMENT
_eLRDeleteDir$ = 8					; size = 4
_eTBDeleteDir$ = 12					; size = 4
_CurCoord$ = 16						; size = 4
??0FPushTerrainToDeleteVector@CMapOutdoor@@QAE@W4EDeleteDir@FPushToDeleteVector@1@0USOutdoorMapCoordinate@@@Z PROC ; CMapOutdoor::FPushTerrainToDeleteVector::FPushTerrainToDeleteVector, COMDAT
; _this$ = ecx

; 524  : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 512  : 				m_eLRDeleteDir = eLRDeleteDir;

  00003	8b 45 08	 mov	 eax, DWORD PTR _eLRDeleteDir$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 513  : 				m_eTBDeleteDir = eTBDeleteDir;

  00008	8b 45 0c	 mov	 eax, DWORD PTR _eTBDeleteDir$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 514  : 				m_CurCoordinate = CurCoord;

  0000e	8b 45 10	 mov	 eax, DWORD PTR _CurCoord$[ebp]
  00011	89 41 08	 mov	 DWORD PTR [ecx+8], eax
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00014	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 483  : 		_Mylast = pointer();

  0001b	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 484  : 		_Myend = pointer();

  00022	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00029	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0002c	89 41 10	 mov	 DWORD PTR [ecx+16], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 526  : 			}

  0002f	8b c1		 mov	 eax, ecx
  00031	5d		 pop	 ebp
  00032	c2 0c 00	 ret	 12			; 0000000cH
??0FPushTerrainToDeleteVector@CMapOutdoor@@QAE@W4EDeleteDir@FPushToDeleteVector@1@0USOutdoorMapCoordinate@@@Z ENDP ; CMapOutdoor::FPushTerrainToDeleteVector::FPushTerrainToDeleteVector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
;	COMDAT ??0FPushToDeleteVector@CMapOutdoor@@QAE@W4EDeleteDir@01@0USOutdoorMapCoordinate@@@Z
_TEXT	SEGMENT
_eLRDeleteDir$ = 8					; size = 4
_eTBDeleteDir$ = 12					; size = 4
_CurCoord$ = 16						; size = 4
??0FPushToDeleteVector@CMapOutdoor@@QAE@W4EDeleteDir@01@0USOutdoorMapCoordinate@@@Z PROC ; CMapOutdoor::FPushToDeleteVector::FPushToDeleteVector, COMDAT
; _this$ = ecx

; 510  : 			FPushToDeleteVector(EDeleteDir eLRDeleteDir, EDeleteDir eTBDeleteDir, TOutdoorMapCoordinate CurCoord)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 511  : 			{
; 512  : 				m_eLRDeleteDir = eLRDeleteDir;

  00003	8b 45 08	 mov	 eax, DWORD PTR _eLRDeleteDir$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 513  : 				m_eTBDeleteDir = eTBDeleteDir;

  00008	8b 45 0c	 mov	 eax, DWORD PTR _eTBDeleteDir$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 514  : 				m_CurCoordinate = CurCoord;

  0000e	8b 45 10	 mov	 eax, DWORD PTR _CurCoord$[ebp]
  00011	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 515  : 			}

  00014	8b c1		 mov	 eax, ecx
  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
??0FPushToDeleteVector@CMapOutdoor@@QAE@W4EDeleteDir@01@0USOutdoorMapCoordinate@@@Z ENDP ; CMapOutdoor::FPushToDeleteVector::FPushToDeleteVector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator++, COMDAT
; _this$ = ecx

; 112  : 		++this->_Ptr;

  00000	83 01 04	 add	 DWORD PTR [ecx], 4

; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 336  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEAAPAVCArea@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEAAPAVCArea@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEAAPAVCArea@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEPAPAVCArea@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEPAPAVCArea@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEPAPAVCArea@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAEAAV12@PAPAVCArea@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAEAAV12@PAPAVCArea@@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Rechecked, COMDAT
; _this$ = ecx

; 312  : 		{	// reset from unchecked iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		this->_Ptr = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 314  : 		return (*this);

  00008	8b c1		 mov	 eax, ecx

; 315  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAEAAV12@PAPAVCArea@@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAE@PAPAVCArea@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAE@PAPAVCArea@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAE@PAPAVCArea@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 211  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 206  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  00000	83 01 04	 add	 DWORD PTR [ecx], 4

; 113  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 114  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEABQAVCArea@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEABQAVCArea@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEABQAVCArea@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEPBQAVCArea@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEPBQAVCArea@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 61   : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 62   : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QBEPBQAVCArea@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAE@PAPAVCArea@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAE@PAPAVCArea@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@QAE@PAPAVCArea@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator++, COMDAT
; _this$ = ecx

; 112  : 		++this->_Ptr;

  00000	83 01 04	 add	 DWORD PTR [ecx], 4

; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 336  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEAAPAVCTerrain@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEAAPAVCTerrain@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEAAPAVCTerrain@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEPAPAVCTerrain@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEPAPAVCTerrain@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEPAPAVCTerrain@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAEAAV12@PAPAVCTerrain@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAEAAV12@PAPAVCTerrain@@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Rechecked, COMDAT
; _this$ = ecx

; 312  : 		{	// reset from unchecked iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		this->_Ptr = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 314  : 		return (*this);

  00008	8b c1		 mov	 eax, ecx

; 315  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAEAAV12@PAPAVCTerrain@@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAE@PAPAVCTerrain@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAE@PAPAVCTerrain@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAE@PAPAVCTerrain@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 211  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 206  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  00000	83 01 04	 add	 DWORD PTR [ecx], 4

; 113  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 114  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEABQAVCTerrain@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEABQAVCTerrain@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEABQAVCTerrain@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEPBQAVCTerrain@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEPBQAVCTerrain@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 61   : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 62   : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QBEPBQAVCTerrain@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAE@PAPAVCTerrain@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAE@PAPAVCTerrain@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@QAE@PAPAVCTerrain@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?UpdateQuadTreeHeights@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_Node$ = 8						; size = 4
?UpdateQuadTreeHeights@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@@Z PROC ; CMapOutdoor::UpdateQuadTreeHeights, COMDAT
; _this$ = ecx

; 1067 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	8b d1		 mov	 edx, ecx
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1068 : 	// Inserted by levites
; 1069 : 	assert(NULL!=m_pTerrainPatchProxyList && "CMapOutdoor::UpdateQuadTreeHeights");
; 1070 : 	if (!m_pTerrainPatchProxyList)

  0000c	8b 72 64	 mov	 esi, DWORD PTR [edx+100]
  0000f	89 54 24 0c	 mov	 DWORD PTR _this$1$[esp+16], edx
  00013	85 f6		 test	 esi, esi
  00015	0f 84 ba 01 00
	00		 je	 $LN114@UpdateQuad

; 1089 : 		{
; 1090 : 			long patch = y * m_wPatchCount + x;

  0001b	f3 0f 10 3d 00
	00 00 00	 movss	 xmm7, DWORD PTR __real@3f000000
  00023	8b 5d 08	 mov	 ebx, DWORD PTR _Node$[ebp]
$LL100@UpdateQuad:

; 1071 : 		return;
; 1072 : 	
; 1073 : 	float minx, maxx, miny, maxy, minz, maxz;
; 1074 : 	minx = maxx = miny = maxy = minz = maxz = 0;
; 1075 : 
; 1076 : 	if (m_pTerrainPatchProxyList[Node->PatchNum].isUsed())

  00026	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  00029	0f 57 d2	 xorps	 xmm2, xmm2
  0002c	0f 57 e4	 xorps	 xmm4, xmm4
  0002f	0f 57 db	 xorps	 xmm3, xmm3
  00032	0f 57 ed	 xorps	 xmm5, xmm5
  00035	0f 57 c9	 xorps	 xmm1, xmm1
  00038	0f 57 f6	 xorps	 xmm6, xmm6
  0003b	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00042	2b c8		 sub	 ecx, eax
  00044	80 7c 8e 04 00	 cmp	 BYTE PTR [esi+ecx*4+4], 0
  00049	74 21		 je	 SHORT $LN18@UpdateQuad
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 64   : 	float GetMinX()											{ return m_fMinX; }

  0004b	8b 44 8e 0c	 mov	 eax, DWORD PTR [esi+ecx*4+12]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1078 : 		minx = m_pTerrainPatchProxyList[Node->PatchNum].GetMinX();

  0004f	f3 0f 10 30	 movss	 xmm6, DWORD PTR [eax]

; 1079 : 		maxx = m_pTerrainPatchProxyList[Node->PatchNum].GetMaxX();

  00053	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]

; 1080 : 		miny = m_pTerrainPatchProxyList[Node->PatchNum].GetMinY();

  00058	f3 0f 10 68 08	 movss	 xmm5, DWORD PTR [eax+8]

; 1081 : 		maxy = m_pTerrainPatchProxyList[Node->PatchNum].GetMaxY();

  0005d	f3 0f 10 58 0c	 movss	 xmm3, DWORD PTR [eax+12]

; 1082 : 		minz = m_pTerrainPatchProxyList[Node->PatchNum].GetMinZ();

  00062	f3 0f 10 60 10	 movss	 xmm4, DWORD PTR [eax+16]

; 1083 : 		maxz = m_pTerrainPatchProxyList[Node->PatchNum].GetMaxZ();

  00067	f3 0f 10 50 14	 movss	 xmm2, DWORD PTR [eax+20]
$LN18@UpdateQuad:

; 1084 : 	}
; 1085 : 	
; 1086 : 	for (long y = Node->y0; y <= Node->y1; y++)

  0006c	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  0006f	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00072	3b f8		 cmp	 edi, eax
  00074	0f 8f 9f 00 00
	00		 jg	 $LN15@UpdateQuad

; 1087 : 	{
; 1088 : 		for (long x = Node->x0; x <= Node->x1; x++)

  0007a	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0007d	8d 49 00	 npad	 3
$LL17@UpdateQuad:
  00080	3b 4b 0c	 cmp	 ecx, DWORD PTR [ebx+12]
  00083	0f 8f 87 00 00
	00		 jg	 $LN16@UpdateQuad

; 1089 : 		{
; 1090 : 			long patch = y * m_wPatchCount + x;

  00089	0f b7 82 8c 00
	00 00		 movzx	 eax, WORD PTR [edx+140]
  00090	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  00093	2b 53 04	 sub	 edx, DWORD PTR [ebx+4]
  00096	0f af c7	 imul	 eax, edi
  00099	03 c1		 add	 eax, ecx
  0009b	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  000a2	2b c8		 sub	 ecx, eax
  000a4	c1 e1 02	 shl	 ecx, 2
  000a7	42		 inc	 edx
$LL14@UpdateQuad:

; 1091 : 
; 1092 : 			if (!m_pTerrainPatchProxyList[patch].isUsed())

  000a8	80 7c 31 04 00	 cmp	 BYTE PTR [ecx+esi+4], 0
  000ad	74 51		 je	 SHORT $LN13@UpdateQuad
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 64   : 	float GetMinX()											{ return m_fMinX; }

  000af	8b 44 31 0c	 mov	 eax, DWORD PTR [ecx+esi+12]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1095 : 			if (m_pTerrainPatchProxyList[patch].GetMinX() < minx)

  000b3	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000b7	0f 2f f0	 comiss	 xmm6, xmm0
  000ba	76 03		 jbe	 SHORT $LN10@UpdateQuad

; 1096 : 				minx = m_pTerrainPatchProxyList[patch].GetMinX();

  000bc	0f 28 f0	 movaps	 xmm6, xmm0
$LN10@UpdateQuad:

; 1097 : 			if (m_pTerrainPatchProxyList[patch].GetMaxX() > maxx)

  000bf	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000c4	0f 2f c1	 comiss	 xmm0, xmm1
  000c7	76 03		 jbe	 SHORT $LN9@UpdateQuad

; 1098 : 				maxx = m_pTerrainPatchProxyList[patch].GetMaxX();

  000c9	0f 28 c8	 movaps	 xmm1, xmm0
$LN9@UpdateQuad:

; 1099 : 			
; 1100 : 			if (m_pTerrainPatchProxyList[patch].GetMinY() < miny)

  000cc	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000d1	0f 2f e8	 comiss	 xmm5, xmm0
  000d4	76 03		 jbe	 SHORT $LN8@UpdateQuad

; 1101 : 				miny = m_pTerrainPatchProxyList[patch].GetMinY();

  000d6	0f 28 e8	 movaps	 xmm5, xmm0
$LN8@UpdateQuad:

; 1102 : 			if (m_pTerrainPatchProxyList[patch].GetMaxY() > maxy)

  000d9	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  000de	0f 2f c3	 comiss	 xmm0, xmm3
  000e1	76 03		 jbe	 SHORT $LN7@UpdateQuad

; 1103 : 				maxy = m_pTerrainPatchProxyList[patch].GetMaxY();

  000e3	0f 28 d8	 movaps	 xmm3, xmm0
$LN7@UpdateQuad:

; 1104 : 			
; 1105 : 			if (m_pTerrainPatchProxyList[patch].GetMinZ() < minz)

  000e6	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  000eb	0f 2f e0	 comiss	 xmm4, xmm0
  000ee	76 03		 jbe	 SHORT $LN6@UpdateQuad

; 1106 : 				minz = m_pTerrainPatchProxyList[patch].GetMinZ();

  000f0	0f 28 e0	 movaps	 xmm4, xmm0
$LN6@UpdateQuad:

; 1107 : 			if (m_pTerrainPatchProxyList[patch].GetMaxZ() > maxz)

  000f3	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  000f8	0f 2f c2	 comiss	 xmm0, xmm2
  000fb	76 03		 jbe	 SHORT $LN13@UpdateQuad

; 1108 : 				maxz = m_pTerrainPatchProxyList[patch].GetMaxZ();

  000fd	0f 28 d0	 movaps	 xmm2, xmm0
$LN13@UpdateQuad:

; 1087 : 	{
; 1088 : 		for (long x = Node->x0; x <= Node->x1; x++)

  00100	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00103	4a		 dec	 edx
  00104	75 a2		 jne	 SHORT $LL14@UpdateQuad
  00106	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00109	8b 54 24 0c	 mov	 edx, DWORD PTR _this$1$[esp+16]
  0010d	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
$LN16@UpdateQuad:

; 1084 : 	}
; 1085 : 	
; 1086 : 	for (long y = Node->y0; y <= Node->y1; y++)

  00110	47		 inc	 edi
  00111	3b f8		 cmp	 edi, eax
  00113	0f 8e 67 ff ff
	ff		 jle	 $LL17@UpdateQuad
$LN15@UpdateQuad:

; 1109 : 		}      
; 1110 : 	}
; 1111 : 	
; 1112 : 	Node->center.x = (maxx + minx) * 0.5f;

  00119	0f 28 c1	 movaps	 xmm0, xmm1

; 1118 : 		(maxz-minz)*(maxz-minz)) / 2.0f;

  0011c	f3 0f 5c ce	 subss	 xmm1, xmm6
  00120	f3 0f 58 c6	 addss	 xmm0, xmm6
  00124	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00128	f3 0f 59 c7	 mulss	 xmm0, xmm7
  0012c	f3 0f 11 43 2c	 movss	 DWORD PTR [ebx+44], xmm0
  00131	0f 28 c3	 movaps	 xmm0, xmm3
  00134	f3 0f 58 c5	 addss	 xmm0, xmm5
  00138	f3 0f 5c dd	 subss	 xmm3, xmm5
  0013c	f3 0f 59 c7	 mulss	 xmm0, xmm7
  00140	f3 0f 59 db	 mulss	 xmm3, xmm3
  00144	f3 0f 11 43 30	 movss	 DWORD PTR [ebx+48], xmm0
  00149	0f 28 c2	 movaps	 xmm0, xmm2
  0014c	f3 0f 5c d4	 subss	 xmm2, xmm4
  00150	f3 0f 58 c4	 addss	 xmm0, xmm4
  00154	f3 0f 58 cb	 addss	 xmm1, xmm3
  00158	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0015c	f3 0f 59 c7	 mulss	 xmm0, xmm7
  00160	f3 0f 58 ca	 addss	 xmm1, xmm2
  00164	f3 0f 11 43 34	 movss	 DWORD PTR [ebx+52], xmm0
  00169	0f 57 c0	 xorps	 xmm0, xmm0
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  0016c	f3 0f 5a c1	 cvtss2sd xmm0, xmm1
  00170	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1120 : 	if (Node->NW_Node != NULL)

  00175	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]

; 1121 : 		UpdateQuadTreeHeights(Node->NW_Node);

  00178	8b 74 24 0c	 mov	 esi, DWORD PTR _this$1$[esp+16]
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  0017c	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1118 : 		(maxz-minz)*(maxz-minz)) / 2.0f;

  00180	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00188	f3 0f 11 43 38	 movss	 DWORD PTR [ebx+56], xmm0

; 1120 : 	if (Node->NW_Node != NULL)

  0018d	85 c0		 test	 eax, eax
  0018f	74 08		 je	 SHORT $LN4@UpdateQuad

; 1121 : 		UpdateQuadTreeHeights(Node->NW_Node);

  00191	50		 push	 eax
  00192	8b ce		 mov	 ecx, esi
  00194	e8 00 00 00 00	 call	 ?UpdateQuadTreeHeights@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@@Z ; CMapOutdoor::UpdateQuadTreeHeights
$LN4@UpdateQuad:

; 1122 : 	
; 1123 : 	if (Node->NE_Node != NULL)

  00199	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  0019c	85 c0		 test	 eax, eax
  0019e	74 08		 je	 SHORT $LN3@UpdateQuad

; 1124 : 		UpdateQuadTreeHeights(Node->NE_Node);

  001a0	50		 push	 eax
  001a1	8b ce		 mov	 ecx, esi
  001a3	e8 00 00 00 00	 call	 ?UpdateQuadTreeHeights@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@@Z ; CMapOutdoor::UpdateQuadTreeHeights
$LN3@UpdateQuad:

; 1125 : 	
; 1126 : 	if (Node->SW_Node != NULL)

  001a8	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  001ab	85 c0		 test	 eax, eax
  001ad	74 08		 je	 SHORT $LN2@UpdateQuad

; 1127 : 		UpdateQuadTreeHeights(Node->SW_Node);

  001af	50		 push	 eax
  001b0	8b ce		 mov	 ecx, esi
  001b2	e8 00 00 00 00	 call	 ?UpdateQuadTreeHeights@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@@Z ; CMapOutdoor::UpdateQuadTreeHeights
$LN2@UpdateQuad:

; 1128 : 	
; 1129 : 	if (Node->SE_Node != NULL)

  001b7	8b 5b 20	 mov	 ebx, DWORD PTR [ebx+32]
  001ba	85 db		 test	 ebx, ebx
  001bc	74 17		 je	 SHORT $LN114@UpdateQuad

; 1068 : 	// Inserted by levites
; 1069 : 	assert(NULL!=m_pTerrainPatchProxyList && "CMapOutdoor::UpdateQuadTreeHeights");
; 1070 : 	if (!m_pTerrainPatchProxyList)

  001be	8b 54 24 0c	 mov	 edx, DWORD PTR _this$1$[esp+16]
  001c2	f3 0f 10 3d 00
	00 00 00	 movss	 xmm7, DWORD PTR __real@3f000000
  001ca	8b 72 64	 mov	 esi, DWORD PTR [edx+100]
  001cd	85 f6		 test	 esi, esi
  001cf	0f 85 51 fe ff
	ff		 jne	 $LL100@UpdateQuad
$LN114@UpdateQuad:

; 1130 : 		UpdateQuadTreeHeights(Node->SE_Node);
; 1131 : }

  001d5	5f		 pop	 edi
  001d6	5e		 pop	 esi
  001d7	5b		 pop	 ebx
  001d8	8b e5		 mov	 esp, ebp
  001da	5d		 pop	 ebp
  001db	c2 04 00	 ret	 4
?UpdateQuadTreeHeights@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@@Z ENDP ; CMapOutdoor::UpdateQuadTreeHeights
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?__IsInPCBlockerList@CMapOutdoor@@IAE_NPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_pkObjInstTest$ = 8					; size = 4
?__IsInPCBlockerList@CMapOutdoor@@IAE_NPAVCGraphicObjectInstance@@@Z PROC ; CMapOutdoor::__IsInPCBlockerList, COMDAT
; _this$ = ecx

; 714  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\vector

; 396  : 	return (_Iter._Unchecked());

  00003	8b 91 1c 0a 00
	00		 mov	 edx, DWORD PTR [ecx+2588]
; File a:\vs\vc\include\xutility

; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

  00009	8b 81 18 0a 00
	00		 mov	 eax, DWORD PTR [ecx+2584]

; 3025 : 	for (; _First != _Last; ++_First)

  0000f	3b d0		 cmp	 edx, eax
  00011	74 10		 je	 SHORT $LN60@IsInPCBloc
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _pkObjInstTest$[ebp]
$LL35@IsInPCBloc:

; 3026 : 		if (*_First == _Val)

  00016	39 08		 cmp	 DWORD PTR [eax], ecx
  00018	74 07		 je	 SHORT $LN55@IsInPCBloc

; 3025 : 	for (; _First != _Last; ++_First)

  0001a	83 c0 04	 add	 eax, 4
  0001d	3b c2		 cmp	 eax, edx
  0001f	75 f5		 jne	 SHORT $LL35@IsInPCBloc
$LN55@IsInPCBloc:
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00021	3b d0		 cmp	 edx, eax
$LN60@IsInPCBloc:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 715  : 	if (m_PCBlockerVector.end() == std::find(m_PCBlockerVector.begin(), m_PCBlockerVector.end(), pkObjInstTest))

  00023	0f 95 c0	 setne	 al

; 716  : 		return false;
; 717  : 
; 718  : 	return true;
; 719  : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?__IsInPCBlockerList@CMapOutdoor@@IAE_NPAVCGraphicObjectInstance@@@Z ENDP ; CMapOutdoor::__IsInPCBlockerList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?__IsInShadowReceiverList@CMapOutdoor@@IAE_NPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_pkObjInstTest$ = 8					; size = 4
?__IsInShadowReceiverList@CMapOutdoor@@IAE_NPAVCGraphicObjectInstance@@@Z PROC ; CMapOutdoor::__IsInShadowReceiverList, COMDAT
; _this$ = ecx

; 706  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\vector

; 396  : 	return (_Iter._Unchecked());

  00003	8b 91 10 0a 00
	00		 mov	 edx, DWORD PTR [ecx+2576]
; File a:\vs\vc\include\xutility

; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

  00009	8b 81 0c 0a 00
	00		 mov	 eax, DWORD PTR [ecx+2572]

; 3025 : 	for (; _First != _Last; ++_First)

  0000f	3b d0		 cmp	 edx, eax
  00011	74 10		 je	 SHORT $LN60@IsInShadow
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _pkObjInstTest$[ebp]
$LL35@IsInShadow:

; 3026 : 		if (*_First == _Val)

  00016	39 08		 cmp	 DWORD PTR [eax], ecx
  00018	74 07		 je	 SHORT $LN55@IsInShadow

; 3025 : 	for (; _First != _Last; ++_First)

  0001a	83 c0 04	 add	 eax, 4
  0001d	3b c2		 cmp	 eax, edx
  0001f	75 f5		 jne	 SHORT $LL35@IsInShadow
$LN55@IsInShadow:
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00021	3b d0		 cmp	 edx, eax
$LN60@IsInShadow:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 707  : 	if (m_ShadowReceiverVector.end() == std::find(m_ShadowReceiverVector.begin(), m_ShadowReceiverVector.end(), pkObjInstTest))

  00023	0f 95 c0	 setne	 al

; 708  : 		return false;
; 709  : 
; 710  : 	return true;
; 711  : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?__IsInShadowReceiverList@CMapOutdoor@@IAE_NPAVCGraphicObjectInstance@@@Z ENDP ; CMapOutdoor::__IsInShadowReceiverList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?__UpdateAroundAreaList@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_this$GSCopy$1$ = -48					; size = 4
_pArea$1 = -44						; size = 4
__$ArrayPad$ = -4					; size = 4
?__UpdateAroundAreaList@CMapOutdoor@@IAEXXZ PROC	; CMapOutdoor::__UpdateAroundAreaList, COMDAT
; _this$ = ecx

; 301  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 302  : #ifdef __PERFORMANCE_CHECKER__
; 303  : 	DWORD ft1=timeGetTime();
; 304  : #endif
; 305  : 	DWORD at[AROUND_AREA_NUM];
; 306  : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)

  00013	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__timeGetTime@0
  00019	33 f6		 xor	 esi, esi
  0001b	89 4d d0	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0001e	8b ff		 npad	 2
$LL4@UpdateArou:

; 307  : 	{
; 308  : 		DWORD t1=timeGetTime();

  00020	ff d7		 call	 edi

; 309  : 		CArea * pArea;
; 310  : 		if (GetAreaPointer(i, &pArea))

  00022	8b 4d d0	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00025	8d 45 d4	 lea	 eax, DWORD PTR _pArea$1[ebp]
  00028	50		 push	 eax
  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 ?GetAreaPointer@CMapOutdoor@@QAEHEPAPAVCArea@@@Z ; CMapOutdoor::GetAreaPointer
  0002f	85 c0		 test	 eax, eax
  00031	74 08		 je	 SHORT $LN1@UpdateArou

; 311  : 			pArea->Update();

  00033	8b 4d d4	 mov	 ecx, DWORD PTR _pArea$1[ebp]
  00036	e8 00 00 00 00	 call	 ?Update@CArea@@QAEXXZ	; CArea::Update
$LN1@UpdateArou:

; 312  : 		DWORD t2=timeGetTime();

  0003b	ff d7		 call	 edi
  0003d	46		 inc	 esi
  0003e	83 fe 09	 cmp	 esi, 9
  00041	7c dd		 jl	 SHORT $LL4@UpdateArou

; 313  : 
; 314  : 		at[i]=t2-t1;
; 315  : 	}	
; 316  : #ifdef __PERFORMANCE_CHECKER__
; 317  : 	DWORD ft2=timeGetTime();
; 318  : 	if (ft2-ft1>5)
; 319  : 	{
; 320  : 		for (int i=0; i<AROUND_AREA_NUM; ++i)
; 321  : 			Tracef("Area %d %d\n", i, at[i]);
; 322  : 	}
; 323  : #endif
; 324  : }

  00043	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	33 cd		 xor	 ecx, ebp
  0004a	5b		 pop	 ebx
  0004b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?__UpdateAroundAreaList@CMapOutdoor@@IAEXXZ ENDP	; CMapOutdoor::__UpdateAroundAreaList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?__CollectCollisionShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_r$2 = -96						; size = 12
_kGetShadowReceiverFromCollisionData$ = -84		; size = 12
_pObjInstEach$3 = -72					; size = 4
_kVct_pkShadowReceiver$ = -68				; size = 12
_s$ = -56						; size = 28
_aVector3d$ = -28					; size = 12
$T4 = -28						; size = 12
$T5 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_v3Target$ = 8						; size = 4
_v3Light$ = 12						; size = 4
?__CollectCollisionShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z PROC ; CMapOutdoor::__CollectCollisionShadowReceiver, COMDAT
; _this$ = ecx

; 678  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__CollectCollisionShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _v3Light$[ebp]
  00030	8b 55 08	 mov	 edx, DWORD PTR _v3Target$[ebp]

; 683  : 
; 684  : 	Vector3d aVector3d;
; 685  : 	aVector3d.Set(v3Target.x, v3Target.y, v3Target.z);
; 686  : 
; 687  : 	CCullingManager & rkCullingMgr = CCullingManager::Instance();

  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
  00039	c7 45 e0 00 00
	48 42		 mov	 DWORD PTR _s$[ebp+24], 1112014848 ; 42480000H
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00040	f3 0f 10 30	 movss	 xmm6, DWORD PTR [eax]
  00044	f3 0f 10 68 04	 movss	 xmm5, DWORD PTR [eax+4]
  00049	0f 28 de	 movaps	 xmm3, xmm6
  0004c	f3 0f 10 60 08	 movss	 xmm4, DWORD PTR [eax+8]
  00051	0f 28 d5	 movaps	 xmm2, xmm5
  00054	f3 0f 58 1a	 addss	 xmm3, DWORD PTR [edx]
  00058	f3 0f 10 7a 08	 movss	 xmm7, DWORD PTR [edx+8]
  0005d	0f 28 cc	 movaps	 xmm1, xmm4
  00060	f3 0f 58 52 04	 addss	 xmm2, DWORD PTR [edx+4]
  00065	f3 0f 58 cf	 addss	 xmm1, xmm7
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00069	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _kVct_pkShadowReceiver$[ebp], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();

  00070	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _kVct_pkShadowReceiver$[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 681  : 	s.v3LastPosition = v3Target + v3Light;

  00077	f3 0f 10 c3	 movss	 xmm0, xmm3
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0007b	f3 0f 58 f3	 addss	 xmm6, xmm3
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 681  : 	s.v3LastPosition = v3Target + v3Light;

  0007f	0f 14 c2	 unpcklps xmm0, xmm2
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00082	f3 0f 58 ea	 addss	 xmm5, xmm2
  00086	f3 0f 58 e1	 addss	 xmm4, xmm1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 681  : 	s.v3LastPosition = v3Target + v3Light;

  0008a	66 0f d6 45 d4	 movq	 QWORD PTR _s$[ebp+12], xmm0
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 107  : 		x = a;

  0008f	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00093	f3 0f 11 4d ec	 movss	 DWORD PTR $T5[ebp+8], xmm1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 681  : 	s.v3LastPosition = v3Target + v3Light;

  00098	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp+8]
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 107  : 		x = a;

  0009b	f3 0f 11 45 e4	 movss	 DWORD PTR _aVector3d$[ebp], xmm0

; 108  : 		y = b;

  000a0	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  000a5	f3 0f 11 65 ec	 movss	 DWORD PTR $T4[ebp+8], xmm4
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 681  : 	s.v3LastPosition = v3Target + v3Light;

  000aa	89 45 dc	 mov	 DWORD PTR _s$[ebp+20], eax

; 682  : 	s.v3Position = s.v3LastPosition + v3Light;

  000ad	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp+8]
  000b0	0f 14 f5	 unpcklps xmm6, xmm5
  000b3	66 0f d6 75 c8	 movq	 QWORD PTR _s$[ebp], xmm6
  000b8	89 45 d0	 mov	 DWORD PTR _s$[ebp+8], eax
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 108  : 		y = b;

  000bb	f3 0f 11 45 e8	 movss	 DWORD PTR _aVector3d$[ebp+4], xmm0

; 109  : 		z = c;

  000c0	f3 0f 11 7d ec	 movss	 DWORD PTR _aVector3d$[ebp+8], xmm7
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 170  : 	{

  000c5	8d 45 c8	 lea	 eax, DWORD PTR _s$[ebp]

; 688  : 
; 689  : 	std::vector<CGraphicObjectInstance *> kVct_pkShadowReceiver;

  000c8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 170  : 	{

  000cf	89 45 b4	 mov	 DWORD PTR _kGetShadowReceiverFromCollisionData$[ebp+8], eax

; 171  : 		m_pkVct_pkShadowReceiver=pkVct_pkShadowReceiver;

  000d2	8d 45 bc	 lea	 eax, DWORD PTR _kVct_pkShadowReceiver$[ebp]
  000d5	89 45 b0	 mov	 DWORD PTR _kGetShadowReceiverFromCollisionData$[ebp+4], eax
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  000d8	8d 45 ac	 lea	 eax, DWORD PTR _kGetShadowReceiverFromCollisionData$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 170  : 	{

  000db	c6 45 ac 00	 mov	 BYTE PTR _kGetShadowReceiverFromCollisionData$[ebp], 0
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  000df	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _kVct_pkShadowReceiver$[ebp+4], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  000e6	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _r$2[ebp], OFFSET ??_7?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@6B@
  000ed	89 45 a4	 mov	 DWORD PTR _r$2[ebp+4], eax
  000f0	c7 45 a8 00 00
	80 bf		 mov	 DWORD PTR _r$2[ebp+8], -1082130432 ; bf800000H

; 17   : 
; 18   : 	virtual ~RangeTester()
; 19   : 	{}
; 20   : 
; 21   : 
; 22   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 23   : 		const Vector3d &dir,          // dest pos of ray
; 24   : 		float distance,
; 25   : 		const Vector3d &sect,
; 26   : 		SpherePack *sphere)
; 27   : 	{
; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)
; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 34   : 	};
; 35   : 	
; 36   : 	
; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};
; 38   : 
; 39   : 	virtual void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state)
; 40   : 	{
; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)
; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 47   : 	}
; 48   : 
; 49   : 	virtual void PointTest2dCallback(const Vector3d &p, SpherePack *sphere,ViewState state)
; 50   : 	{
; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)
; 56   : 		{
; 57   : #ifdef SPHERELIB_STRICT
; 58   : 			puts("FIND!!");
; 59   : #endif
; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 61   : 		}
; 62   : 	}
; 63   : };
; 64   : 
; 65   : class CCullingManager : public CSingleton<CCullingManager>, public SpherePackCallback, private CScreen
; 66   : {
; 67   : public:
; 68   : 	typedef SpherePack * CullingHandle;
; 69   : 	typedef std::vector<CGraphicObjectInstance *> TRangeList;
; 70   : 
; 71   : 	CCullingManager();
; 72   : 	virtual ~CCullingManager();
; 73   : 
; 74   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 75   : 		const Vector3d &dir,          // dest pos of ray
; 76   : 		float distance,
; 77   : 		const Vector3d &sect,
; 78   : 		SpherePack *sphere);
; 79   : 	
; 80   : 	
; 81   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state);
; 82   : 	
; 83   : 	void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state);	
; 84   : 
; 85   : 	void Reset();
; 86   : 	void Update();
; 87   : 	void Process();
; 88   : 	
; 89   : 	void FindRange(const Vector3d &p, float radius);
; 90   : 	void FindRay(const Vector3d &p1, const Vector3d &dir);
; 91   : 	void FindRayDistance(const Vector3d &p1, const Vector3d &dir, float distance);
; 92   : 
; 93   : 	void RangeTest(const Vector3d& p, float radius, SpherePackCallback* callback)
; 94   : 	{
; 95   : 		m_Factory->RangeTest(p, radius, callback);
; 96   : 	}
; 97   : 
; 98   : 	void PointTest2d(const Vector3d& p, SpherePackCallback* callback)
; 99   : 	{
; 100  : 		m_Factory->PointTest2d(p, callback);
; 101  : 	}
; 102  : 
; 103  : 	template <class T>
; 104  : 	void ForInRange2d(const Vector3d& p, T* pFunc)
; 105  : 	{
; 106  : 		RangeTester<T> r(pFunc);
; 107  : 		m_Factory->PointTest2d(p, &r);
; 108  : 	}
; 109  : 
; 110  : 	template <class T>
; 111  : 	void ForInRange(const Vector3d &p, float radius, T* pFunc)
; 112  : 	{
; 113  : 		RangeTester<T> r(pFunc);
; 114  : 		m_Factory->RangeTest(p, radius, &r/*this*/);	

  000f7	8d 45 a0	 lea	 eax, DWORD PTR _r$2[ebp]
  000fa	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000fe	50		 push	 eax
  000ff	51		 push	 ecx
  00100	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00103	8d 45 e4	 lea	 eax, DWORD PTR _aVector3d$[ebp]
  00106	c7 04 24 00 00
	c8 42		 mov	 DWORD PTR [esp], 1120403456 ; 42c80000H
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 692  : 	if (!kGetShadowReceiverFromCollisionData.m_bCollide)

  00113	80 7d ac 00	 cmp	 BYTE PTR _kGetShadowReceiverFromCollisionData$[ebp], 0

; 696  : 	for ( i = kVct_pkShadowReceiver.begin(); i != kVct_pkShadowReceiver.end(); ++i)

  00117	8b 75 bc	 mov	 esi, DWORD PTR _kVct_pkShadowReceiver$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 115  : 	}

  0011a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 692  : 	if (!kGetShadowReceiverFromCollisionData.m_bCollide)

  0011e	74 3c		 je	 SHORT $LN3@CollectCol
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00120	3b 75 c0	 cmp	 esi, DWORD PTR _kVct_pkShadowReceiver$[ebp+4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 696  : 	for ( i = kVct_pkShadowReceiver.begin(); i != kVct_pkShadowReceiver.end(); ++i)

  00123	74 37		 je	 SHORT $LN3@CollectCol
$LL62@CollectCol:

; 697  : 	{
; 698  : 		CGraphicObjectInstance * pObjInstEach = *i;

  00125	8b 3e		 mov	 edi, DWORD PTR [esi]

; 699  : 		if (!__IsInPCBlockerList(pObjInstEach))

  00127	8b cb		 mov	 ecx, ebx
  00129	57		 push	 edi
  0012a	89 7d b8	 mov	 DWORD PTR _pObjInstEach$3[ebp], edi
  0012d	e8 00 00 00 00	 call	 ?__IsInPCBlockerList@CMapOutdoor@@IAE_NPAVCGraphicObjectInstance@@@Z ; CMapOutdoor::__IsInPCBlockerList
  00132	84 c0		 test	 al, al
  00134	75 1b		 jne	 SHORT $LN4@CollectCol

; 700  : 			if (!__IsInShadowReceiverList(pObjInstEach))				

  00136	57		 push	 edi
  00137	8b cb		 mov	 ecx, ebx
  00139	e8 00 00 00 00	 call	 ?__IsInShadowReceiverList@CMapOutdoor@@IAE_NPAVCGraphicObjectInstance@@@Z ; CMapOutdoor::__IsInShadowReceiverList
  0013e	84 c0		 test	 al, al
  00140	75 0f		 jne	 SHORT $LN4@CollectCol

; 701  : 				m_ShadowReceiverVector.push_back(pObjInstEach);			

  00142	8d 45 b8	 lea	 eax, DWORD PTR _pObjInstEach$3[ebp]
  00145	50		 push	 eax
  00146	8d 8b 0c 0a 00
	00		 lea	 ecx, DWORD PTR [ebx+2572]
  0014c	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXABQAVCGraphicObjectInstance@@@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::push_back
$LN4@CollectCol:
; File a:\vs\vc\include\vector

; 112  : 		++this->_Ptr;

  00151	83 c6 04	 add	 esi, 4

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00154	3b 75 c0	 cmp	 esi, DWORD PTR _kVct_pkShadowReceiver$[ebp+4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 696  : 	for ( i = kVct_pkShadowReceiver.begin(); i != kVct_pkShadowReceiver.end(); ++i)

  00157	75 cc		 jne	 SHORT $LL62@CollectCol
  00159	8b 75 bc	 mov	 esi, DWORD PTR _kVct_pkShadowReceiver$[ebp]
$LN3@CollectCol:
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0015c	85 f6		 test	 esi, esi
  0015e	74 09		 je	 SHORT $LN84@CollectCol
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00160	56		 push	 esi
  00161	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00166	83 c4 04	 add	 esp, 4
$LN84@CollectCol:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 703  : }

  00169	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0016c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00173	59		 pop	 ecx
  00174	5f		 pop	 edi
  00175	5e		 pop	 esi
  00176	5b		 pop	 ebx
  00177	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017a	33 cd		 xor	 ecx, ebp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	8b e5		 mov	 esp, ebp
  00183	5d		 pop	 ebp
  00184	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__CollectCollisionShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z$0:
  00000	8d 4d bc	 lea	 ecx, DWORD PTR _kVct_pkShadowReceiver$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::~vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >
__unwindfunclet$?__CollectCollisionShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z$1:
  00008	8d 4d a0	 lea	 ecx, DWORD PTR _r$2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UFGetShadowReceiverFromCollisionData@@@@UAE@XZ ; RangeTester<FGetShadowReceiverFromCollisionData>::~RangeTester<FGetShadowReceiverFromCollisionData>
__ehhandler$?__CollectCollisionShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__CollectCollisionShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__CollectCollisionShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z ENDP ; CMapOutdoor::__CollectCollisionShadowReceiver
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?__CollectCollisionPCBlocker@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0M@Z
_TEXT	SEGMENT
_kPCBlockerList$ = -2244				; size = 2084
_v3Eye$GSCopy$1$ = -160					; size = 4
_pObjInstEach$2 = -156					; size = 4
_kPCBlockerRangeTester$ = -152				; size = 12
$T3 = -152						; size = 12
$T4 = -152						; size = 12
$T5 = -152						; size = 12
$T6 = -152						; size = 12
_aDynamicSphereInstanceVector$ = -140			; size = 112
_v3dRayStart$ = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_v3Eye$ = 8						; size = 4
_v3Target$ = 12						; size = 4
_fDistance$ = 16					; size = 4
?__CollectCollisionPCBlocker@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0M@Z PROC ; CMapOutdoor::__CollectCollisionPCBlocker, COMDAT
; _this$ = ecx

; 585  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__CollectCollisionPCBlocker@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0M@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec b8 08 00
	00		 sub	 esp, 2232		; 000008b8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b f9		 mov	 edi, ecx
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _v3Eye$[ebp]
  00033	8b 55 0c	 mov	 edx, DWORD PTR _v3Target$[ebp]

; 599  : 		pkDSI->fRadius = fDistance * 0.5f;

  00036	f3 0f 10 2d 00
	00 00 00	 movss	 xmm5, DWORD PTR __real@3f000000
  0003e	f3 0f 10 5d 10	 movss	 xmm3, DWORD PTR _fDistance$[ebp]
  00043	f3 0f 10 21	 movss	 xmm4, DWORD PTR [ecx]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00047	f3 0f 10 3a	 movss	 xmm7, DWORD PTR [edx]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 591  : 	v3dRayStart.Set(v3Eye.x, v3Eye.y, v3Eye.z);

  0004b	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00050	f3 0f 5c fc	 subss	 xmm7, xmm4
  00054	f3 0f 10 72 04	 movss	 xmm6, DWORD PTR [edx+4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 591  : 	v3dRayStart.Set(v3Eye.x, v3Eye.y, v3Eye.z);

  00059	f3 0f 10 51 04	 movss	 xmm2, DWORD PTR [ecx+4]

; 600  : 		pkDSI->v3LastPosition = v3Eye;

  0005e	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00062	f3 0f 5c f2	 subss	 xmm6, xmm2
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 107  : 		x = a;

  00066	f3 0f 11 65 e4	 movss	 DWORD PTR _v3dRayStart$[ebp], xmm4
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0006b	f3 0f 10 62 08	 movss	 xmm4, DWORD PTR [edx+8]
  00070	f3 0f 5c e1	 subss	 xmm4, xmm1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 600  : 		pkDSI->v3LastPosition = v3Eye;

  00074	66 0f d6 45 80	 movq	 QWORD PTR _aDynamicSphereInstanceVector$[ebp+12], xmm0
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 108  : 		y = b;

  00079	f3 0f 11 55 e8	 movss	 DWORD PTR _v3dRayStart$[ebp+4], xmm2
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0007e	0f 28 d7	 movaps	 xmm2, xmm7
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 600  : 		pkDSI->v3LastPosition = v3Eye;

  00081	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 109  : 		z = c;

  00084	f3 0f 11 4d ec	 movss	 DWORD PTR _v3dRayStart$[ebp+8], xmm1
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00089	0f 28 ce	 movaps	 xmm1, xmm6
  0008c	f3 0f 59 d5	 mulss	 xmm2, xmm5
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 600  : 		pkDSI->v3LastPosition = v3Eye;

  00090	89 45 88	 mov	 DWORD PTR _aDynamicSphereInstanceVector$[ebp+20], eax
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00093	0f 28 c4	 movaps	 xmm0, xmm4
  00096	f3 0f 59 cd	 mulss	 xmm1, xmm5
  0009a	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _v3Eye$GSCopy$1$[ebp], ecx

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  000a0	f3 0f 58 11	 addss	 xmm2, DWORD PTR [ecx]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  000a4	f3 0f 59 c5	 mulss	 xmm0, xmm5

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  000a8	f3 0f 58 49 04	 addss	 xmm1, DWORD PTR [ecx+4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 599  : 		pkDSI->fRadius = fDistance * 0.5f;

  000ad	f3 0f 59 dd	 mulss	 xmm3, xmm5
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  000b1	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 601  : 		pkDSI->v3Position = v3Eye + 0.5f * (v3Target - v3Eye);

  000b6	0f 14 d1	 unpcklps xmm2, xmm1
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  000b9	0f 28 ce	 movaps	 xmm1, xmm6
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 601  : 		pkDSI->v3Position = v3Eye + 0.5f * (v3Target - v3Eye);

  000bc	66 0f d6 95 74
	ff ff ff	 movq	 QWORD PTR _aDynamicSphereInstanceVector$[ebp], xmm2
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  000c4	0f 28 d7	 movaps	 xmm2, xmm7
  000c7	f3 0f 59 d5	 mulss	 xmm2, xmm5

; 182  :     z = fz;

  000cb	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR $T6[ebp+8], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  000d3	0f 28 c4	 movaps	 xmm0, xmm4
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 601  : 		pkDSI->v3Position = v3Eye + 0.5f * (v3Target - v3Eye);

  000d6	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T6[ebp+8]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  000dc	f3 0f 58 11	 addss	 xmm2, DWORD PTR [ecx]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  000e0	f3 0f 59 c5	 mulss	 xmm0, xmm5
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 601  : 		pkDSI->v3Position = v3Eye + 0.5f * (v3Target - v3Eye);

  000e4	89 85 7c ff ff
	ff		 mov	 DWORD PTR _aDynamicSphereInstanceVector$[ebp+8], eax
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  000ea	f3 0f 59 cd	 mulss	 xmm1, xmm5

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  000ee	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 599  : 		pkDSI->fRadius = fDistance * 0.5f;

  000f3	f3 0f 11 5d 8c	 movss	 DWORD PTR _aDynamicSphereInstanceVector$[ebp+24], xmm3
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  000f8	f3 0f 58 49 04	 addss	 xmm1, DWORD PTR [ecx+4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 604  : 		pkDSI->fRadius = fDistance * 0.5f;

  000fd	f3 0f 11 5d a8	 movss	 DWORD PTR _aDynamicSphereInstanceVector$[ebp+52], xmm3

; 607  : 		++pkDSI;
; 608  : 
; 609  : 		pkDSI->fRadius = fDistance * 0.5f;

  00102	f3 0f 11 5d c4	 movss	 DWORD PTR _aDynamicSphereInstanceVector$[ebp+80], xmm3
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00107	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR $T5[ebp+8], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 606  : 		pkDSI->v3Position = v3Target;

  0010f	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  00113	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T5[ebp+8]
  00119	0f 14 d1	 unpcklps xmm2, xmm1
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0011c	0f 28 ce	 movaps	 xmm1, xmm6
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 606  : 		pkDSI->v3Position = v3Target;

  0011f	66 0f d6 45 90	 movq	 QWORD PTR _aDynamicSphereInstanceVector$[ebp+28], xmm0

; 610  : 		pkDSI->v3LastPosition = v3Target;

  00124	66 0f 7f c0	 movq	 xmm0, xmm0
  00128	66 0f d6 55 9c	 movq	 QWORD PTR _aDynamicSphereInstanceVector$[ebp+40], xmm2
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0012d	0f 28 d7	 movaps	 xmm2, xmm7
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 610  : 		pkDSI->v3LastPosition = v3Target;

  00130	66 0f d6 45 b8	 movq	 QWORD PTR _aDynamicSphereInstanceVector$[ebp+68], xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00135	0f 28 c4	 movaps	 xmm0, xmm4
  00138	f3 0f 59 d5	 mulss	 xmm2, xmm5
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 605  : 		pkDSI->v3LastPosition = v3Eye + 0.5f * (v3Target - v3Eye);

  0013c	89 45 a4	 mov	 DWORD PTR _aDynamicSphereInstanceVector$[ebp+48], eax

; 606  : 		pkDSI->v3Position = v3Target;

  0013f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00142	f3 0f 59 cd	 mulss	 xmm1, xmm5
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 606  : 		pkDSI->v3Position = v3Target;

  00146	89 45 98	 mov	 DWORD PTR _aDynamicSphereInstanceVector$[ebp+36], eax
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00149	f3 0f 58 11	 addss	 xmm2, DWORD PTR [ecx]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0014d	f3 0f 59 c5	 mulss	 xmm0, xmm5
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 610  : 		pkDSI->v3LastPosition = v3Target;

  00151	89 45 c0	 mov	 DWORD PTR _aDynamicSphereInstanceVector$[ebp+76], eax
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00154	f3 0f 58 49 04	 addss	 xmm1, DWORD PTR [ecx+4]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00159	f3 0f 59 fd	 mulss	 xmm7, xmm5

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0015d	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00162	f3 0f 59 f5	 mulss	 xmm6, xmm5

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00166	f3 0f 58 39	 addss	 xmm7, DWORD PTR [ecx]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0016a	f3 0f 59 e5	 mulss	 xmm4, xmm5

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0016e	f3 0f 58 71 04	 addss	 xmm6, DWORD PTR [ecx+4]

; 182  :     z = fz;

  00173	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR $T4[ebp+8], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 611  : 		pkDSI->v3Position = v3Eye + 0.5f * (v3Target - v3Eye);

  0017b	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T4[ebp+8]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00181	f3 0f 58 61 08	 addss	 xmm4, DWORD PTR [ecx+8]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 611  : 		pkDSI->v3Position = v3Eye + 0.5f * (v3Target - v3Eye);

  00186	0f 14 d1	 unpcklps xmm2, xmm1
  00189	66 0f d6 55 ac	 movq	 QWORD PTR _aDynamicSphereInstanceVector$[ebp+56], xmm2
  0018e	89 45 b4	 mov	 DWORD PTR _aDynamicSphereInstanceVector$[ebp+64], eax

; 612  : 		++pkDSI;
; 613  : 
; 614  : 		pkDSI->fRadius = fDistance * 0.5f;

  00191	f3 0f 11 5d e0	 movss	 DWORD PTR _aDynamicSphereInstanceVector$[ebp+108], xmm3

; 616  : 		pkDSI->v3Position = v3Eye;

  00196	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]

; 617  : 		++pkDSI;
; 618  : 	}
; 619  : #ifdef __PERFORMANCE_CHECKER__
; 620  : 	DWORD t3=timeGetTime();	
; 621  : #endif
; 622  : 	CCullingManager & rkCullingMgr = CCullingManager::Instance();

  0019a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  001a0	f3 0f 11 a5 70
	ff ff ff	 movss	 DWORD PTR $T3[ebp+8], xmm4
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 615  : 		pkDSI->v3LastPosition = v3Eye + 0.5f * (v3Target - v3Eye);

  001a8	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp+8]
  001ae	89 45 dc	 mov	 DWORD PTR _aDynamicSphereInstanceVector$[ebp+104], eax

; 616  : 		pkDSI->v3Position = v3Eye;

  001b1	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 623  : 
; 624  : 	PCBlocker_SInstanceList kPCBlockerList(&aDynamicSphereInstanceVector);

  001b4	8d 8d 3c f7 ff
	ff		 lea	 ecx, DWORD PTR _kPCBlockerList$[ebp]
  001ba	89 45 d0	 mov	 DWORD PTR _aDynamicSphereInstanceVector$[ebp+92], eax
  001bd	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _aDynamicSphereInstanceVector$[ebp]
  001c3	0f 14 fe	 unpcklps xmm7, xmm6
  001c6	50		 push	 eax
  001c7	66 0f d6 7d d4	 movq	 QWORD PTR _aDynamicSphereInstanceVector$[ebp+96], xmm7
  001cc	66 0f d6 45 c8	 movq	 QWORD PTR _aDynamicSphereInstanceVector$[ebp+84], xmm0
  001d1	e8 00 00 00 00	 call	 ??0PCBlocker_SInstanceList@@QAE@PAVPCBlocker_CDynamicSphereInstanceVector@@@Z ; PCBlocker_SInstanceList::PCBlocker_SInstanceList
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  001d6	8d 85 3c f7 ff
	ff		 lea	 eax, DWORD PTR _kPCBlockerList$[ebp]
  001dc	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _kPCBlockerRangeTester$[ebp], OFFSET ??_7?$RangeTester@UPCBlocker_SInstanceList@@@@6B@
  001e6	89 85 6c ff ff
	ff		 mov	 DWORD PTR _kPCBlockerRangeTester$[ebp+4], eax
  001ec	c7 85 70 ff ff
	ff 00 00 80 bf	 mov	 DWORD PTR _kPCBlockerRangeTester$[ebp+8], -1082130432 ; bf800000H

; 95   : 		m_Factory->RangeTest(p, radius, callback);

  001f6	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fDistance$[ebp]
  001fb	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _kPCBlockerRangeTester$[ebp]
  00201	50		 push	 eax
  00202	51		 push	 ecx
  00203	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00206	8d 45 e4	 lea	 eax, DWORD PTR _v3dRayStart$[ebp]
  00209	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0020e	50		 push	 eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 625  : 	RangeTester<PCBlocker_SInstanceList> kPCBlockerRangeTester(&kPCBlockerList);

  0020f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 95   : 		m_Factory->RangeTest(p, radius, callback);

  00216	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 515  : 		if (m_dwBlockerCount>0)

  0021b	8b 85 40 f7 ff
	ff		 mov	 eax, DWORD PTR _kPCBlockerList$[ebp+4]
  00221	85 c0		 test	 eax, eax
  00223	74 70		 je	 SHORT $LN5@CollectCol

; 626  : 	rkCullingMgr.RangeTest(v3dRayStart, fDistance, &kPCBlockerRangeTester);
; 627  : #ifdef __PERFORMANCE_CHECKER__
; 628  :  	DWORD t4=timeGetTime();
; 629  : #endif
; 630  : 
; 631  : 	if (!kPCBlockerList.IsEmpty())
; 632  : 	{
; 633  : 		PCBlocker_SInstanceList::Iterator i;
; 634  : 
; 635  : 		for (i=kPCBlockerList.Begin(); i!=kPCBlockerList.End(); ++i)

  00225	8d 9d 48 f7 ff
	ff		 lea	 ebx, DWORD PTR _kPCBlockerList$[ebp+12]

; 505  : 		return m_apkPCBlocker+m_dwBlockerCount;

  0022b	8b cb		 mov	 ecx, ebx
  0022d	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 626  : 	rkCullingMgr.RangeTest(v3dRayStart, fDistance, &kPCBlockerRangeTester);
; 627  : #ifdef __PERFORMANCE_CHECKER__
; 628  :  	DWORD t4=timeGetTime();
; 629  : #endif
; 630  : 
; 631  : 	if (!kPCBlockerList.IsEmpty())
; 632  : 	{
; 633  : 		PCBlocker_SInstanceList::Iterator i;
; 634  : 
; 635  : 		for (i=kPCBlockerList.Begin(); i!=kPCBlockerList.End(); ++i)

  00230	3b c8		 cmp	 ecx, eax
  00232	74 61		 je	 SHORT $LN5@CollectCol
$LL7@CollectCol:

; 636  : 		{
; 637  : 			CGraphicObjectInstance * pObjInstEach = *i;

  00234	8b 33		 mov	 esi, DWORD PTR [ebx]
  00236	89 b5 64 ff ff
	ff		 mov	 DWORD PTR _pObjInstEach$2[ebp], esi

; 638  : 
; 639  : 			if (!pObjInstEach)

  0023c	85 f6		 test	 esi, esi
  0023e	74 41		 je	 SHORT $LN6@CollectCol

; 640  : 				continue;
; 641  : 
; 642  : 			if (TREE_OBJECT == pObjInstEach->GetType() && !m_bTransparentTree)

  00240	8b 06		 mov	 eax, DWORD PTR [esi]
  00242	8b ce		 mov	 ecx, esi
  00244	ff 50 04	 call	 DWORD PTR [eax+4]
  00247	3d a6 f7 c9 8a	 cmp	 eax, -1966475354	; 8ac9f7a6H
  0024c	75 09		 jne	 SHORT $LN3@CollectCol
  0024e	80 bf b5 0e 00
	00 00		 cmp	 BYTE PTR [edi+3765], 0
  00255	74 2a		 je	 SHORT $LN6@CollectCol
$LN3@CollectCol:

; 643  : 				continue;
; 644  : 
; 645  : 			if (!__IsInShadowReceiverList(pObjInstEach))

  00257	56		 push	 esi
  00258	8b cf		 mov	 ecx, edi
  0025a	e8 00 00 00 00	 call	 ?__IsInShadowReceiverList@CMapOutdoor@@IAE_NPAVCGraphicObjectInstance@@@Z ; CMapOutdoor::__IsInShadowReceiverList
  0025f	84 c0		 test	 al, al
  00261	75 1e		 jne	 SHORT $LN6@CollectCol

; 646  : 				if (!__IsInPCBlockerList(pObjInstEach))

  00263	56		 push	 esi
  00264	8b cf		 mov	 ecx, edi
  00266	e8 00 00 00 00	 call	 ?__IsInPCBlockerList@CMapOutdoor@@IAE_NPAVCGraphicObjectInstance@@@Z ; CMapOutdoor::__IsInPCBlockerList
  0026b	84 c0		 test	 al, al
  0026d	75 12		 jne	 SHORT $LN6@CollectCol

; 647  : 					m_PCBlockerVector.push_back(pObjInstEach);

  0026f	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _pObjInstEach$2[ebp]
  00275	50		 push	 eax
  00276	8d 8f 18 0a 00
	00		 lea	 ecx, DWORD PTR [edi+2584]
  0027c	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXABQAVCGraphicObjectInstance@@@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::push_back
$LN6@CollectCol:

; 505  : 		return m_apkPCBlocker+m_dwBlockerCount;

  00281	8b 85 40 f7 ff
	ff		 mov	 eax, DWORD PTR _kPCBlockerList$[ebp+4]

; 626  : 	rkCullingMgr.RangeTest(v3dRayStart, fDistance, &kPCBlockerRangeTester);
; 627  : #ifdef __PERFORMANCE_CHECKER__
; 628  :  	DWORD t4=timeGetTime();
; 629  : #endif
; 630  : 
; 631  : 	if (!kPCBlockerList.IsEmpty())
; 632  : 	{
; 633  : 		PCBlocker_SInstanceList::Iterator i;
; 634  : 
; 635  : 		for (i=kPCBlockerList.Begin(); i!=kPCBlockerList.End(); ++i)

  00287	83 c3 04	 add	 ebx, 4

; 505  : 		return m_apkPCBlocker+m_dwBlockerCount;

  0028a	8d 84 85 48 f7
	ff ff		 lea	 eax, DWORD PTR _kPCBlockerList$[ebp+eax*4+12]

; 626  : 	rkCullingMgr.RangeTest(v3dRayStart, fDistance, &kPCBlockerRangeTester);
; 627  : #ifdef __PERFORMANCE_CHECKER__
; 628  :  	DWORD t4=timeGetTime();
; 629  : #endif
; 630  : 
; 631  : 	if (!kPCBlockerList.IsEmpty())
; 632  : 	{
; 633  : 		PCBlocker_SInstanceList::Iterator i;
; 634  : 
; 635  : 		for (i=kPCBlockerList.Begin(); i!=kPCBlockerList.End(); ++i)

  00291	3b d8		 cmp	 ebx, eax
  00293	75 9f		 jne	 SHORT $LL7@CollectCol
$LN5@CollectCol:
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  00295	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _v3Eye$GSCopy$1$[ebp]
  0029b	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 653  : 	std::sort(m_PCBlockerVector.begin(), m_PCBlockerVector.end(), FPCBlockerDistanceSort(v3Eye));

  0029e	8b 87 1c 0a 00
	00		 mov	 eax, DWORD PTR [edi+2588]
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  002a4	8b f4		 mov	 esi, esp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 653  : 	std::sort(m_PCBlockerVector.begin(), m_PCBlockerVector.end(), FPCBlockerDistanceSort(v3Eye));

  002a6	8b 8f 18 0a 00
	00		 mov	 ecx, DWORD PTR [edi+2584]
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  002ac	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  002b0	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  002b3	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  002b7	89 56 08	 mov	 DWORD PTR [esi+8], edx
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  002ba	8b d0		 mov	 edx, eax
  002bc	2b d1		 sub	 edx, ecx
  002be	c1 fa 02	 sar	 edx, 2
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  002c1	52		 push	 edx
  002c2	50		 push	 eax
  002c3	51		 push	 ecx
  002c4	e8 00 00 00 00	 call	 ??$_Sort@PAPAVCGraphicObjectInstance@@HUFPCBlockerDistanceSort@@@std@@YAXPAPAVCGraphicObjectInstance@@0HUFPCBlockerDistanceSort@@@Z ; std::_Sort<CGraphicObjectInstance * *,int,FPCBlockerDistanceSort>
  002c9	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 675  : }

  002cc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002cf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002d6	59		 pop	 ecx
  002d7	5f		 pop	 edi
  002d8	5e		 pop	 esi
  002d9	5b		 pop	 ebx
  002da	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002dd	33 cd		 xor	 ecx, ebp
  002df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e4	8b e5		 mov	 esp, ebp
  002e6	5d		 pop	 ebp
  002e7	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__CollectCollisionPCBlocker@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0M@Z$0:
  00000	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _kPCBlockerRangeTester$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UPCBlocker_SInstanceList@@@@UAE@XZ ; RangeTester<PCBlocker_SInstanceList>::~RangeTester<PCBlocker_SInstanceList>
__ehhandler$?__CollectCollisionPCBlocker@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0M@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 38 f7 ff
	ff		 mov	 ecx, DWORD PTR [edx-2248]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__CollectCollisionPCBlocker@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0M@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__CollectCollisionPCBlocker@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0M@Z ENDP ; CMapOutdoor::__CollectCollisionPCBlocker
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?__CollectShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_kGetShadowReceiverFromHeightData$ = -484		; size = 436
_r$2 = -48						; size = 12
_this$GSCopy$1$ = -36					; size = 4
_pObjInstEach$3 = -32					; size = 4
_aVector3d$ = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_v3Target$ = 8						; size = 4
_v3Light$ = 12						; size = 4
?__CollectShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z PROC ; CMapOutdoor::__CollectShadowReceiver, COMDAT
; _this$ = ecx

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__CollectShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 01 00
	00		 sub	 esp, 472		; 000001d8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b f1		 mov	 esi, ecx
  00030	89 75 dc	 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi
  00033	8b 55 08	 mov	 edx, DWORD PTR _v3Target$[ebp]
  00036	8b 45 0c	 mov	 eax, DWORD PTR _v3Light$[ebp]

; 398  : 
; 399  : 	CCullingManager & rkCullingMgr = CCullingManager::Instance();

  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton

; 345  : 	{

  0003f	c6 85 28 fe ff
	ff 00		 mov	 BYTE PTR _kGetShadowReceiverFromHeightData$[ebp+12], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00046	f3 0f 10 1a	 movss	 xmm3, DWORD PTR [edx]
  0004a	f3 0f 10 52 04	 movss	 xmm2, DWORD PTR [edx+4]
  0004f	0f 28 cb	 movaps	 xmm1, xmm3
  00052	f3 0f 10 28	 movss	 xmm5, DWORD PTR [eax]
  00056	0f 28 c2	 movaps	 xmm0, xmm2
  00059	f3 0f 10 60 04	 movss	 xmm4, DWORD PTR [eax+4]
  0005e	f3 0f 58 cd	 addss	 xmm1, xmm5
  00062	f3 0f 58 c4	 addss	 xmm0, xmm4
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 107  : 		x = a;

  00066	f3 0f 11 5d e4	 movss	 DWORD PTR _aVector3d$[ebp], xmm3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  0006b	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _kGetShadowReceiverFromHeightData$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 108  : 		y = b;

  00071	f3 0f 11 55 e8	 movss	 DWORD PTR _aVector3d$[ebp+4], xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 345  : 	{

  00076	f3 0f 11 9d 2c
	fe ff ff	 movss	 DWORD PTR _kGetShadowReceiverFromHeightData$[ebp+16], xmm3
  0007e	f3 0f 11 95 30
	fe ff ff	 movss	 DWORD PTR _kGetShadowReceiverFromHeightData$[ebp+20], xmm2
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00086	f3 0f 58 e9	 addss	 xmm5, xmm1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 346  : 		m_dwCheckCount=0;

  0008a	c7 85 24 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _kGetShadowReceiverFromHeightData$[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00094	f3 0f 58 e0	 addss	 xmm4, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 347  : 		m_dwCollectOverCount=0;

  00098	c7 85 1c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _kGetShadowReceiverFromHeightData$[ebp], 0

; 391  : 	CDynamicSphereInstance s;
; 392  : 	s.v3LastPosition = v3Target + v3Light;
; 393  : 	s.v3Position = s.v3LastPosition + v3Light;
; 394  : 	s.fRadius = 50.0f;
; 395  : 
; 396  : 	Vector3d aVector3d;
; 397  : 	aVector3d.Set(v3Target.x, v3Target.y, v3Target.z);

  000a2	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 109  : 		z = c;

  000a7	f3 0f 11 45 ec	 movss	 DWORD PTR _aVector3d$[ebp+8], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 348  : 		m_dwCollectCount=0;		

  000ac	c7 85 20 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _kGetShadowReceiverFromHeightData$[ebp+4], 0
  000b6	f3 0f 11 ad 34
	fe ff ff	 movss	 DWORD PTR _kGetShadowReceiverFromHeightData$[ebp+24], xmm5
  000be	f3 0f 11 a5 38
	fe ff ff	 movss	 DWORD PTR _kGetShadowReceiverFromHeightData$[ebp+28], xmm4
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  000c6	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _r$2[ebp], OFFSET ??_7?$RangeTester@UFGetShadowReceiverFromHeightData@@@@6B@
  000cd	89 45 d4	 mov	 DWORD PTR _r$2[ebp+4], eax
  000d0	c7 45 d8 00 00
	80 bf		 mov	 DWORD PTR _r$2[ebp+8], -1082130432 ; bf800000H

; 17   : 
; 18   : 	virtual ~RangeTester()
; 19   : 	{}
; 20   : 
; 21   : 
; 22   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 23   : 		const Vector3d &dir,          // dest pos of ray
; 24   : 		float distance,
; 25   : 		const Vector3d &sect,
; 26   : 		SpherePack *sphere)
; 27   : 	{
; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)
; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 34   : 	};
; 35   : 	
; 36   : 	
; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};
; 38   : 
; 39   : 	virtual void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state)
; 40   : 	{
; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)
; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 47   : 	}
; 48   : 
; 49   : 	virtual void PointTest2dCallback(const Vector3d &p, SpherePack *sphere,ViewState state)
; 50   : 	{
; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)
; 56   : 		{
; 57   : #ifdef SPHERELIB_STRICT
; 58   : 			puts("FIND!!");
; 59   : #endif
; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 61   : 		}
; 62   : 	}
; 63   : };
; 64   : 
; 65   : class CCullingManager : public CSingleton<CCullingManager>, public SpherePackCallback, private CScreen
; 66   : {
; 67   : public:
; 68   : 	typedef SpherePack * CullingHandle;
; 69   : 	typedef std::vector<CGraphicObjectInstance *> TRangeList;
; 70   : 
; 71   : 	CCullingManager();
; 72   : 	virtual ~CCullingManager();
; 73   : 
; 74   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 75   : 		const Vector3d &dir,          // dest pos of ray
; 76   : 		float distance,
; 77   : 		const Vector3d &sect,
; 78   : 		SpherePack *sphere);
; 79   : 	
; 80   : 	
; 81   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state);
; 82   : 	
; 83   : 	void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state);	
; 84   : 
; 85   : 	void Reset();
; 86   : 	void Update();
; 87   : 	void Process();
; 88   : 	
; 89   : 	void FindRange(const Vector3d &p, float radius);
; 90   : 	void FindRay(const Vector3d &p1, const Vector3d &dir);
; 91   : 	void FindRayDistance(const Vector3d &p1, const Vector3d &dir, float distance);
; 92   : 
; 93   : 	void RangeTest(const Vector3d& p, float radius, SpherePackCallback* callback)
; 94   : 	{
; 95   : 		m_Factory->RangeTest(p, radius, callback);
; 96   : 	}
; 97   : 
; 98   : 	void PointTest2d(const Vector3d& p, SpherePackCallback* callback)
; 99   : 	{
; 100  : 		m_Factory->PointTest2d(p, callback);
; 101  : 	}
; 102  : 
; 103  : 	template <class T>
; 104  : 	void ForInRange2d(const Vector3d& p, T* pFunc)
; 105  : 	{
; 106  : 		RangeTester<T> r(pFunc);
; 107  : 		m_Factory->PointTest2d(p, &r);
; 108  : 	}
; 109  : 
; 110  : 	template <class T>
; 111  : 	void ForInRange(const Vector3d &p, float radius, T* pFunc)
; 112  : 	{
; 113  : 		RangeTester<T> r(pFunc);
; 114  : 		m_Factory->RangeTest(p, radius, &r/*this*/);	

  000d7	8d 45 d0	 lea	 eax, DWORD PTR _r$2[ebp]
  000da	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000e1	50		 push	 eax
  000e2	51		 push	 ecx
  000e3	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  000e6	8d 45 e4	 lea	 eax, DWORD PTR _aVector3d$[ebp]
  000e9	c7 04 24 00 00
	20 41		 mov	 DWORD PTR [esp], 1092616192 ; 41200000H
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 412  : 	if (kGetShadowReceiverFromHeightData.m_bReceiverFound)

  000f6	80 bd 28 fe ff
	ff 00		 cmp	 BYTE PTR _kGetShadowReceiverFromHeightData$[ebp+12], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 115  : 	}

  000fd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 412  : 	if (kGetShadowReceiverFromHeightData.m_bReceiverFound)

  00104	0f 84 98 00 00
	00		 je	 $LN2@CollectSha

; 414  : 		for (UINT i=0; i<kGetShadowReceiverFromHeightData.GetCollectCount(); ++i)

  0010a	33 db		 xor	 ebx, ebx
  0010c	39 9d 20 fe ff
	ff		 cmp	 DWORD PTR _kGetShadowReceiverFromHeightData$[ebp+4], ebx
  00112	0f 86 8a 00 00
	00		 jbe	 $LN2@CollectSha

; 349  : 	}
; 350  : 
; 351  : 	CGraphicObjectInstance* GetCollectItem(UINT uIndex)
; 352  : 	{
; 353  : 		if (uIndex>=m_dwCollectCount)

  00118	3b 9d 20 fe ff
	ff		 cmp	 ebx, DWORD PTR _kGetShadowReceiverFromHeightData$[ebp+4]
  0011e	72 04		 jb	 SHORT $LN35@CollectSha

; 354  : 			return NULL;

  00120	33 ff		 xor	 edi, edi
  00122	eb 07		 jmp	 SHORT $LN36@CollectSha
$LN35@CollectSha:

; 355  : 
; 356  : 		return m_apkShadowReceiver[uIndex];

  00124	8b bc 9d 40 fe
	ff ff		 mov	 edi, DWORD PTR _kGetShadowReceiverFromHeightData$[ebp+ebx*4+36]
$LN36@CollectSha:

; 415  : 		{
; 416  : 			CGraphicObjectInstance * pObjInstEach = kGetShadowReceiverFromHeightData.GetCollectItem(i);
; 417  : 			if (!__IsInShadowReceiverList(pObjInstEach))

  0012b	57		 push	 edi
  0012c	8b ce		 mov	 ecx, esi
  0012e	89 7d e0	 mov	 DWORD PTR _pObjInstEach$3[ebp], edi
  00131	e8 00 00 00 00	 call	 ?__IsInShadowReceiverList@CMapOutdoor@@IAE_NPAVCGraphicObjectInstance@@@Z ; CMapOutdoor::__IsInShadowReceiverList
  00136	84 c0		 test	 al, al
  00138	75 5f		 jne	 SHORT $LN3@CollectSha
; File a:\vs\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0013a	8b 86 10 0a 00
	00		 mov	 eax, DWORD PTR [esi+2576]
  00140	8d 4d e0	 lea	 ecx, DWORD PTR _pObjInstEach$3[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 418  : 				m_ShadowReceiverVector.push_back(pObjInstEach);	

  00143	81 c6 0c 0a 00
	00		 add	 esi, 2572		; 00000a0cH
; File a:\vs\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00149	3b c8		 cmp	 ecx, eax
  0014b	73 2e		 jae	 SHORT $LN41@CollectSha
  0014d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0014f	8d 55 e0	 lea	 edx, DWORD PTR _pObjInstEach$3[ebp]
  00152	3b ca		 cmp	 ecx, edx
  00154	77 25		 ja	 SHORT $LN41@CollectSha

; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00156	8b fa		 mov	 edi, edx
  00158	2b f9		 sub	 edi, ecx
  0015a	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  0015d	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00160	75 09		 jne	 SHORT $LN40@CollectSha

; 1248 : 				_Reserve(1);

  00162	6a 01		 push	 1
  00164	8b ce		 mov	 ecx, esi
  00166	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Reserve
$LN40@CollectSha:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0016b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0016e	85 c9		 test	 ecx, ecx
  00170	74 20		 je	 SHORT $LN86@CollectSha
  00172	8b 06		 mov	 eax, DWORD PTR [esi]
  00174	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00177	89 01		 mov	 DWORD PTR [ecx], eax
; File a:\vs\vc\include\vector

; 1254 : 		else

  00179	eb 17		 jmp	 SHORT $LN86@CollectSha
$LN41@CollectSha:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  0017b	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0017e	75 09		 jne	 SHORT $LN38@CollectSha

; 1257 : 				_Reserve(1);

  00180	6a 01		 push	 1
  00182	8b ce		 mov	 ecx, esi
  00184	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Reserve
$LN38@CollectSha:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00189	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0018c	85 c0		 test	 eax, eax
  0018e	74 02		 je	 SHORT $LN86@CollectSha
  00190	89 38		 mov	 DWORD PTR [eax], edi
$LN86@CollectSha:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00192	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  00196	8b 75 dc	 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
$LN3@CollectSha:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 414  : 		for (UINT i=0; i<kGetShadowReceiverFromHeightData.GetCollectCount(); ++i)

  00199	43		 inc	 ebx
  0019a	3b 9d 20 fe ff
	ff		 cmp	 ebx, DWORD PTR _kGetShadowReceiverFromHeightData$[ebp+4]
  001a0	72 82		 jb	 SHORT $LN35@CollectSha
$LN2@CollectSha:

; 419  : 		}
; 420  : 	}
; 421  : 
; 422  : #ifdef __PERFORMANCE_CHECKER__
; 423  : 	static FILE* fp=fopen("perf_shadow_collect.txt", "w");
; 424  : 	DWORD t3=ELTimer_GetMSec();
; 425  : 
; 426  : 	if (t3-t1>5)
; 427  : 	{
; 428  : 		fprintf(fp, "SC.Total %d (Time %f)\n", t3-t1, ELTimer_GetMSec()/1000.0f);
; 429  : 		fprintf(fp, "SC.Find %d\n", t2-t1);
; 430  : 		fprintf(fp, "SC.Push %d\n", t3-t2);
; 431  : 		fprintf(fp, "SC.Count (Collect %d, Over %d, Check %d)\n", 
; 432  : 			kGetShadowReceiverFromHeightData.m_dwCollectCount, 
; 433  : 			kGetShadowReceiverFromHeightData.m_dwCollectOverCount,
; 434  : 			kGetShadowReceiverFromHeightData.m_dwCheckCount);
; 435  : 		fflush(fp);
; 436  : 	}
; 437  : #endif
; 438  : }

  001a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ac	59		 pop	 ecx
  001ad	5f		 pop	 edi
  001ae	5e		 pop	 esi
  001af	5b		 pop	 ebx
  001b0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b3	33 cd		 xor	 ecx, ebp
  001b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ba	8b e5		 mov	 esp, ebp
  001bc	5d		 pop	 ebp
  001bd	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__CollectShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR _r$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UFGetShadowReceiverFromHeightData@@@@UAE@XZ ; RangeTester<FGetShadowReceiverFromHeightData>::~RangeTester<FGetShadowReceiverFromHeightData>
__ehhandler$?__CollectShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 18 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-488]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__CollectShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__CollectShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z ENDP ; CMapOutdoor::__CollectShadowReceiver
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?__Game_UpdateArea@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_fDistance$1$ = -28					; size = 4
_v3Light$ = -24						; size = 12
_v3Eye$ = -12						; size = 12
_v3Player$ = 8						; size = 4
?__Game_UpdateArea@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@@Z PROC ; CMapOutdoor::__Game_UpdateArea, COMDAT
; _this$ = ecx

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 20	 sub	 esp, 32			; 00000020H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0000d	8b 87 18 0a 00
	00		 mov	 eax, DWORD PTR [edi+2584]
  00013	89 87 1c 0a 00
	00		 mov	 DWORD PTR [edi+2588], eax
  00019	8b 87 0c 0a 00
	00		 mov	 eax, DWORD PTR [edi+2572]
  0001f	89 87 10 0a 00
	00		 mov	 DWORD PTR [edi+2576], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 232  : 	CCamera * pCamera = rCmrMgr.GetCurrentCamera();

  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0002b	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 233  : 	if (!pCamera)

  00030	85 c0		 test	 eax, eax
  00032	0f 84 9f 00 00
	00		 je	 $LN2@Game_Updat
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h

; 186  : 		float GetDistance() const { return m_fDistance; }

  00038	f3 0f 10 80 34
	01 00 00	 movss	 xmm0, DWORD PTR [eax+308]
  00040	f3 0f 11 44 24
	0c		 movss	 DWORD PTR _fDistance$1$[esp+40], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 240  : 	D3DXVECTOR3 v3Eye= pCamera->GetEye();

  00046	f3 0f 7e 40 30	 movq	 xmm0, QWORD PTR [eax+48]
  0004b	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  0004e	66 0f d6 44 24
	1c		 movq	 QWORD PTR _v3Eye$[esp+40], xmm0
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  00054	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@402fff8cc0000000
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 240  : 	D3DXVECTOR3 v3Eye= pCamera->GetEye();

  0005c	89 44 24 24	 mov	 DWORD PTR _v3Eye$[esp+48], eax
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  00060	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 243  : 	v3Light *= 50.0f / D3DXVec3Length(&v3Light);

  00065	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@42480000

; 258  : 	__CollectShadowReceiver(v3Player, v3Light);

  0006d	8d 44 24 10	 lea	 eax, DWORD PTR _v3Light$[esp+40]
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  00071	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 258  : 	__CollectShadowReceiver(v3Player, v3Light);

  00075	8b 75 08	 mov	 esi, DWORD PTR _v3Player$[ebp]
  00078	8b cf		 mov	 ecx, edi
  0007a	50		 push	 eax
  0007b	56		 push	 esi
  0007c	f3 0f 5e c8	 divss	 xmm1, xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 222  :     x *= f;

  00080	0f 28 c1	 movaps	 xmm0, xmm1

; 223  :     y *= f;

  00083	f3 0f 11 4c 24
	1c		 movss	 DWORD PTR _v3Light$[esp+52], xmm1
  00089	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3fddb22d

; 224  :     z *= f;

  00091	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@c05db22d
  00099	f3 0f 11 44 24
	18		 movss	 DWORD PTR _v3Light$[esp+48], xmm0
  0009f	f3 0f 11 4c 24
	20		 movss	 DWORD PTR _v3Light$[esp+56], xmm1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 258  : 	__CollectShadowReceiver(v3Player, v3Light);

  000a5	e8 00 00 00 00	 call	 ?__CollectShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z ; CMapOutdoor::__CollectShadowReceiver

; 259  : #ifdef __PERFORMANCE_CHECKER__
; 260  : 	DWORD t4=timeGetTime();
; 261  : #endif
; 262  : 	__CollectCollisionPCBlocker(v3Eye, v3Player, fDistance);

  000aa	f3 0f 10 44 24
	0c		 movss	 xmm0, DWORD PTR _fDistance$1$[esp+40]
  000b0	8d 44 24 1c	 lea	 eax, DWORD PTR _v3Eye$[esp+40]
  000b4	51		 push	 ecx
  000b5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ba	8b cf		 mov	 ecx, edi
  000bc	56		 push	 esi
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ?__CollectCollisionPCBlocker@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0M@Z ; CMapOutdoor::__CollectCollisionPCBlocker

; 263  : #ifdef __PERFORMANCE_CHECKER__
; 264  : 	DWORD t5=timeGetTime();
; 265  : #endif
; 266  : 	__CollectCollisionShadowReceiver(v3Player, v3Light);

  000c3	8d 44 24 10	 lea	 eax, DWORD PTR _v3Light$[esp+40]
  000c7	8b cf		 mov	 ecx, edi
  000c9	50		 push	 eax
  000ca	56		 push	 esi
  000cb	e8 00 00 00 00	 call	 ?__CollectCollisionShadowReceiver@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@0@Z ; CMapOutdoor::__CollectCollisionShadowReceiver

; 267  : #ifdef __PERFORMANCE_CHECKER__
; 268  : 	DWORD t6=timeGetTime();
; 269  : #endif
; 270  : 	__UpdateAroundAreaList();

  000d0	8b cf		 mov	 ecx, edi
  000d2	e8 00 00 00 00	 call	 ?__UpdateAroundAreaList@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__UpdateAroundAreaList
$LN2@Game_Updat:

; 271  : 
; 272  : #ifdef __PERFORMANCE_CHECKER__
; 273  : 	DWORD t7=timeGetTime();
; 274  : 	{
; 275  : 		static FILE* fp=fopen("perf_area_update.txt", "w");
; 276  : 
; 277  : 		if (t7-t1>5)
; 278  : 		{
; 279  : 			fprintf(fp, "UA.Total %d (Time %f)\n", t3-t1, ELTimer_GetMSec()/1000.0f);
; 280  : 			fprintf(fp, "UA.Clear %d\n", t2-t1);
; 281  : 			fprintf(fp, "UA.Vector %d\n", t3-t2);
; 282  : 			fprintf(fp, "UA.Shadow %d\n", t4-t3);
; 283  : 			fprintf(fp, "UA.Blocker %d\n", t5-t4);
; 284  : 			fprintf(fp, "UA.ColliShadow %d\n", t6-t5);
; 285  : 			fprintf(fp, "UA.Area %d\n", t7-t6);			
; 286  : 			fflush(fp);
; 287  : 		}
; 288  : 	}
; 289  : #endif
; 290  : }

  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 04 00	 ret	 4
?__Game_UpdateArea@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@@Z ENDP ; CMapOutdoor::__Game_UpdateArea
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?__UpdateArea@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_v3Player$ = 8						; size = 4
?__UpdateArea@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@@Z PROC	; CMapOutdoor::__UpdateArea, COMDAT
; _this$ = ecx

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 218  : #endif
; 219  : }

  00003	5d		 pop	 ebp

; 214  : #ifdef WORLD_EDITOR
; 215  : 	__NEW_WorldEditor_UpdateArea();	
; 216  : #else
; 217  : 	__Game_UpdateArea(v3Player);

  00004	e9 00 00 00 00	 jmp	 ?__Game_UpdateArea@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@@Z ; CMapOutdoor::__Game_UpdateArea
?__UpdateArea@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@@Z ENDP	; CMapOutdoor::__UpdateArea
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?AssignPatch@CMapOutdoor@@IAEXJJJJJ@Z
_TEXT	SEGMENT
_pTerrain$ = 8						; size = 4
_lPatchNum$ = 8						; size = 4
_byPatchNumY$ = 12					; size = 1
$T1 = 12						; size = 1
_x0$ = 12						; size = 4
tv242 = 16						; size = 4
_y0$ = 16						; size = 4
_byPatchNumX$ = 20					; size = 1
_x1$ = 20						; size = 4
_y1$ = 24						; size = 4
?AssignPatch@CMapOutdoor@@IAEXJJJJJ@Z PROC		; CMapOutdoor::AssignPatch, COMDAT
; _this$ = ecx

; 986  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 	assert(NULL!=m_pTerrainPatchProxyList && "CMapOutdoor::AssignPatch");
; 988  : 	
; 989  : 	CTerrainPatchProxy * pTerrainPatchProxy = &m_pTerrainPatchProxyList[lPatchNum];

  00003	8b 45 08	 mov	 eax, DWORD PTR _lPatchNum$[ebp]
  00006	53		 push	 ebx

; 990  : 	
; 991  : 	if (y0 < 0 && y1 <= 0)

  00007	8b 5d 10	 mov	 ebx, DWORD PTR _y0$[ebp]
  0000a	56		 push	 esi
  0000b	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00012	2b d0		 sub	 edx, eax
  00014	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00017	57		 push	 edi
  00018	8d 3c 90	 lea	 edi, DWORD PTR [eax+edx*4]
  0001b	8b 45 18	 mov	 eax, DWORD PTR _y1$[ebp]
  0001e	85 db		 test	 ebx, ebx
  00020	79 4b		 jns	 SHORT $LN18@AssignPatc
  00022	85 c0		 test	 eax, eax
  00024	7f 47		 jg	 SHORT $LN18@AssignPatc

; 992  : 	{
; 993  : 		if (x0 < 0 && x1 <= 0)

  00026	8b 75 0c	 mov	 esi, DWORD PTR _x0$[ebp]
  00029	8b 45 14	 mov	 eax, DWORD PTR _x1$[ebp]
  0002c	85 f6		 test	 esi, esi
  0002e	79 13		 jns	 SHORT $LN17@AssignPatc
  00030	85 c0		 test	 eax, eax
  00032	7f 0f		 jg	 SHORT $LN17@AssignPatc

; 994  : 		{
; 995  : 			pTerrainPatchProxy->SetTerrainNum(0);
; 996  : 			x0 += CTerrainImpl::XSIZE;

  00034	83 ee 80	 sub	 esi, -128		; ffffff80H
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 177  : 	void SetTerrainNum(BYTE byTerrainNum)											{ m_byTerrainNum = byTerrainNum; }

  00037	c6 47 08 00	 mov	 BYTE PTR [edi+8], 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1008 : 		y0 += CTerrainImpl::YSIZE;

  0003b	83 eb 80	 sub	 ebx, -128		; ffffff80H

; 1009 : 		y1 += CTerrainImpl::YSIZE;

  0003e	e9 aa 00 00 00	 jmp	 $LN37@AssignPatc
$LN17@AssignPatc:

; 997  : 			x1 += CTerrainImpl::XSIZE;
; 998  : 		}
; 999  : 		else if (x0 >= CTerrainImpl::XSIZE && x1 > CTerrainImpl::XSIZE)

  00043	81 fe 80 00 00
	00		 cmp	 esi, 128		; 00000080H
  00049	7c 16		 jl	 SHORT $LN15@AssignPatc
  0004b	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00050	7e 0f		 jle	 SHORT $LN15@AssignPatc

; 1000 : 		{
; 1001 : 			pTerrainPatchProxy->SetTerrainNum(2);
; 1002 : 			x0 -= CTerrainImpl::XSIZE;

  00052	83 c6 80	 add	 esi, -128		; ffffff80H
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 177  : 	void SetTerrainNum(BYTE byTerrainNum)											{ m_byTerrainNum = byTerrainNum; }

  00055	c6 47 08 02	 mov	 BYTE PTR [edi+8], 2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1008 : 		y0 += CTerrainImpl::YSIZE;

  00059	83 eb 80	 sub	 ebx, -128		; ffffff80H

; 1009 : 		y1 += CTerrainImpl::YSIZE;

  0005c	e9 8c 00 00 00	 jmp	 $LN37@AssignPatc
$LN15@AssignPatc:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 177  : 	void SetTerrainNum(BYTE byTerrainNum)											{ m_byTerrainNum = byTerrainNum; }

  00061	c6 47 08 01	 mov	 BYTE PTR [edi+8], 1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1008 : 		y0 += CTerrainImpl::YSIZE;

  00065	83 eb 80	 sub	 ebx, -128		; ffffff80H

; 1009 : 		y1 += CTerrainImpl::YSIZE;

  00068	e9 80 00 00 00	 jmp	 $LN37@AssignPatc
$LN18@AssignPatc:

; 1010 : 	}
; 1011 : 	else if (y0 >= CTerrainImpl::YSIZE && y1 > CTerrainImpl::YSIZE)

  0006d	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  00073	7c 45		 jl	 SHORT $LN12@AssignPatc
  00075	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0007a	7e 3e		 jle	 SHORT $LN12@AssignPatc

; 1012 : 	{
; 1013 : 		if (x0 < 0 && x1 <= 0)

  0007c	8b 75 0c	 mov	 esi, DWORD PTR _x0$[ebp]
  0007f	8b 45 14	 mov	 eax, DWORD PTR _x1$[ebp]
  00082	85 f6		 test	 esi, esi
  00084	79 10		 jns	 SHORT $LN11@AssignPatc
  00086	85 c0		 test	 eax, eax
  00088	7f 0c		 jg	 SHORT $LN11@AssignPatc

; 1014 : 		{
; 1015 : 			pTerrainPatchProxy->SetTerrainNum(6);
; 1016 : 			x0 += CTerrainImpl::XSIZE;

  0008a	83 ee 80	 sub	 esi, -128		; ffffff80H
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 177  : 	void SetTerrainNum(BYTE byTerrainNum)											{ m_byTerrainNum = byTerrainNum; }

  0008d	c6 47 08 06	 mov	 BYTE PTR [edi+8], 6
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1028 : 		y0 -= CTerrainImpl::YSIZE;

  00091	83 c3 80	 add	 ebx, -128		; ffffff80H

; 1029 : 		y1 -= CTerrainImpl::YSIZE;
; 1030 : 	}
; 1031 : 	else

  00094	eb 57		 jmp	 SHORT $LN37@AssignPatc
$LN11@AssignPatc:

; 1017 : 			x1 += CTerrainImpl::XSIZE;
; 1018 : 		}
; 1019 : 		else if (x0 >= CTerrainImpl::XSIZE && x1 > CTerrainImpl::XSIZE)

  00096	81 fe 80 00 00
	00		 cmp	 esi, 128		; 00000080H
  0009c	7c 13		 jl	 SHORT $LN9@AssignPatc
  0009e	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000a3	7e 0c		 jle	 SHORT $LN9@AssignPatc

; 1020 : 		{
; 1021 : 			pTerrainPatchProxy->SetTerrainNum(8);
; 1022 : 			x0 -= CTerrainImpl::XSIZE;

  000a5	83 c6 80	 add	 esi, -128		; ffffff80H
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 177  : 	void SetTerrainNum(BYTE byTerrainNum)											{ m_byTerrainNum = byTerrainNum; }

  000a8	c6 47 08 08	 mov	 BYTE PTR [edi+8], 8
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1028 : 		y0 -= CTerrainImpl::YSIZE;

  000ac	83 c3 80	 add	 ebx, -128		; ffffff80H

; 1029 : 		y1 -= CTerrainImpl::YSIZE;
; 1030 : 	}
; 1031 : 	else

  000af	eb 3c		 jmp	 SHORT $LN37@AssignPatc
$LN9@AssignPatc:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 177  : 	void SetTerrainNum(BYTE byTerrainNum)											{ m_byTerrainNum = byTerrainNum; }

  000b1	c6 47 08 07	 mov	 BYTE PTR [edi+8], 7
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1028 : 		y0 -= CTerrainImpl::YSIZE;

  000b5	83 c3 80	 add	 ebx, -128		; ffffff80H

; 1029 : 		y1 -= CTerrainImpl::YSIZE;
; 1030 : 	}
; 1031 : 	else

  000b8	eb 33		 jmp	 SHORT $LN37@AssignPatc
$LN12@AssignPatc:

; 1032 : 	{
; 1033 : 		if (x0 < 0 && x1 <= 0)

  000ba	8b 75 0c	 mov	 esi, DWORD PTR _x0$[ebp]
  000bd	8b 45 14	 mov	 eax, DWORD PTR _x1$[ebp]
  000c0	85 f6		 test	 esi, esi
  000c2	79 0d		 jns	 SHORT $LN6@AssignPatc
  000c4	85 c0		 test	 eax, eax
  000c6	7f 09		 jg	 SHORT $LN6@AssignPatc
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 177  : 	void SetTerrainNum(BYTE byTerrainNum)											{ m_byTerrainNum = byTerrainNum; }

  000c8	c6 47 08 03	 mov	 BYTE PTR [edi+8], 3
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1036 : 			x0 += CTerrainImpl::XSIZE;

  000cc	83 ee 80	 sub	 esi, -128		; ffffff80H

; 1037 : 			x1 += CTerrainImpl::XSIZE;

  000cf	eb 1c		 jmp	 SHORT $LN37@AssignPatc
$LN6@AssignPatc:

; 1038 : 		}
; 1039 : 		else if (x0 >= CTerrainImpl::XSIZE && x1 > CTerrainImpl::XSIZE)

  000d1	81 fe 80 00 00
	00		 cmp	 esi, 128		; 00000080H
  000d7	7c 10		 jl	 SHORT $LN4@AssignPatc
  000d9	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000de	7e 09		 jle	 SHORT $LN4@AssignPatc
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 177  : 	void SetTerrainNum(BYTE byTerrainNum)											{ m_byTerrainNum = byTerrainNum; }

  000e0	c6 47 08 05	 mov	 BYTE PTR [edi+8], 5
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1042 : 			x0 -= CTerrainImpl::XSIZE;

  000e4	83 c6 80	 add	 esi, -128		; ffffff80H

; 1043 : 			x1 -= CTerrainImpl::XSIZE;
; 1044 : 		}
; 1045 : 		else

  000e7	eb 04		 jmp	 SHORT $LN37@AssignPatc
$LN4@AssignPatc:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 177  : 	void SetTerrainNum(BYTE byTerrainNum)											{ m_byTerrainNum = byTerrainNum; }

  000e9	c6 47 08 04	 mov	 BYTE PTR [edi+8], 4
$LN37@AssignPatc:

; 175  : 
; 176  : 	BYTE GetTerrainNum()															{ return m_byTerrainNum; }

  000ed	8a 47 08	 mov	 al, BYTE PTR [edi+8]
  000f0	88 45 0c	 mov	 BYTE PTR $T1[ebp], al
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1050 : 	if (!GetTerrainPointer(pTerrainPatchProxy->GetTerrainNum(), &pTerrain))

  000f3	8d 45 08	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  000f6	50		 push	 eax
  000f7	ff 75 0c	 push	 DWORD PTR $T1[ebp]
  000fa	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  000ff	85 c0		 test	 eax, eax
  00101	74 4f		 je	 SHORT $LN45@AssignPatc

; 1051 : 		return;
; 1052 : 
; 1053 : 	BYTE byPatchNumX, byPatchNumY;
; 1054 : 	byPatchNumX = x0 / CTerrainImpl::PATCH_XSIZE;
; 1055 : 	byPatchNumY = y0 / CTerrainImpl::PATCH_YSIZE;
; 1056 : 	
; 1057 : 	CTerrainPatch * pTerrainPatch = pTerrain->GetTerrainPatchPtr(byPatchNumX, byPatchNumY);

  00103	8b 4d 08	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00106	8b c6		 mov	 eax, esi
  00108	99		 cdq
  00109	83 e2 0f	 and	 edx, 15			; 0000000fH
  0010c	03 c2		 add	 eax, edx
  0010e	c1 f8 04	 sar	 eax, 4
  00111	88 45 14	 mov	 BYTE PTR _byPatchNumX$[ebp], al
  00114	89 45 10	 mov	 DWORD PTR tv242[ebp], eax
  00117	8b c3		 mov	 eax, ebx
  00119	99		 cdq
  0011a	83 e2 0f	 and	 edx, 15			; 0000000fH
  0011d	8d 1c 02	 lea	 ebx, DWORD PTR [edx+eax]
  00120	c1 fb 04	 sar	 ebx, 4
  00123	88 5d 0c	 mov	 BYTE PTR _byPatchNumY$[ebp], bl
  00126	ff 75 0c	 push	 DWORD PTR _byPatchNumY$[ebp]
  00129	ff 75 14	 push	 DWORD PTR _byPatchNumX$[ebp]
  0012c	e8 00 00 00 00	 call	 ?GetTerrainPatchPtr@CTerrain@@QAEPAVCTerrainPatch@@EE@Z ; CTerrain::GetTerrainPatchPtr
  00131	8b f0		 mov	 esi, eax

; 1058 : 	if (!pTerrainPatch)

  00133	85 f6		 test	 esi, esi
  00135	74 1b		 je	 SHORT $LN45@AssignPatc
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 174  : 	void SetPatchNum(short sPatchNum)												{ m_sPatchNum = sPatchNum; }

  00137	8b 45 10	 mov	 eax, DWORD PTR tv242[ebp]
  0013a	0f b6 d3	 movzx	 edx, bl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1061 : 	pTerrainPatchProxy->SetPatchNum(byPatchNumY * CTerrainImpl::PATCH_XCOUNT + byPatchNumX);

  0013d	66 c1 e2 03	 shl	 dx, 3
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 174  : 	void SetPatchNum(short sPatchNum)												{ m_sPatchNum = sPatchNum; }

  00141	0f b6 c8	 movzx	 ecx, al
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1061 : 	pTerrainPatchProxy->SetPatchNum(byPatchNumY * CTerrainImpl::PATCH_XCOUNT + byPatchNumX);

  00144	66 03 d1	 add	 dx, cx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 179  : 	void SetTerrainPatch(CTerrainPatch * pTerrainPatch)								{ m_pTerrainPatch = pTerrainPatch;}

  00147	89 77 0c	 mov	 DWORD PTR [edi+12], esi

; 174  : 	void SetPatchNum(short sPatchNum)												{ m_sPatchNum = sPatchNum; }

  0014a	66 89 57 06	 mov	 WORD PTR [edi+6], dx

; 171  : 	void SetUsed(bool bUsed)														{ m_bUsed = bUsed; }

  0014e	c6 47 04 01	 mov	 BYTE PTR [edi+4], 1
$LN45@AssignPatc:
  00152	5f		 pop	 edi
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 1064 : }

  00155	5d		 pop	 ebp
  00156	c2 14 00	 ret	 20			; 00000014H
?AssignPatch@CMapOutdoor@@IAEXJJJJJ@Z ENDP		; CMapOutdoor::AssignPatch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?ConvertTerrainToTnL@CMapOutdoor@@IAEXJJ@Z
_TEXT	SEGMENT
_yw$1$ = -24						; size = 4
_ex$1$ = -20						; size = 4
_ey$1$ = -16						; size = 4
_this$1$ = -12						; size = 4
_xw$1$ = -8						; size = 4
_yp$1$ = -4						; size = 4
_lx$ = 8						; size = 4
_ly$ = 12						; size = 4
?ConvertTerrainToTnL@CMapOutdoor@@IAEXJJ@Z PROC		; CMapOutdoor::ConvertTerrainToTnL, COMDAT
; _this$ = ecx

; 943  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 946  : 	for (long i = 0; i < m_wPatchCount * m_wPatchCount; i++)

  0000a	33 d2		 xor	 edx, edx
  0000c	57		 push	 edi
  0000d	89 75 f4	 mov	 DWORD PTR _this$1$[ebp], esi
  00010	0f b7 86 8c 00
	00 00		 movzx	 eax, WORD PTR [esi+140]
  00017	0f af c0	 imul	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	7e 1c		 jle	 SHORT $LN9@ConvertTer
  0001e	33 c9		 xor	 ecx, ecx
$LL11@ConvertTer:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 171  : 	void SetUsed(bool bUsed)														{ m_bUsed = bUsed; }

  00020	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 946  : 	for (long i = 0; i < m_wPatchCount * m_wPatchCount; i++)

  00023	8d 49 1c	 lea	 ecx, DWORD PTR [ecx+28]
  00026	42		 inc	 edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 171  : 	void SetUsed(bool bUsed)														{ m_bUsed = bUsed; }

  00027	c6 44 08 e8 00	 mov	 BYTE PTR [eax+ecx-24], 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 946  : 	for (long i = 0; i < m_wPatchCount * m_wPatchCount; i++)

  0002c	0f b7 86 8c 00
	00 00		 movzx	 eax, WORD PTR [esi+140]
  00033	0f af c0	 imul	 eax, eax
  00036	3b d0		 cmp	 edx, eax
  00038	7c e6		 jl	 SHORT $LL11@ConvertTer
$LN9@ConvertTer:

; 947  : 		m_pTerrainPatchProxyList[i].SetUsed(false);
; 948  : 
; 949  : 	lx -= m_lViewRadius;          /* Move to the top left corner of the */

  0003a	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  0003d	8b 55 08	 mov	 edx, DWORD PTR _lx$[ebp]

; 950  : 	ly -= m_lViewRadius;          /* input rectangle */

  00040	8b 5d 0c	 mov	 ebx, DWORD PTR _ly$[ebp]
  00043	2b d0		 sub	 edx, eax
  00045	2b d8		 sub	 ebx, eax
  00047	89 55 08	 mov	 DWORD PTR _lx$[ebp], edx

; 951  : 
; 952  : 	long diameter = m_lViewRadius * 2;

  0004a	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  0004d	89 5d 0c	 mov	 DWORD PTR _ly$[ebp], ebx

; 953  : 	
; 954  : 	long x0 = lx / TERRAIN_PATCHSIZE;
; 955  : 	long y0 = ly / TERRAIN_PATCHSIZE;
; 956  : 	long x1 = ( lx + diameter - 1 ) / TERRAIN_PATCHSIZE;
; 957  : 	long y1 = ( ly + diameter - 1 ) / TERRAIN_PATCHSIZE;
; 958  : 
; 959  : 	long xw = x1 - x0 + 1;     /* Figure out how many patches are needed */

  00050	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00053	89 45 ec	 mov	 DWORD PTR _ex$1$[ebp], eax
  00056	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  00059	03 c1		 add	 eax, ecx
  0005b	99		 cdq
  0005c	83 e2 0f	 and	 edx, 15			; 0000000fH
  0005f	8d 3c 02	 lea	 edi, DWORD PTR [edx+eax]
  00062	8b 45 08	 mov	 eax, DWORD PTR _lx$[ebp]
  00065	99		 cdq
  00066	83 e2 0f	 and	 edx, 15			; 0000000fH
  00069	c1 ff 04	 sar	 edi, 4
  0006c	03 c2		 add	 eax, edx
  0006e	c1 f8 04	 sar	 eax, 4
  00071	2b f8		 sub	 edi, eax

; 960  : 	long yw = y1 - y0 + 1;

  00073	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00076	89 45 f0	 mov	 DWORD PTR _ey$1$[ebp], eax
  00079	47		 inc	 edi
  0007a	48		 dec	 eax
  0007b	89 7d f8	 mov	 DWORD PTR _xw$1$[ebp], edi
  0007e	99		 cdq

; 961  : 	
; 962  : 	long ex = lx + diameter;
; 963  : 	long ey = ly + diameter;
; 964  : 	
; 965  : 	y0 = ly;
; 966  : 	for (long yp = 0; yp < yw; yp++)

  0007f	33 ff		 xor	 edi, edi
  00081	83 e2 0f	 and	 edx, 15			; 0000000fH
  00084	89 7d fc	 mov	 DWORD PTR _yp$1$[ebp], edi
  00087	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  0008a	8b c3		 mov	 eax, ebx
  0008c	99		 cdq
  0008d	83 e2 0f	 and	 edx, 15			; 0000000fH
  00090	c1 f9 04	 sar	 ecx, 4
  00093	03 c2		 add	 eax, edx
  00095	c1 f8 04	 sar	 eax, 4
  00098	2b c8		 sub	 ecx, eax
  0009a	41		 inc	 ecx
  0009b	89 4d e8	 mov	 DWORD PTR _yw$1$[ebp], ecx
  0009e	85 c9		 test	 ecx, ecx
  000a0	7e 70		 jle	 SHORT $LN6@ConvertTer
$LL8@ConvertTer:

; 967  :     {
; 968  : 		x0 = lx;

  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _lx$[ebp]

; 969  : 		y1 = (y0 / TERRAIN_PATCHSIZE + 1) * TERRAIN_PATCHSIZE;

  000a5	8b c3		 mov	 eax, ebx
  000a7	99		 cdq
  000a8	83 e2 0f	 and	 edx, 15			; 0000000fH
  000ab	8d 34 02	 lea	 esi, DWORD PTR [edx+eax]
  000ae	c1 fe 04	 sar	 esi, 4
  000b1	46		 inc	 esi
  000b2	c1 e6 04	 shl	 esi, 4

; 970  : 		if (y1 > ey)

  000b5	3b 75 f0	 cmp	 esi, DWORD PTR _ey$1$[ebp]
  000b8	0f 4f 75 f0	 cmovg	 esi, DWORD PTR _ey$1$[ebp]

; 971  : 			y1 = ey;
; 972  : 		for (long xp = 0; xp < xw; xp++)

  000bc	33 db		 xor	 ebx, ebx
  000be	39 5d f8	 cmp	 DWORD PTR _xw$1$[ebp], ebx
  000c1	7e 3e		 jle	 SHORT $LN2@ConvertTer
$LL4@ConvertTer:

; 973  : 		{
; 974  : 			x1 = (x0 / TERRAIN_PATCHSIZE + 1) * TERRAIN_PATCHSIZE;

  000c3	8b c1		 mov	 eax, ecx
  000c5	99		 cdq
  000c6	83 e2 0f	 and	 edx, 15			; 0000000fH

; 975  : 			if (x1 > ex)
; 976  : 				x1 = ex;
; 977  :  			AssignPatch(yp * m_wPatchCount + xp, x0, y0, x1, y1);

  000c9	56		 push	 esi
  000ca	8d 3c 02	 lea	 edi, DWORD PTR [edx+eax]
  000cd	c1 ff 04	 sar	 edi, 4
  000d0	47		 inc	 edi
  000d1	c1 e7 04	 shl	 edi, 4
  000d4	3b 7d ec	 cmp	 edi, DWORD PTR _ex$1$[ebp]
  000d7	0f 4f 7d ec	 cmovg	 edi, DWORD PTR _ex$1$[ebp]
  000db	57		 push	 edi
  000dc	ff 75 0c	 push	 DWORD PTR _ly$[ebp]
  000df	51		 push	 ecx
  000e0	8b 4d f4	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000e3	0f b7 81 8c 00
	00 00		 movzx	 eax, WORD PTR [ecx+140]
  000ea	0f af 45 fc	 imul	 eax, DWORD PTR _yp$1$[ebp]
  000ee	03 c3		 add	 eax, ebx
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?AssignPatch@CMapOutdoor@@IAEXJJJJJ@Z ; CMapOutdoor::AssignPatch
  000f6	43		 inc	 ebx

; 978  : 			x0 = x1;

  000f7	8b cf		 mov	 ecx, edi
  000f9	3b 5d f8	 cmp	 ebx, DWORD PTR _xw$1$[ebp]
  000fc	7c c5		 jl	 SHORT $LL4@ConvertTer
  000fe	8b 7d fc	 mov	 edi, DWORD PTR _yp$1$[ebp]
$LN2@ConvertTer:

; 961  : 	
; 962  : 	long ex = lx + diameter;
; 963  : 	long ey = ly + diameter;
; 964  : 	
; 965  : 	y0 = ly;
; 966  : 	for (long yp = 0; yp < yw; yp++)

  00101	47		 inc	 edi

; 979  : 		}
; 980  : 		y0 = y1;

  00102	8b de		 mov	 ebx, esi
  00104	89 5d 0c	 mov	 DWORD PTR _ly$[ebp], ebx
  00107	89 7d fc	 mov	 DWORD PTR _yp$1$[ebp], edi
  0010a	3b 7d e8	 cmp	 edi, DWORD PTR _yw$1$[ebp]
  0010d	7c 93		 jl	 SHORT $LL8@ConvertTer
  0010f	8b 75 f4	 mov	 esi, DWORD PTR _this$1$[ebp]
$LN6@ConvertTer:

; 981  :     }
; 982  : 	UpdateQuadTreeHeights(m_pRootNode);

  00112	ff b6 14 01 00
	00		 push	 DWORD PTR [esi+276]
  00118	8b ce		 mov	 ecx, esi
  0011a	e8 00 00 00 00	 call	 ?UpdateQuadTreeHeights@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@@Z ; CMapOutdoor::UpdateQuadTreeHeights
  0011f	5f		 pop	 edi
  00120	5e		 pop	 esi
  00121	5b		 pop	 ebx

; 983  : }

  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c2 08 00	 ret	 8
?ConvertTerrainToTnL@CMapOutdoor@@IAEXJJ@Z ENDP		; CMapOutdoor::ConvertTerrainToTnL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?UpdateTerrain@CMapOutdoor@@IAEXMM@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_fX$ = 8						; size = 4
tv206 = 12						; size = 4
_fY$ = 12						; size = 4
?UpdateTerrain@CMapOutdoor@@IAEXMM@Z PROC		; CMapOutdoor::UpdateTerrain, COMDAT
; _this$ = ecx

; 723  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 724  : 	if (fY < 0)

  00004	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _fY$[ebp]
  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	0f 2f c1	 comiss	 xmm0, xmm1
  0000f	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00012	76 07		 jbe	 SHORT $LN3@UpdateTerr

; 725  : 		fY = -fY;

  00014	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
$LN3@UpdateTerr:

; 726  : 
; 727  : 	int sx, sy;
; 728  : 	PR_FLOAT_TO_INT(fX, sx);

  0001b	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fX$[ebp]
  00020	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00028	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  0002e	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  00034	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0003a	66 0f 6e c2	 movd	 xmm0, edx
  0003e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00041	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  00048	76 01		 jbe	 SHORT $LN6@UpdateTerr
  0004a	4a		 dec	 edx
$LN6@UpdateTerr:
  0004b	56		 push	 esi
  0004c	57		 push	 edi

; 729  : 	PR_FLOAT_TO_INT(fY, sy);

  0004d	f3 0f 11 0d 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm1
  00055	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  0005b	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  00061	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00067	66 0f 6e c6	 movd	 xmm0, esi
  0006b	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0006e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  00075	76 01		 jbe	 SHORT $LN8@UpdateTerr
  00077	4e		 dec	 esi
$LN8@UpdateTerr:

; 730  : 
; 731  : 	long lDivider = (CTerrainImpl::CELLSCALE * TERRAIN_PATCHSIZE);
; 732  : 
; 733  : 	m_lCenterX = (sx - m_lCurCoordStartX) / lDivider;

  00078	2b 51 78	 sub	 edx, DWORD PTR [ecx+120]
  0007b	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH

; 734  : 	m_lCenterY = (sy - m_lCurCoordStartY) / lDivider;

  00080	2b 71 7c	 sub	 esi, DWORD PTR [ecx+124]
  00083	f7 ea		 imul	 edx
  00085	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0008a	c1 fa 0a	 sar	 edx, 10			; 0000000aH
  0008d	8b fa		 mov	 edi, edx
  0008f	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00092	03 fa		 add	 edi, edx
  00094	f7 ee		 imul	 esi
  00096	89 7d 0c	 mov	 DWORD PTR tv206[ebp], edi
  00099	c1 fa 0a	 sar	 edx, 10			; 0000000aH
  0009c	8b c2		 mov	 eax, edx
  0009e	89 b9 04 01 00
	00		 mov	 DWORD PTR [ecx+260], edi
  000a4	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000a7	03 c2		 add	 eax, edx
  000a9	89 81 08 01 00
	00		 mov	 DWORD PTR [ecx+264], eax

; 735  : 	
; 736  : 	if ((m_lCenterX != m_lOldReadX) || (m_lCenterY != m_lOldReadY))

  000af	3b b9 0c 01 00
	00		 cmp	 edi, DWORD PTR [ecx+268]
  000b5	75 08		 jne	 SHORT $LN1@UpdateTerr
  000b7	3b 81 10 01 00
	00		 cmp	 eax, DWORD PTR [ecx+272]
  000bd	74 28		 je	 SHORT $LN2@UpdateTerr
$LN1@UpdateTerr:

; 737  : 	{
; 738  : 		long lRealCenterX = m_lCenterX * TERRAIN_PATCHSIZE;
; 739  : 		long lRealCenterY = m_lCenterY * TERRAIN_PATCHSIZE;
; 740  : 		m_lOldReadX = m_lCenterX; 

  000bf	8b 55 0c	 mov	 edx, DWORD PTR tv206[ebp]
  000c2	8b f0		 mov	 esi, eax
  000c4	c1 e6 04	 shl	 esi, 4

; 741  : 		m_lOldReadY = m_lCenterY;
; 742  : 		
; 743  : 		ConvertTerrainToTnL(lRealCenterX, lRealCenterY);

  000c7	56		 push	 esi
  000c8	c1 e7 04	 shl	 edi, 4
  000cb	57		 push	 edi
  000cc	89 91 0c 01 00
	00		 mov	 DWORD PTR [ecx+268], edx
  000d2	89 81 10 01 00
	00		 mov	 DWORD PTR [ecx+272], eax
  000d8	e8 00 00 00 00	 call	 ?ConvertTerrainToTnL@CMapOutdoor@@IAEXJJ@Z ; CMapOutdoor::ConvertTerrainToTnL

; 744  : 		UpdateAreaList(lRealCenterX, lRealCenterY);

  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000e0	56		 push	 esi
  000e1	57		 push	 edi
  000e2	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e4	ff 50 4c	 call	 DWORD PTR [eax+76]
$LN2@UpdateTerr:
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi

; 745  : 		//Tracef(" Area, Terrain : (%d, %d),  Area, Terrain : (%d, %d)\n",
; 746  : 		//	m_AreaVector.size(), m_TerrainVector.size(), m_AreaDeleteVector.size(), m_TerrainDeleteVector.size());		
; 747  : 	}
; 748  : }

  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 08 00	 ret	 8
?UpdateTerrain@CMapOutdoor@@IAEXMM@Z ENDP		; CMapOutdoor::UpdateTerrain
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z
_TEXT	SEGMENT
_$S2$ = -60						; size = 24
_$S3$ = -36						; size = 24
__$EHRec$ = -12						; size = 12
_dwIndex$1$ = 8						; size = 4
_dwIndex$1$ = 8						; size = 4
_eDeleteLRDir$1$ = 8					; size = 4
_lCenterX$ = 8						; size = 4
_lCenterY$ = 12						; size = 4
?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z PROC		; CMapOutdoor::UpdateAreaList, COMDAT
; _this$ = ecx

; 878  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0002a	8b 87 1c 09 00
	00		 mov	 eax, DWORD PTR [edi+2332]
  00030	2b 87 18 09 00
	00		 sub	 eax, DWORD PTR [edi+2328]
  00036	c1 f8 02	 sar	 eax, 2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 879  : 	if (m_TerrainVector.size() <= AROUND_AREA_NUM && m_AreaVector.size() <= AROUND_AREA_NUM)

  00039	83 f8 09	 cmp	 eax, 9
  0003c	77 18		 ja	 SHORT $LN21@UpdateArea
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0003e	8b 87 50 09 00
	00		 mov	 eax, DWORD PTR [edi+2384]
  00044	2b 87 4c 09 00
	00		 sub	 eax, DWORD PTR [edi+2380]
  0004a	c1 f8 02	 sar	 eax, 2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 879  : 	if (m_TerrainVector.size() <= AROUND_AREA_NUM && m_AreaVector.size() <= AROUND_AREA_NUM)

  0004d	83 f8 09	 cmp	 eax, 9
  00050	0f 86 4c 02 00
	00		 jbe	 $LN319@UpdateArea
$LN21@UpdateArea:

; 880  : 		return;
; 881  : 
; 882  : 	__ClearGarvage();

  00056	8b 07		 mov	 eax, DWORD PTR [edi]
  00058	ff 50 3c	 call	 DWORD PTR [eax+60]

; 896  : 		FPushTerrainToDeleteVector(eDeleteLRDir, eDeleteTBDir, m_CurCoordinate));

  0005b	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  0005e	33 d2		 xor	 edx, edx
  00060	83 7d 08 40	 cmp	 DWORD PTR _lCenterX$[ebp], 64 ; 00000040H
  00064	0f 9e c2	 setle	 dl
  00067	33 db		 xor	 ebx, ebx
  00069	83 7d 0c 40	 cmp	 DWORD PTR _lCenterY$[ebp], 64 ; 00000040H
  0006d	89 55 08	 mov	 DWORD PTR _eDeleteLRDir$1$[ebp], edx
  00070	0f 9e c3	 setle	 bl
  00073	83 ec 18	 sub	 esp, 24			; 00000018H
  00076	8b cc		 mov	 ecx, esp
  00078	83 c3 02	 add	 ebx, 2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 514  : 				m_CurCoordinate = CurCoord;

  0007b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0007e	89 11		 mov	 DWORD PTR [ecx], edx
  00080	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00083	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 483  : 		_Mylast = pointer();

  0008a	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 484  : 		_Myend = pointer();

  00091	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00098	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0009b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 896  : 		FPushTerrainToDeleteVector(eDeleteLRDir, eDeleteTBDir, m_CurCoordinate));

  0009e	8d 45 c4	 lea	 eax, DWORD PTR _$S2$[ebp]
  000a1	ff b7 1c 09 00
	00		 push	 DWORD PTR [edi+2332]
  000a7	ff b7 18 09 00
	00		 push	 DWORD PTR [edi+2328]
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@UFPushTerrainToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushTerrainToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@0U12@@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,CMapOutdoor::FPushTerrainToDeleteVector>

; 898  : 		FPushAreaToDeleteVector(eDeleteLRDir, eDeleteTBDir, m_CurCoordinate));

  000b3	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  000b6	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 512  : 				m_eLRDeleteDir = eLRDeleteDir;

  000b9	8b 55 08	 mov	 edx, DWORD PTR _eDeleteLRDir$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 898  : 		FPushAreaToDeleteVector(eDeleteLRDir, eDeleteTBDir, m_CurCoordinate));

  000bc	8b cc		 mov	 ecx, esp
  000be	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 514  : 				m_CurCoordinate = CurCoord;

  000c5	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  000c8	89 11		 mov	 DWORD PTR [ecx], edx
  000ca	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  000cd	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 483  : 		_Mylast = pointer();

  000d4	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 484  : 		_Myend = pointer();

  000db	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  000e2	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000e5	89 41 10	 mov	 DWORD PTR [ecx+16], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 898  : 		FPushAreaToDeleteVector(eDeleteLRDir, eDeleteTBDir, m_CurCoordinate));

  000e8	8d 45 dc	 lea	 eax, DWORD PTR _$S3$[ebp]
  000eb	ff b7 50 09 00
	00		 push	 DWORD PTR [edi+2384]
  000f1	ff b7 4c 09 00
	00		 push	 DWORD PTR [edi+2380]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@UFPushAreaToDeleteVector@CMapOutdoor@@@std@@YA?AUFPushAreaToDeleteVector@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@0U12@@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,CMapOutdoor::FPushAreaToDeleteVector>
  000fd	83 c4 24	 add	 esp, 36			; 00000024H
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00100	8b 55 d0	 mov	 edx, DWORD PTR _$S2$[ebp+12]
  00103	8b 45 d4	 mov	 eax, DWORD PTR _$S2$[ebp+16]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 898  : 		FPushAreaToDeleteVector(eDeleteLRDir, eDeleteTBDir, m_CurCoordinate));

  00106	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  0010a	3b d0		 cmp	 edx, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 900  : 	if (!rPushTerrainToDeleteVector.m_ReturnTerrainVector.empty())

  0010c	0f 84 ab 00 00
	00		 je	 $LN13@UpdateArea
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00112	2b c2		 sub	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 902  : 		m_TerrainDeleteVector.resize(rPushTerrainToDeleteVector.m_ReturnTerrainVector.size());

  00114	8d 8f 24 09 00
	00		 lea	 ecx, DWORD PTR [edi+2340]
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0011a	c1 f8 02	 sar	 eax, 2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 902  : 		m_TerrainDeleteVector.resize(rPushTerrainToDeleteVector.m_ReturnTerrainVector.size());

  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?resize@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::resize
; File a:\vs\vc\include\xutility

; 2054 : 	ptrdiff_t _Count = _Last - _First;

  00123	8b 45 d4	 mov	 eax, DWORD PTR _$S2$[ebp+16]
  00126	8b 4d d0	 mov	 ecx, DWORD PTR _$S2$[ebp+12]
  00129	2b c1		 sub	 eax, ecx

; 2056 : 		_Count * sizeof (*_First));

  0012b	83 e0 fc	 and	 eax, -4			; fffffffcH
  0012e	50		 push	 eax
  0012f	51		 push	 ecx
  00130	ff b7 24 09 00
	00		 push	 DWORD PTR [edi+2340]
  00136	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0013b	8b 5d d4	 mov	 ebx, DWORD PTR _$S2$[ebp+16]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 905  : 		for (DWORD dwIndex = 0; dwIndex < rPushTerrainToDeleteVector.m_ReturnTerrainVector.size(); ++dwIndex)

  0013e	33 c9		 xor	 ecx, ecx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00140	8b 55 d0	 mov	 edx, DWORD PTR _$S2$[ebp+12]
  00143	8b c3		 mov	 eax, ebx
  00145	2b c2		 sub	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 905  : 		for (DWORD dwIndex = 0; dwIndex < rPushTerrainToDeleteVector.m_ReturnTerrainVector.size(); ++dwIndex)

  00147	89 4d 08	 mov	 DWORD PTR _dwIndex$1$[ebp], ecx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0014a	c1 f8 02	 sar	 eax, 2
; File a:\vs\vc\include\xutility

; 2056 : 		_Count * sizeof (*_First));

  0014d	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 905  : 		for (DWORD dwIndex = 0; dwIndex < rPushTerrainToDeleteVector.m_ReturnTerrainVector.size(); ++dwIndex)

  00150	85 c0		 test	 eax, eax
  00152	74 69		 je	 SHORT $LN13@UpdateArea
  00154	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL15@UpdateArea:
; File a:\vs\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

  00160	8b b7 18 09 00
	00		 mov	 esi, DWORD PTR [edi+2328]

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00166	3b b7 1c 09 00
	00		 cmp	 esi, DWORD PTR [edi+2332]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 909  : 			while(aTerrainPtrItertor != m_TerrainVector.end())

  0016c	74 40		 je	 SHORT $LN14@UpdateArea

; 906  : 		{
; 907  : 			bool isDel=false;
; 908  : 			TTerrainPtrVectorIterator aTerrainPtrItertor = m_TerrainVector.begin();

  0016e	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
$LL12@UpdateArea:

; 910  : 			{
; 911  : 				CTerrain * pTerrain = *aTerrainPtrItertor;
; 912  : 				if (pTerrain == rPushTerrainToDeleteVector.m_ReturnTerrainVector[dwIndex])

  00171	8b 06		 mov	 eax, DWORD PTR [esi]
  00173	3b 04 8a	 cmp	 eax, DWORD PTR [edx+ecx*4]
  00176	75 25		 jne	 SHORT $LN10@UpdateArea
; File a:\vs\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  00178	8b 87 1c 09 00
	00		 mov	 eax, DWORD PTR [edi+2332]
  0017e	2b c3		 sub	 eax, ebx

; 2431 : 		_Count * sizeof (*_First));

  00180	83 e0 fc	 and	 eax, -4			; fffffffcH
  00183	50		 push	 eax
  00184	53		 push	 ebx
  00185	56		 push	 esi
  00186	e8 00 00 00 00	 call	 _memmove
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 917  : 				else

  0018b	8b 55 d0	 mov	 edx, DWORD PTR _$S2$[ebp+12]
; File a:\vs\vc\include\xutility

; 2431 : 		_Count * sizeof (*_First));

  0018e	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1456 : 		--this->_Mylast;

  00191	83 87 1c 09 00
	00 fc		 add	 DWORD PTR [edi+2332], -4 ; fffffffcH
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 917  : 				else

  00198	8b 4d 08	 mov	 ecx, DWORD PTR _dwIndex$1$[ebp]
  0019b	eb 06		 jmp	 SHORT $LN196@UpdateArea
$LN10@UpdateArea:
; File a:\vs\vc\include\vector

; 112  : 		++this->_Ptr;

  0019d	83 c6 04	 add	 esi, 4
  001a0	83 c3 04	 add	 ebx, 4
$LN196@UpdateArea:

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  001a3	3b b7 1c 09 00
	00		 cmp	 esi, DWORD PTR [edi+2332]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 909  : 			while(aTerrainPtrItertor != m_TerrainVector.end())

  001a9	75 c6		 jne	 SHORT $LL12@UpdateArea
  001ab	8b 5d d4	 mov	 ebx, DWORD PTR _$S2$[ebp+16]
$LN14@UpdateArea:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  001ae	8b c3		 mov	 eax, ebx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 905  : 		for (DWORD dwIndex = 0; dwIndex < rPushTerrainToDeleteVector.m_ReturnTerrainVector.size(); ++dwIndex)

  001b0	41		 inc	 ecx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  001b1	2b c2		 sub	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 905  : 		for (DWORD dwIndex = 0; dwIndex < rPushTerrainToDeleteVector.m_ReturnTerrainVector.size(); ++dwIndex)

  001b3	89 4d 08	 mov	 DWORD PTR _dwIndex$1$[ebp], ecx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  001b6	c1 f8 02	 sar	 eax, 2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 905  : 		for (DWORD dwIndex = 0; dwIndex < rPushTerrainToDeleteVector.m_ReturnTerrainVector.size(); ++dwIndex)

  001b9	3b c8		 cmp	 ecx, eax
  001bb	72 a3		 jb	 SHORT $LL15@UpdateArea
$LN13@UpdateArea:
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  001bd	8b 4d e8	 mov	 ecx, DWORD PTR _$S3$[ebp+12]
  001c0	8b 45 ec	 mov	 eax, DWORD PTR _$S3$[ebp+16]
  001c3	3b c8		 cmp	 ecx, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 922  : 	if (!rPushAreaToDeleteVector.m_ReturnAreaVector.empty())

  001c5	0f 84 a5 00 00
	00		 je	 $LN5@UpdateArea
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  001cb	2b c1		 sub	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 924  : 		m_AreaDeleteVector.resize(rPushAreaToDeleteVector.m_ReturnAreaVector.size());

  001cd	8d 8f 58 09 00
	00		 lea	 ecx, DWORD PTR [edi+2392]
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  001d3	c1 f8 02	 sar	 eax, 2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 924  : 		m_AreaDeleteVector.resize(rPushAreaToDeleteVector.m_ReturnAreaVector.size());

  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 ?resize@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXI@Z ; std::vector<CArea *,std::allocator<CArea *> >::resize
; File a:\vs\vc\include\xutility

; 2054 : 	ptrdiff_t _Count = _Last - _First;

  001dc	8b 45 ec	 mov	 eax, DWORD PTR _$S3$[ebp+16]
  001df	8b 4d e8	 mov	 ecx, DWORD PTR _$S3$[ebp+12]
  001e2	2b c1		 sub	 eax, ecx

; 2056 : 		_Count * sizeof (*_First));

  001e4	83 e0 fc	 and	 eax, -4			; fffffffcH
  001e7	50		 push	 eax
  001e8	51		 push	 ecx
  001e9	ff b7 58 09 00
	00		 push	 DWORD PTR [edi+2392]
  001ef	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  001f4	8b 5d ec	 mov	 ebx, DWORD PTR _$S3$[ebp+16]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 927  : 		for (DWORD dwIndex = 0; dwIndex < rPushAreaToDeleteVector.m_ReturnAreaVector.size(); ++dwIndex)

  001f7	33 d2		 xor	 edx, edx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  001f9	8b 4d e8	 mov	 ecx, DWORD PTR _$S3$[ebp+12]
  001fc	8b c3		 mov	 eax, ebx
  001fe	2b c1		 sub	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 927  : 		for (DWORD dwIndex = 0; dwIndex < rPushAreaToDeleteVector.m_ReturnAreaVector.size(); ++dwIndex)

  00200	89 55 08	 mov	 DWORD PTR _dwIndex$1$[ebp], edx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00203	c1 f8 02	 sar	 eax, 2
; File a:\vs\vc\include\xutility

; 2056 : 		_Count * sizeof (*_First));

  00206	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 927  : 		for (DWORD dwIndex = 0; dwIndex < rPushAreaToDeleteVector.m_ReturnAreaVector.size(); ++dwIndex)

  00209	85 c0		 test	 eax, eax
  0020b	74 60		 je	 SHORT $LN344@UpdateArea
  0020d	8d 49 00	 npad	 3
$LL7@UpdateArea:
; File a:\vs\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

  00210	8b b7 4c 09 00
	00		 mov	 esi, DWORD PTR [edi+2380]

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00216	3b b7 50 09 00
	00		 cmp	 esi, DWORD PTR [edi+2384]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 930  : 			while(aAreaPtrItertor != m_AreaVector.end())

  0021c	74 40		 je	 SHORT $LN6@UpdateArea

; 928  : 		{
; 929  : 			TAreaPtrVectorIterator aAreaPtrItertor = m_AreaVector.begin();

  0021e	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
$LL4@UpdateArea:

; 931  : 			{
; 932  : 				CArea * pArea = *aAreaPtrItertor;
; 933  : 				if (pArea == rPushAreaToDeleteVector.m_ReturnAreaVector[dwIndex])

  00221	8b 06		 mov	 eax, DWORD PTR [esi]
  00223	3b 04 91	 cmp	 eax, DWORD PTR [ecx+edx*4]
  00226	75 25		 jne	 SHORT $LN2@UpdateArea
; File a:\vs\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  00228	8b 87 50 09 00
	00		 mov	 eax, DWORD PTR [edi+2384]
  0022e	2b c3		 sub	 eax, ebx

; 2431 : 		_Count * sizeof (*_First));

  00230	83 e0 fc	 and	 eax, -4			; fffffffcH
  00233	50		 push	 eax
  00234	53		 push	 ebx
  00235	56		 push	 esi
  00236	e8 00 00 00 00	 call	 _memmove
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 935  : 				else

  0023b	8b 4d e8	 mov	 ecx, DWORD PTR _$S3$[ebp+12]
; File a:\vs\vc\include\xutility

; 2431 : 		_Count * sizeof (*_First));

  0023e	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1456 : 		--this->_Mylast;

  00241	83 87 50 09 00
	00 fc		 add	 DWORD PTR [edi+2384], -4 ; fffffffcH
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 935  : 				else

  00248	8b 55 08	 mov	 edx, DWORD PTR _dwIndex$1$[ebp]
  0024b	eb 06		 jmp	 SHORT $LN298@UpdateArea
$LN2@UpdateArea:
; File a:\vs\vc\include\vector

; 112  : 		++this->_Ptr;

  0024d	83 c6 04	 add	 esi, 4
  00250	83 c3 04	 add	 ebx, 4
$LN298@UpdateArea:

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00253	3b b7 50 09 00
	00		 cmp	 esi, DWORD PTR [edi+2384]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 930  : 			while(aAreaPtrItertor != m_AreaVector.end())

  00259	75 c6		 jne	 SHORT $LL4@UpdateArea
  0025b	8b 5d ec	 mov	 ebx, DWORD PTR _$S3$[ebp+16]
$LN6@UpdateArea:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0025e	8b c3		 mov	 eax, ebx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 927  : 		for (DWORD dwIndex = 0; dwIndex < rPushAreaToDeleteVector.m_ReturnAreaVector.size(); ++dwIndex)

  00260	42		 inc	 edx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00261	2b c1		 sub	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 927  : 		for (DWORD dwIndex = 0; dwIndex < rPushAreaToDeleteVector.m_ReturnAreaVector.size(); ++dwIndex)

  00263	89 55 08	 mov	 DWORD PTR _dwIndex$1$[ebp], edx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00266	c1 f8 02	 sar	 eax, 2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 927  : 		for (DWORD dwIndex = 0; dwIndex < rPushAreaToDeleteVector.m_ReturnAreaVector.size(); ++dwIndex)

  00269	3b d0		 cmp	 edx, eax
  0026b	72 a3		 jb	 SHORT $LL7@UpdateArea
$LN344@UpdateArea:
  0026d	8b 55 d0	 mov	 edx, DWORD PTR _$S2$[ebp+12]
$LN5@UpdateArea:
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00270	85 c9		 test	 ecx, ecx
  00272	74 21		 je	 SHORT $LN304@UpdateArea
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00274	51		 push	 ecx
  00275	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File a:\vs\vc\include\vector

; 1631 : 			this->_Myend = pointer();

  0027a	8b 55 d0	 mov	 edx, DWORD PTR _$S2$[ebp+12]
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0027d	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00280	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _$S3$[ebp+12], 0

; 1630 : 			this->_Mylast = pointer();

  00287	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _$S3$[ebp+16], 0

; 1631 : 			this->_Myend = pointer();

  0028e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _$S3$[ebp+20], 0
$LN304@UpdateArea:

; 1623 : 		if (this->_Myfirst != pointer())

  00295	85 d2		 test	 edx, edx
  00297	74 09		 je	 SHORT $LN319@UpdateArea
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00299	52		 push	 edx
  0029a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0029f	83 c4 04	 add	 esp, 4
$LN319@UpdateArea:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 940  : }

  002a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002ac	59		 pop	 ecx
  002ad	5f		 pop	 edi
  002ae	5e		 pop	 esi
  002af	5b		 pop	 ebx
  002b0	8b e5		 mov	 esp, ebp
  002b2	5d		 pop	 ebp
  002b3	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z$1:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR _$S2$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1FPushTerrainToDeleteVector@CMapOutdoor@@QAE@XZ
__unwindfunclet$?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z$3:
  00008	8d 4d dc	 lea	 ecx, DWORD PTR _$S3$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1FPushAreaToDeleteVector@CMapOutdoor@@QAE@XZ
__ehhandler$?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z ENDP		; CMapOutdoor::UpdateAreaList
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?__UpdateGarvage@CMapOutdoor@@MAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?__UpdateGarvage@CMapOutdoor@@MAEXXZ PROC		; CMapOutdoor::__UpdateGarvage, COMDAT
; _this$ = ecx

; 843  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__UpdateGarvage@CMapOutdoor@@MAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx

; 844  : 	const DWORD dwTerrainEraseInterval = 1000 * 60;
; 845  : 	static DWORD dwEraseTime = ELTimer_GetMSec();

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?1??__UpdateGarvage@CMapOutdoor@@MAEXXZ@4IA
  0002b	a8 01		 test	 al, 1
  0002d	75 20		 jne	 SHORT $LN5@UpdateGarv
  0002f	83 c8 01	 or	 eax, 1
  00032	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?1??__UpdateGarvage@CMapOutdoor@@MAEXXZ@4IA, eax
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003e	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00043	a3 00 00 00 00	 mov	 DWORD PTR ?dwEraseTime@?1??__UpdateGarvage@CMapOutdoor@@MAEXXZ@4KA, eax
  00048	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN5@UpdateGarv:
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  0004f	8b 87 24 09 00
	00		 mov	 eax, DWORD PTR [edi+2340]
  00055	3b 87 28 09 00
	00		 cmp	 eax, DWORD PTR [edi+2344]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 847  : 	if (!m_TerrainDeleteVector.empty())

  0005b	74 4c		 je	 SHORT $LN4@UpdateGarv

; 848  : 	{
; 849  : 		if (ELTimer_GetMSec() - dwEraseTime <= dwTerrainEraseInterval)

  0005d	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00062	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?dwEraseTime@?1??__UpdateGarvage@CMapOutdoor@@MAEXXZ@4KA
  00068	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  0006d	0f 86 97 00 00
	00		 jbe	 $LN2@UpdateGarv
; File a:\vs\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

  00073	8b b7 24 09 00
	00		 mov	 esi, DWORD PTR [edi+2340]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 853  : 		CTerrain::Delete(pTerrain);

  00079	ff 36		 push	 DWORD PTR [esi]
  0007b	e8 00 00 00 00	 call	 ?Delete@CTerrain@@SAXPAV1@@Z ; CTerrain::Delete
; File a:\vs\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  00080	8b 87 28 09 00
	00		 mov	 eax, DWORD PTR [edi+2344]
; File a:\vs\vc\include\vector

; 1454 : 			_VIPTR(_Where));

  00086	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
; File a:\vs\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  00089	2b c1		 sub	 eax, ecx

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

  0008b	83 e0 fc	 and	 eax, -4			; fffffffcH
  0008e	50		 push	 eax
  0008f	51		 push	 ecx
  00090	56		 push	 esi
  00091	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 1456 : 		--this->_Mylast;

  00096	83 87 28 09 00
	00 fc		 add	 DWORD PTR [edi+2344], -4 ; fffffffcH
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 856  : 		dwEraseTime = ELTimer_GetMSec();

  0009d	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 857  : 		Trace("Delete Terrain \n");

  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GFILMBNJ@Delete?5Terrain?5?6?$AA@

; 858  : 		return;

  000a7	eb 54		 jmp	 SHORT $LN70@UpdateGarv
$LN4@UpdateGarv:
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  000a9	8b 87 58 09 00
	00		 mov	 eax, DWORD PTR [edi+2392]
  000af	3b 87 5c 09 00
	00		 cmp	 eax, DWORD PTR [edi+2396]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 861  : 	if (!m_AreaDeleteVector.empty())

  000b5	74 53		 je	 SHORT $LN2@UpdateGarv

; 862  : 	{
; 863  : 		if (ELTimer_GetMSec() - dwEraseTime <= dwTerrainEraseInterval)

  000b7	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  000bc	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?dwEraseTime@?1??__UpdateGarvage@CMapOutdoor@@MAEXXZ@4KA
  000c2	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  000c7	76 41		 jbe	 SHORT $LN2@UpdateGarv
; File a:\vs\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

  000c9	8b b7 58 09 00
	00		 mov	 esi, DWORD PTR [edi+2392]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 868  : 		CArea::Delete(pArea);

  000cf	ff 36		 push	 DWORD PTR [esi]
  000d1	e8 00 00 00 00	 call	 ?Delete@CArea@@SAXPAV1@@Z ; CArea::Delete
; File a:\vs\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  000d6	8b 87 5c 09 00
	00		 mov	 eax, DWORD PTR [edi+2396]
; File a:\vs\vc\include\vector

; 1454 : 			_VIPTR(_Where));

  000dc	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
; File a:\vs\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  000df	2b c1		 sub	 eax, ecx

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

  000e1	83 e0 fc	 and	 eax, -4			; fffffffcH
  000e4	50		 push	 eax
  000e5	51		 push	 ecx
  000e6	56		 push	 esi
  000e7	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 1456 : 		--this->_Mylast;

  000ec	83 87 5c 09 00
	00 fc		 add	 DWORD PTR [edi+2396], -4 ; fffffffcH
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 871  : 		dwEraseTime = ELTimer_GetMSec();

  000f3	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 872  : 		Trace("Delete Area \n");

  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MNAKBLAF@Delete?5Area?5?6?$AA@
$LN70@UpdateGarv:
  000fd	a3 00 00 00 00	 mov	 DWORD PTR ?dwEraseTime@?1??__UpdateGarvage@CMapOutdoor@@MAEXXZ@4KA, eax
  00102	e8 00 00 00 00	 call	 ?Trace@@YAXPBD@Z	; Trace
  00107	83 c4 14	 add	 esp, 20			; 00000014H
$LN2@UpdateGarv:

; 873  : 		return;
; 874  : 	}
; 875  : }

  0010a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00114	59		 pop	 ecx
  00115	5f		 pop	 edi
  00116	5e		 pop	 esi
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__UpdateGarvage@CMapOutdoor@@MAEXXZ$0:
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?1??__UpdateGarvage@CMapOutdoor@@MAEXXZ@4IA
  00005	83 e0 fe	 and	 eax, -2			; fffffffeH
  00008	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?1??__UpdateGarvage@CMapOutdoor@@MAEXXZ@4IA, eax
  0000d	c3		 ret	 0
__ehhandler$?__UpdateGarvage@CMapOutdoor@@MAEXXZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__UpdateGarvage@CMapOutdoor@@MAEXXZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__UpdateGarvage@CMapOutdoor@@MAEXXZ ENDP		; CMapOutdoor::__UpdateGarvage
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?__ClearGarvage@CMapOutdoor@@MAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?__ClearGarvage@CMapOutdoor@@MAEXXZ PROC		; CMapOutdoor::__ClearGarvage, COMDAT
; _this$ = ecx

; 834  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File a:\vs\vc\include\algorithm

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  00004	8b 81 28 09 00
	00		 mov	 eax, DWORD PTR [ecx+2344]
  0000a	33 d2		 xor	 edx, edx
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000e	8b b1 24 09 00
	00		 mov	 esi, DWORD PTR [ecx+2340]
  00014	8b d8		 mov	 ebx, eax
  00016	2b de		 sub	 ebx, esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 834  : {

  00018	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0001b	83 c3 03	 add	 ebx, 3
  0001e	c1 eb 02	 shr	 ebx, 2
  00021	57		 push	 edi
  00022	33 ff		 xor	 edi, edi
  00024	3b f0		 cmp	 esi, eax
  00026	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00029	85 db		 test	 ebx, ebx
  0002b	74 18		 je	 SHORT $LN29@ClearGarva
  0002d	8d 49 00	 npad	 3
$LL31@ClearGarva:

; 24   : 		_Func(*_First);

  00030	ff 36		 push	 DWORD PTR [esi]
  00032	e8 00 00 00 00	 call	 ?Delete@CTerrain@@SAXPAV1@@Z ; CTerrain::Delete
  00037	47		 inc	 edi
  00038	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0003b	83 c4 04	 add	 esp, 4
  0003e	3b fb		 cmp	 edi, ebx
  00040	75 ee		 jne	 SHORT $LL31@ClearGarva
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@ClearGarva:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00045	8b 81 24 09 00
	00		 mov	 eax, DWORD PTR [ecx+2340]
  0004b	33 d2		 xor	 edx, edx
  0004d	89 81 28 09 00
	00		 mov	 DWORD PTR [ecx+2344], eax
  00053	33 ff		 xor	 edi, edi
; File a:\vs\vc\include\algorithm

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  00055	8b 81 5c 09 00
	00		 mov	 eax, DWORD PTR [ecx+2396]
  0005b	8b d8		 mov	 ebx, eax
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0005d	8b b1 58 09 00
	00		 mov	 esi, DWORD PTR [ecx+2392]
  00063	2b de		 sub	 ebx, esi
  00065	83 c3 03	 add	 ebx, 3
  00068	c1 eb 02	 shr	 ebx, 2
  0006b	3b f0		 cmp	 esi, eax
  0006d	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00070	85 db		 test	 ebx, ebx
  00072	74 15		 je	 SHORT $LN66@ClearGarva
$LL68@ClearGarva:

; 24   : 		_Func(*_First);

  00074	ff 36		 push	 DWORD PTR [esi]
  00076	e8 00 00 00 00	 call	 ?Delete@CArea@@SAXPAV1@@Z ; CArea::Delete
  0007b	47		 inc	 edi
  0007c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0007f	83 c4 04	 add	 esp, 4
  00082	3b fb		 cmp	 edi, ebx
  00084	75 ee		 jne	 SHORT $LL68@ClearGarva
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN66@ClearGarva:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00089	8b 81 58 09 00
	00		 mov	 eax, DWORD PTR [ecx+2392]
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	89 81 5c 09 00
	00		 mov	 DWORD PTR [ecx+2396], eax
  00097	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 840  : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
?__ClearGarvage@CMapOutdoor@@MAEXXZ ENDP		; CMapOutdoor::__ClearGarvage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?UpdateSky@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
?UpdateSky@CMapOutdoor@@QAEXXZ PROC			; CMapOutdoor::UpdateSky, COMDAT
; _this$ = ecx

; 161  : 	m_SkyBox.Update();

  00000	8b 81 38 03 00
	00		 mov	 eax, DWORD PTR [ecx+824]
  00006	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  0000c	ff 60 0c	 jmp	 DWORD PTR [eax+12]
?UpdateSky@CMapOutdoor@@QAEXXZ ENDP			; CMapOutdoor::UpdateSky
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?UpdateAroundAmbience@CMapOutdoor@@UAEXMMM@Z
_TEXT	SEGMENT
_pArea$1 = -4						; size = 4
_fX$ = 8						; size = 4
_fY$ = 12						; size = 4
_fZ$ = 16						; size = 4
?UpdateAroundAmbience@CMapOutdoor@@UAEXMMM@Z PROC	; CMapOutdoor::UpdateAroundAmbience, COMDAT
; _this$ = ecx

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 204  : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)

  00008	33 f6		 xor	 esi, esi
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL4@UpdateArou:

; 205  : 	{
; 206  : 		CArea * pArea;
; 207  : 		if (GetAreaPointer(i, &pArea))

  00010	8d 45 fc	 lea	 eax, DWORD PTR _pArea$1[ebp]
  00013	8b cf		 mov	 ecx, edi
  00015	50		 push	 eax
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ?GetAreaPointer@CMapOutdoor@@QAEHEPAPAVCArea@@@Z ; CMapOutdoor::GetAreaPointer
  0001c	85 c0		 test	 eax, eax
  0001e	74 2b		 je	 SHORT $LN3@UpdateArou

; 208  : 			pArea->UpdateAroundAmbience(fX, fY, fZ);

  00020	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fZ$[ebp]
  00025	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _pArea$1[ebp]
  0002b	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00031	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fY$[ebp]
  00036	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0003c	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fX$[ebp]
  00041	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00046	e8 00 00 00 00	 call	 ?UpdateAroundAmbience@CArea@@QAEXMMM@Z ; CArea::UpdateAroundAmbience
$LN3@UpdateArou:

; 204  : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)

  0004b	46		 inc	 esi
  0004c	83 fe 09	 cmp	 esi, 9
  0004f	7c bf		 jl	 SHORT $LL4@UpdateArou
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 209  : 	}
; 210  : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 0c 00	 ret	 12			; 0000000cH
?UpdateAroundAmbience@CMapOutdoor@@UAEXMMM@Z ENDP	; CMapOutdoor::UpdateAroundAmbience
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp
;	COMDAT ?Update@CMapOutdoor@@UAE_NMMM@Z
_TEXT	SEGMENT
_v3Player$ = -44					; size = 12
_t1$1$ = -32						; size = 4
_sReferenceCoordMinX$1$ = -28				; size = 4
tv498 = -28						; size = 4
_wCellCoordX$1$ = -24					; size = 4
_sReferenceCoordMaxY$1$ = -20				; size = 4
_sCoordY$1$ = -20					; size = 4
tv491 = -20						; size = 4
tv492 = -16						; size = 4
tv490 = -16						; size = 4
_sReferenceCoordMaxX$1$ = -12				; size = 4
tv493 = -12						; size = 4
tv481 = -12						; size = 4
_sReferenceCoordMinY$1$ = -8				; size = 4
_ix$1$ = -8						; size = 4
_wCellCoordY$1$ = -4					; size = 4
tv496 = -4						; size = 4
_fX$ = 8						; size = 4
_fY$ = 12						; size = 4
_usY$1$ = 16						; size = 4
_sCoordX$1$ = 16					; size = 4
_fZ$ = 16						; size = 4
?Update@CMapOutdoor@@UAE_NMMM@Z PROC			; CMapOutdoor::Update, COMDAT
; _this$ = ecx

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00006	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fZ$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 50   : 	m_v3Player=v3Player;

  0000b	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _fY$[ebp]
  00010	56		 push	 esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00011	f3 0f 11 45 dc	 movss	 DWORD PTR _v3Player$[ebp+8], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 50   : 	m_v3Player=v3Player;

  00016	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fX$[ebp]
  0001b	8b 45 dc	 mov	 eax, DWORD PTR _v3Player$[ebp+8]
  0001e	57		 push	 edi
  0001f	8b f9		 mov	 edi, ecx
  00021	0f 14 c1	 unpcklps xmm0, xmm1
  00024	66 0f d6 45 d4	 movq	 QWORD PTR _v3Player$[ebp], xmm0
  00029	66 0f d6 87 a8
	0e 00 00	 movq	 QWORD PTR [edi+3752], xmm0
  00031	89 87 b0 0e 00
	00		 mov	 DWORD PTR [edi+3760], eax

; 51   : 
; 52   : 
; 53   : 	DWORD t1=ELTimer_GetMSec();

  00037	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 54   : 
; 55   : 	int ix, iy;
; 56   : 	PR_FLOAT_TO_INT(fX, ix);

  0003c	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fX$[ebp]
  00041	89 45 e0	 mov	 DWORD PTR _t1$1$[ebp], eax
  00044	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  0004c	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  00052	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0005e	89 4d f8	 mov	 DWORD PTR _ix$1$[ebp], ecx
  00061	66 0f 6e c1	 movd	 xmm0, ecx
  00065	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00068	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  0006f	76 04		 jbe	 SHORT $LN14@Update
  00071	49		 dec	 ecx
  00072	89 4d f8	 mov	 DWORD PTR _ix$1$[ebp], ecx
$LN14@Update:

; 57   : 	if ( fY < 0 )

  00075	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _fY$[ebp]
  0007a	0f 57 c0	 xorps	 xmm0, xmm0
  0007d	0f 2f c1	 comiss	 xmm0, xmm1
  00080	76 0c		 jbe	 SHORT $LN11@Update

; 58   : 		fY = -fY;

  00082	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  00089	f3 0f 11 4d 0c	 movss	 DWORD PTR _fY$[ebp], xmm1
$LN11@Update:

; 59   : 	PR_FLOAT_TO_INT(fY, iy);

  0008e	f3 0f 11 0d 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm1
  00096	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  0009c	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  000a2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  000a8	66 0f 6e c6	 movd	 xmm0, esi
  000ac	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000af	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  000b6	76 01		 jbe	 SHORT $LN16@Update
  000b8	4e		 dec	 esi
$LN16@Update:

; 60   : 	
; 61   : 	short sCoordX = MINMAX(0, ix / CTerrainImpl::TERRAIN_XSIZE, m_sTerrainCountX - 1);

  000b9	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000be	f7 e9		 imul	 ecx
  000c0	0f bf 47 70	 movsx	 eax, WORD PTR [edi+112]
  000c4	c1 fa 0d	 sar	 edx, 13			; 0000000dH
  000c7	48		 dec	 eax
  000c8	8b ca		 mov	 ecx, edx
  000ca	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000cd	03 ca		 add	 ecx, edx
  000cf	50		 push	 eax
  000d0	51		 push	 ecx
  000d1	6a 00		 push	 0
  000d3	89 4d e4	 mov	 DWORD PTR tv498[ebp], ecx
  000d6	e8 00 00 00 00	 call	 ?MINMAX@@YAHHHH@Z	; MINMAX
  000db	0f b7 c0	 movzx	 eax, ax
  000de	89 45 10	 mov	 DWORD PTR _sCoordX$1$[ebp], eax

; 62   : 	short sCoordY = MINMAX(0, iy / CTerrainImpl::TERRAIN_YSIZE, m_sTerrainCountY - 1);

  000e1	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000e6	f7 ee		 imul	 esi
  000e8	0f bf 47 72	 movsx	 eax, WORD PTR [edi+114]
  000ec	c1 fa 0d	 sar	 edx, 13			; 0000000dH
  000ef	48		 dec	 eax
  000f0	8b ca		 mov	 ecx, edx
  000f2	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000f5	03 ca		 add	 ecx, edx
  000f7	50		 push	 eax
  000f8	51		 push	 ecx
  000f9	6a 00		 push	 0
  000fb	89 4d fc	 mov	 DWORD PTR tv496[ebp], ecx
  000fe	e8 00 00 00 00	 call	 ?MINMAX@@YAHHHH@Z	; MINMAX
  00103	83 c4 18	 add	 esp, 24			; 00000018H
  00106	0f b7 c8	 movzx	 ecx, ax

; 63   : #ifdef __PERFORMANCE_CHECKER__
; 64   : 	DWORD t2=ELTimer_GetMSec();
; 65   : #endif
; 66   : 
; 67   : 	bool bNeedInit = (m_PrevCoordinate.m_sTerrainCoordX == -1 || m_PrevCoordinate.m_sTerrainCoordY == -1);

  00109	66 83 bf 80 00
	00 00 ff	 cmp	 WORD PTR [edi+128], -1
  00111	89 4d ec	 mov	 DWORD PTR _sCoordY$1$[ebp], ecx
  00114	74 37		 je	 SHORT $LN42@Update
  00116	66 83 bf 82 00
	00 00 ff	 cmp	 WORD PTR [edi+130], -1
  0011e	74 2d		 je	 SHORT $LN42@Update

; 68   : 
; 69   : 	if ( bNeedInit ||
; 70   : 		(m_CurCoordinate.m_sTerrainCoordX/LOAD_SIZE_WIDTH) != (sCoordX/LOAD_SIZE_WIDTH) || 
; 71   : 		(m_CurCoordinate.m_sTerrainCoordY/LOAD_SIZE_WIDTH) != (sCoordY/LOAD_SIZE_WIDTH) )

  00120	0f b7 57 74	 movzx	 edx, WORD PTR [edi+116]
  00124	8b 45 10	 mov	 eax, DWORD PTR _sCoordX$1$[ebp]
  00127	66 3b d0	 cmp	 dx, ax
  0012a	75 0a		 jne	 SHORT $LN8@Update
  0012c	66 39 4f 76	 cmp	 WORD PTR [edi+118], cx
  00130	0f 84 a8 01 00
	00		 je	 $LN10@Update
$LN8@Update:

; 77   : 		}
; 78   : 		else
; 79   : 		{
; 80   : 			m_PrevCoordinate.m_sTerrainCoordX = m_CurCoordinate.m_sTerrainCoordX;
; 81   : 			m_PrevCoordinate.m_sTerrainCoordY = m_CurCoordinate.m_sTerrainCoordY;

  00136	66 8b 47 76	 mov	 ax, WORD PTR [edi+118]
  0013a	66 89 87 82 00
	00 00		 mov	 WORD PTR [edi+130], ax
  00141	8b 45 10	 mov	 eax, DWORD PTR _sCoordX$1$[ebp]
  00144	66 89 97 80 00
	00 00		 mov	 WORD PTR [edi+128], dx
  0014b	eb 11		 jmp	 SHORT $LN7@Update
$LN42@Update:

; 72   : 	{
; 73   : 		if (bNeedInit)
; 74   : 		{
; 75   : 			m_PrevCoordinate.m_sTerrainCoordX = sCoordX;

  0014d	8b 45 10	 mov	 eax, DWORD PTR _sCoordX$1$[ebp]
  00150	66 89 87 80 00
	00 00		 mov	 WORD PTR [edi+128], ax

; 76   : 			m_PrevCoordinate.m_sTerrainCoordY = sCoordY;

  00157	66 89 8f 82 00
	00 00		 mov	 WORD PTR [edi+130], cx
$LN7@Update:

; 82   : 		}
; 83   : 		
; 84   : 		m_CurCoordinate.m_sTerrainCoordX = sCoordX;
; 85   : 		m_CurCoordinate.m_sTerrainCoordY = sCoordY;
; 86   : 		m_lCurCoordStartX = sCoordX * CTerrainImpl::TERRAIN_XSIZE;

  0015e	66 89 47 74	 mov	 WORD PTR [edi+116], ax
  00162	98		 cwde
  00163	89 45 f4	 mov	 DWORD PTR tv493[ebp], eax
  00166	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  0016c	66 89 4f 76	 mov	 WORD PTR [edi+118], cx
  00170	89 47 78	 mov	 DWORD PTR [edi+120], eax

; 87   : 		m_lCurCoordStartY = sCoordY * CTerrainImpl::TERRAIN_YSIZE;

  00173	0f bf c1	 movsx	 eax, cx

; 88   : 
; 89   : 		WORD wCellCoordX = (ix % CTerrainImpl::TERRAIN_XSIZE) / CTerrainImpl::CELLSCALE;

  00176	8b 4d f8	 mov	 ecx, DWORD PTR _ix$1$[ebp]
  00179	89 45 f0	 mov	 DWORD PTR tv492[ebp], eax
  0017c	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  00182	89 47 7c	 mov	 DWORD PTR [edi+124], eax
  00185	69 45 e4 00 64
	00 00		 imul	 eax, DWORD PTR tv498[ebp], 25600
  0018c	2b c8		 sub	 ecx, eax
  0018e	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00193	f7 e9		 imul	 ecx
  00195	c1 fa 06	 sar	 edx, 6
  00198	8b ca		 mov	 ecx, edx
  0019a	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0019d	03 ca		 add	 ecx, edx
  0019f	0f b7 c1	 movzx	 eax, cx

; 90   : 		WORD wCellCoordY = (iy % CTerrainImpl::TERRAIN_YSIZE) / CTerrainImpl::CELLSCALE;

  001a2	69 4d fc 00 64
	00 00		 imul	 ecx, DWORD PTR tv496[ebp], 25600
  001a9	89 45 e8	 mov	 DWORD PTR _wCellCoordX$1$[ebp], eax
  001ac	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  001b1	2b f1		 sub	 esi, ecx
  001b3	f7 ee		 imul	 esi
  001b5	c1 fa 06	 sar	 edx, 6
  001b8	8b c2		 mov	 eax, edx
  001ba	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001bd	03 c2		 add	 eax, edx
  001bf	0f b7 d0	 movzx	 edx, ax

; 91   : 
; 92   : 		short sReferenceCoordMinX, sReferenceCoordMaxX, sReferenceCoordMinY, sReferenceCoordMaxY;
; 93   : 		sReferenceCoordMinX = max(m_CurCoordinate.m_sTerrainCoordX - LOAD_SIZE_WIDTH, 0);

  001c2	8b 45 f4	 mov	 eax, DWORD PTR tv493[ebp]
  001c5	48		 dec	 eax
  001c6	89 55 fc	 mov	 DWORD PTR _wCellCoordY$1$[ebp], edx
  001c9	85 c0		 test	 eax, eax
  001cb	7e 09		 jle	 SHORT $LN20@Update
  001cd	8b 45 10	 mov	 eax, DWORD PTR _sCoordX$1$[ebp]
  001d0	48		 dec	 eax
  001d1	0f b7 f0	 movzx	 esi, ax
  001d4	eb 02		 jmp	 SHORT $LN44@Update
$LN20@Update:
  001d6	33 f6		 xor	 esi, esi
$LN44@Update:

; 94   : 		sReferenceCoordMaxX = min(m_CurCoordinate.m_sTerrainCoordX + LOAD_SIZE_WIDTH, m_sTerrainCountX - 1);

  001d8	0f b7 47 70	 movzx	 eax, WORD PTR [edi+112]
  001dc	0f bf c8	 movsx	 ecx, ax
  001df	8b 45 f4	 mov	 eax, DWORD PTR tv493[ebp]
  001e2	49		 dec	 ecx
  001e3	40		 inc	 eax
  001e4	89 75 e4	 mov	 DWORD PTR _sReferenceCoordMinX$1$[ebp], esi
  001e7	3b c1		 cmp	 eax, ecx
  001e9	7d 0c		 jge	 SHORT $LN22@Update
  001eb	8b 45 10	 mov	 eax, DWORD PTR _sCoordX$1$[ebp]
  001ee	40		 inc	 eax
  001ef	0f b7 c8	 movzx	 ecx, ax
  001f2	89 4d f4	 mov	 DWORD PTR _sReferenceCoordMaxX$1$[ebp], ecx
  001f5	eb 0b		 jmp	 SHORT $LN23@Update
$LN22@Update:
  001f7	0f b7 47 70	 movzx	 eax, WORD PTR [edi+112]
  001fb	48		 dec	 eax
  001fc	0f b7 c0	 movzx	 eax, ax
  001ff	89 45 f4	 mov	 DWORD PTR _sReferenceCoordMaxX$1$[ebp], eax
$LN23@Update:

; 95   : 		sReferenceCoordMinY = max(m_CurCoordinate.m_sTerrainCoordY - LOAD_SIZE_WIDTH, 0);

  00202	8b 45 f0	 mov	 eax, DWORD PTR tv492[ebp]
  00205	48		 dec	 eax
  00206	85 c0		 test	 eax, eax
  00208	7e 0c		 jle	 SHORT $LN24@Update
  0020a	8b 45 ec	 mov	 eax, DWORD PTR _sCoordY$1$[ebp]
  0020d	48		 dec	 eax
  0020e	0f b7 c0	 movzx	 eax, ax
  00211	89 45 f8	 mov	 DWORD PTR _sReferenceCoordMinY$1$[ebp], eax
  00214	eb 07		 jmp	 SHORT $LN25@Update
$LN24@Update:
  00216	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _sReferenceCoordMinY$1$[ebp], 0
$LN25@Update:

; 96   : 		sReferenceCoordMaxY = min(m_CurCoordinate.m_sTerrainCoordY + LOAD_SIZE_WIDTH, m_sTerrainCountY - 1);

  0021d	0f b7 47 72	 movzx	 eax, WORD PTR [edi+114]
  00221	0f bf c8	 movsx	 ecx, ax
  00224	8b 45 f0	 mov	 eax, DWORD PTR tv492[ebp]
  00227	49		 dec	 ecx
  00228	40		 inc	 eax
  00229	3b c1		 cmp	 eax, ecx
  0022b	7d 06		 jge	 SHORT $LN26@Update
  0022d	8b 45 ec	 mov	 eax, DWORD PTR _sCoordY$1$[ebp]
  00230	40		 inc	 eax
  00231	eb 05		 jmp	 SHORT $LN45@Update
$LN26@Update:
  00233	0f b7 47 72	 movzx	 eax, WORD PTR [edi+114]
  00237	48		 dec	 eax
$LN45@Update:
  00238	0f b7 c0	 movzx	 eax, ax
  0023b	89 45 ec	 mov	 DWORD PTR _sReferenceCoordMaxY$1$[ebp], eax

; 97   : 		
; 98   : 		for (WORD usY = sReferenceCoordMinY; usY <=sReferenceCoordMaxY; ++usY)

  0023e	8b 45 f8	 mov	 eax, DWORD PTR _sReferenceCoordMinY$1$[ebp]
  00241	0f b7 c8	 movzx	 ecx, ax
  00244	8b 45 ec	 mov	 eax, DWORD PTR _sReferenceCoordMaxY$1$[ebp]
  00247	98		 cwde
  00248	89 45 ec	 mov	 DWORD PTR tv491[ebp], eax
  0024b	8b 45 f8	 mov	 eax, DWORD PTR _sReferenceCoordMinY$1$[ebp]
  0024e	0f b7 c0	 movzx	 eax, ax
  00251	89 4d 10	 mov	 DWORD PTR _usY$1$[ebp], ecx
  00254	3b 45 ec	 cmp	 eax, DWORD PTR tv491[ebp]
  00257	7f 5e		 jg	 SHORT $LN4@Update
  00259	8b 45 f4	 mov	 eax, DWORD PTR _sReferenceCoordMaxX$1$[ebp]
  0025c	0f b7 d6	 movzx	 edx, si
  0025f	98		 cwde
  00260	89 55 f4	 mov	 DWORD PTR tv481[ebp], edx
  00263	8b 55 fc	 mov	 edx, DWORD PTR _wCellCoordY$1$[ebp]
  00266	89 45 f0	 mov	 DWORD PTR tv490[ebp], eax
  00269	8d a4 24 00 00
	00 00		 npad	 7
$LL6@Update:

; 99   : 		{
; 100  : 			for (WORD usX = sReferenceCoordMinX; usX <= sReferenceCoordMaxX; ++usX)

  00270	0f b7 f6	 movzx	 esi, si
  00273	39 45 f4	 cmp	 DWORD PTR tv481[ebp], eax
  00276	7f 2d		 jg	 SHORT $LN5@Update
$LL3@Update:

; 101  : 			{
; 102  : 				LoadTerrain(usX, usY, wCellCoordX, wCellCoordY);

  00278	8b 07		 mov	 eax, DWORD PTR [edi]
  0027a	52		 push	 edx
  0027b	ff 75 e8	 push	 DWORD PTR _wCellCoordX$1$[ebp]
  0027e	51		 push	 ecx
  0027f	56		 push	 esi
  00280	8b cf		 mov	 ecx, edi
  00282	ff 50 44	 call	 DWORD PTR [eax+68]

; 103  :   				LoadArea(usX, usY, wCellCoordX, wCellCoordY);

  00285	ff 75 fc	 push	 DWORD PTR _wCellCoordY$1$[ebp]
  00288	8b 07		 mov	 eax, DWORD PTR [edi]
  0028a	8b cf		 mov	 ecx, edi
  0028c	ff 75 e8	 push	 DWORD PTR _wCellCoordX$1$[ebp]
  0028f	ff 75 10	 push	 DWORD PTR _usY$1$[ebp]
  00292	56		 push	 esi
  00293	ff 50 48	 call	 DWORD PTR [eax+72]
  00296	8b 4d 10	 mov	 ecx, DWORD PTR _usY$1$[ebp]
  00299	46		 inc	 esi
  0029a	8b 55 fc	 mov	 edx, DWORD PTR _wCellCoordY$1$[ebp]
  0029d	0f b7 c6	 movzx	 eax, si
  002a0	3b 45 f0	 cmp	 eax, DWORD PTR tv490[ebp]
  002a3	7e d3		 jle	 SHORT $LL3@Update
$LN5@Update:

; 97   : 		
; 98   : 		for (WORD usY = sReferenceCoordMinY; usY <=sReferenceCoordMaxY; ++usY)

  002a5	8b 75 e4	 mov	 esi, DWORD PTR _sReferenceCoordMinX$1$[ebp]
  002a8	41		 inc	 ecx
  002a9	0f b7 c1	 movzx	 eax, cx
  002ac	3b 45 ec	 cmp	 eax, DWORD PTR tv491[ebp]
  002af	8b 45 f0	 mov	 eax, DWORD PTR tv490[ebp]
  002b2	89 4d 10	 mov	 DWORD PTR _usY$1$[ebp], ecx
  002b5	7e b9		 jle	 SHORT $LL6@Update
$LN4@Update:

; 104  : 			}
; 105  : 		}
; 106  : 
; 107  : 		AssignTerrainPtr();

  002b7	8b cf		 mov	 ecx, edi
  002b9	e8 00 00 00 00	 call	 ?AssignTerrainPtr@CMapOutdoor@@IAEXXZ ; CMapOutdoor::AssignTerrainPtr

; 108  : 		m_lOldReadX = -1;

  002be	c7 87 0c 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [edi+268], -1

; 109  : 
; 110  : 		Tracenf("Update::Load spent %d ms\n", ELTimer_GetMSec() - t1);

  002c8	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  002cd	2b 45 e0	 sub	 eax, DWORD PTR _t1$1$[ebp]
  002d0	50		 push	 eax
  002d1	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@IDOOHDBC@Update?3?3Load?5spent?5?$CFd?5ms?6?$AA@
  002d6	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  002db	83 c4 08	 add	 esp, 8
$LN10@Update:

; 115  : 	CSpeedTreeForestDirectX8::Instance().UpdateSystem(CTimer::Instance().GetCurrentSecond());

  002de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h

; 27   : 		return (*ms_singleton);

  002e4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorupdate.cpp

; 115  : 	CSpeedTreeForestDirectX8::Instance().UpdateSystem(CTimer::Instance().GetCurrentSecond());

  002ea	e8 00 00 00 00	 call	 ?GetCurrentSecond@CTimer@@QAEMXZ ; CTimer::GetCurrentSecond
  002ef	51		 push	 ecx
  002f0	8b ce		 mov	 ecx, esi
  002f2	d9 1c 24	 fstp	 DWORD PTR [esp]
  002f5	e8 00 00 00 00	 call	 ?UpdateSystem@CSpeedTreeForest@@QAEXM@Z ; CSpeedTreeForest::UpdateSystem

; 116  : #ifdef __PERFORMANCE_CHECKER__
; 117  : 	DWORD t4=ELTimer_GetMSec();
; 118  : #endif
; 119  : 	__UpdateGarvage();

  002fa	8b 07		 mov	 eax, DWORD PTR [edi]
  002fc	8b cf		 mov	 ecx, edi
  002fe	ff 50 40	 call	 DWORD PTR [eax+64]

; 120  : #ifdef __PERFORMANCE_CHECKER__
; 121  : 	DWORD t5=ELTimer_GetMSec();
; 122  : #endif
; 123  : 	UpdateTerrain(fX, fY);

  00301	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _fY$[ebp]
  00306	83 ec 08	 sub	 esp, 8
  00309	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fX$[ebp]
  0030e	8b cf		 mov	 ecx, edi
  00310	f3 0f 11 4c 24
	04		 movss	 DWORD PTR [esp+4], xmm1
  00316	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0031b	e8 00 00 00 00	 call	 ?UpdateTerrain@CMapOutdoor@@IAEXMM@Z ; CMapOutdoor::UpdateTerrain

; 124  : #ifdef __PERFORMANCE_CHECKER__
; 125  : 	DWORD t6=ELTimer_GetMSec();
; 126  : #endif
; 127  : 	__UpdateArea(v3Player);

  00320	8d 45 d4	 lea	 eax, DWORD PTR _v3Player$[ebp]
  00323	8b cf		 mov	 ecx, edi
  00325	50		 push	 eax
  00326	e8 00 00 00 00	 call	 ?__UpdateArea@CMapOutdoor@@IAEXAAUD3DXVECTOR3@@@Z ; CMapOutdoor::__UpdateArea

; 128  : #ifdef __PERFORMANCE_CHECKER__
; 129  : 	DWORD t7=ELTimer_GetMSec();
; 130  : #endif
; 131  : 	UpdateSky();

  0032b	8b cf		 mov	 ecx, edi
  0032d	e8 00 00 00 00	 call	 ?UpdateSky@CMapOutdoor@@QAEXXZ ; CMapOutdoor::UpdateSky

; 132  : #ifdef __PERFORMANCE_CHECKER__	
; 133  : 	DWORD t8=ELTimer_GetMSec();
; 134  : #endif
; 135  : 	__HeightCache_Update();

  00332	8b cf		 mov	 ecx, edi
  00334	e8 00 00 00 00	 call	 ?__HeightCache_Update@CMapOutdoor@@AAEXXZ ; CMapOutdoor::__HeightCache_Update
  00339	5f		 pop	 edi

; 136  : 
; 137  : #ifdef __PERFORMANCE_CHECKER__
; 138  : 	{
; 139  : 		static FILE* fp=fopen("perf_outdoor_update.txt", "w");
; 140  : 
; 141  : 		if (t8-t1>5)
; 142  : 		{
; 143  : 			fprintf(fp, "OD.Total %d (Time %f)\n", t3-t1, ELTimer_GetMSec()/1000.0f);
; 144  : 			fprintf(fp, "OD.INIT %d\n", t2-t1);
; 145  : 			fprintf(fp, "OD.LOAD %d\n", t3-t2);
; 146  : 			fprintf(fp, "OD.TREE %d\n", t4-t3);
; 147  : 			fprintf(fp, "OD.GVG %d\n", t5-t4);
; 148  : 			fprintf(fp, "OD.TRN %d\n", t6-t5);
; 149  : 			fprintf(fp, "OD.AREA %d\n", t7-t6);
; 150  : 			fprintf(fp, "OD.SKY %d\n", t8-t7);
; 151  : 			fflush(fp);
; 152  : 		}
; 153  : 	}
; 154  : #endif
; 155  : 	
; 156  : 	return true;

  0033a	b0 01		 mov	 al, 1
  0033c	5e		 pop	 esi

; 157  : }

  0033d	8b e5		 mov	 esp, ebp
  0033f	5d		 pop	 ebp
  00340	c2 0c 00	 ret	 12			; 0000000cH
?Update@CMapOutdoor@@UAE_NMMM@Z ENDP			; CMapOutdoor::Update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBEXPAPAVCTerrain@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBEXPAPAVCTerrain@@0@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBEXPAPAVCTerrain@@0@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBEXXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBEXXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXI@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 02	 sar	 eax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 02	 sar	 esi, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 02	 sar	 edx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXI@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi

; 23   : 	void *_Ptr = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
; File a:\vs\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 db		 test	 ebx, ebx
  0000f	74 1e		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00017	77 5d		 ja	 SHORT $LN61@Reallocate
  00019	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 04	 add	 esp, 4
  0002b	85 f6		 test	 esi, esi
  0002d	74 47		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File a:\vs\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 e0 fc	 and	 eax, -4			; fffffffcH
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00041	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00046	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00049	2b c1		 sub	 eax, ecx
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN56@Reallocate
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File a:\vs\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0005e	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00066	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00069	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0006c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 1609 : 		}

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN61@Reallocate:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00076	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0007b	cc		 int	 3
?_Reallocate@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBE_NPBQAVCTerrain@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBE_NPBQAVCTerrain@@@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBE_NPBQAVCTerrain@@@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBEII@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IBEII@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXPAPAVCTerrain@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXPAPAVCTerrain@@0@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXPAPAVCTerrain@@0@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Buy, COMDAT
; _this$ = ecx

; 1546 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00016	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN4@Buy

; 1552 : 			return (false);

  00021	32 c0		 xor	 al, al
  00023	5e		 pop	 esi

; 1562 : 		}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN4@Buy:

; 1553 : 		else if (max_size() < _Capacity)

  00028	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0002d	77 27		 ja	 SHORT $LN35@Buy
  0002f	57		 push	 edi
; File a:\vs\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00030	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  00037	57		 push	 edi
  00038	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003d	83 c4 04	 add	 esp, 4
  00040	85 c0		 test	 eax, eax
  00042	74 1c		 je	 SHORT $LN26@Buy
; File a:\vs\vc\include\vector

; 1558 : 			this->_Mylast = this->_Myfirst;

  00044	89 06		 mov	 DWORD PTR [esi], eax
  00046	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;

  00049	03 c7		 add	 eax, edi
  0004b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1560 : 			}
; 1561 : 		return (true);

  0004e	b0 01		 mov	 al, 1
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 1562 : 		}

  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
$LN35@Buy:

; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0005b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN37@Buy:
$LN26@Buy:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00060	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN38@Buy:
$LN34@Buy:
  00065	cc		 int	 3
?_Buy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Pop_back_n@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Pop_back_n@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXI@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Pop_back_n, COMDAT
; _this$ = ecx

; 1495 : 		{	// erase _Count elements at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1496 : 		pointer _Ptr = this->_Mylast - _Count;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	f7 d8		 neg	 eax
  00008	c1 e0 02	 shl	 eax, 2

; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;

  0000b	01 41 04	 add	 DWORD PTR [ecx+4], eax

; 1504 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Pop_back_n@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Pop_back_n
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::erase, COMDAT
; _this$ = ecx

; 1452 : 		{	// erase element at where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
; File a:\vs\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  0000d	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00010	2b d6		 sub	 edx, esi

; 2431 : 		_Count * sizeof (*_First));

  00012	83 e2 fc	 and	 edx, -4			; fffffffcH
  00015	52		 push	 edx
  00016	56		 push	 esi
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File a:\vs\vc\include\xutility

; 2431 : 		_Count * sizeof (*_First));

  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1456 : 		--this->_Mylast;

  00023	83 47 04 fc	 add	 DWORD PTR [edi+4], -4	; fffffffcH

; 47   : 		{	// construct with pointer _Parg

  00027	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  0002a	5f		 pop	 edi
  0002b	89 08		 mov	 DWORD PTR [eax], ecx
  0002d	5e		 pop	 esi

; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
?erase@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXABQAVCTerrain@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXABQAVCTerrain@@@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 31		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2b		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Reserve
$LN3@push_back:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 2a		 je	 SHORT $LN49@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00036	89 01		 mov	 DWORD PTR [ecx], eax
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00038	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00042	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00045	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Reserve
$LN1@push_back:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	85 c9		 test	 ecx, ecx
  00055	74 04		 je	 SHORT $LN49@push_back
  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	89 01		 mov	 DWORD PTR [ecx], eax
$LN49@push_back:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  0005b	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?push_back@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXABQAVCTerrain@@@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??A?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEAAPAVCTerrain@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEAAPAVCTerrain@@I@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::operator[], COMDAT
; _this$ = ecx

; 1197 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00008	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1210 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEAAPAVCTerrain@@I@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?empty@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE_NXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
;	COMDAT ?resize@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXI@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::resize, COMDAT
; _this$ = ecx

; 1100 : 		{	// determine new length, padding as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx
  00006	56		 push	 esi

; 1101 : 		if (_Newsize < size())

  00007	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0000a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0000d	8b d0		 mov	 edx, eax
  0000f	2b 13		 sub	 edx, DWORD PTR [ebx]
  00011	c1 fa 02	 sar	 edx, 2

; 1101 : 		if (_Newsize < size())

  00014	3b d6		 cmp	 edx, esi
  00016	76 0e		 jbe	 SHORT $LN42@resize

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;

  00018	2b f2		 sub	 esi, edx
  0001a	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
  0001d	5e		 pop	 esi

; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();

  0001e	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00021	5b		 pop	 ebx

; 1115 : 			}
; 1116 : 		}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN42@resize:

; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)

  00026	73 32		 jae	 SHORT $LN2@resize

; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());

  00028	8b c6		 mov	 eax, esi
  0002a	57		 push	 edi
  0002b	2b c2		 sub	 eax, edx
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAEXI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Reserve

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00033	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]

; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);

  00036	8b ce		 mov	 ecx, esi

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00038	8b c7		 mov	 eax, edi
  0003a	2b 03		 sub	 eax, DWORD PTR [ebx]
  0003c	c1 f8 02	 sar	 eax, 2

; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);

  0003f	2b c8		 sub	 ecx, eax
; File a:\vs\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00041	74 04		 je	 SHORT $LN33@resize
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00043	33 c0		 xor	 eax, eax
  00045	f3 ab		 rep stosd
$LN33@resize:
  00047	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0004a	8b c1		 mov	 eax, ecx
  0004c	2b 03		 sub	 eax, DWORD PTR [ebx]
  0004e	c1 f8 02	 sar	 eax, 2

; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();

  00051	2b f0		 sub	 esi, eax
  00053	5f		 pop	 edi
  00054	8d 04 b1	 lea	 eax, DWORD PTR [ecx+esi*4]
  00057	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN2@resize:
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx

; 1115 : 			}
; 1116 : 		}

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?resize@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Make_iter, COMDAT
; _this$ = ecx

; 1044 : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::end, COMDAT
; _this$ = ecx

; 1039 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::begin, COMDAT
; _this$ = ecx

; 1029 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@2@XZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::~vector<CTerrain *,std::allocator<CTerrain *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::~vector<CTerrain *,std::allocator<CTerrain *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::vector<CTerrain *,std::allocator<CTerrain *> >, COMDAT
; _this$ = ecx

; 721  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi

; 721  : 		{	// construct by copying _Right

  00008	8b f9		 mov	 edi, ecx

; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);
; 206  : 		}
; 207  : 
; 208  : 	bool operator!=(const _Myiter& _Right) const
; 209  : 		{	// test for iterator inequality
; 210  : 		return (!(*this == _Right));
; 211  : 		}
; 212  : 
; 213  : 	bool operator<(const _Myiter& _Right) const
; 214  : 		{	// test if this < _Right
; 215  : 		_Compat(_Right);
; 216  : 		return (this->_Ptr < _Right._Ptr);
; 217  : 		}
; 218  : 
; 219  : 	bool operator>(const _Myiter& _Right) const
; 220  : 		{	// test if this > _Right
; 221  : 		return (_Right < *this);
; 222  : 		}
; 223  : 
; 224  : 	bool operator<=(const _Myiter& _Right) const
; 225  : 		{	// test if this <= _Right
; 226  : 		return (!(_Right < *this));
; 227  : 		}
; 228  : 
; 229  : 	bool operator>=(const _Myiter& _Right) const
; 230  : 		{	// test if this >= _Right
; 231  : 		return (!(*this < _Right));
; 232  : 		}
; 233  : 
; 234  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 235  : 	void _Compat(const _Myiter& _Right) const
; 236  : 		{	// test for compatible iterator pair
; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())
; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");
; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 242  : 			}
; 243  : 		}
; 244  : 
; 245  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 246  : 	void _Compat(const _Myiter& _Right) const
; 247  : 		{	// test for compatible iterator pair
; 248  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 249  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 250  : 		}
; 251  : 
; 252  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 253  : 	void _Compat(const _Myiter&) const
; 254  : 		{	// test for compatible iterator pair
; 255  : 		}
; 256  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 257  : 
; 258  : 	_Tptr _Ptr;	// pointer to element in vector
; 259  : 	};
; 260  : 
; 261  : template<class _Myvec> inline
; 262  : 	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
; 263  : 		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
; 264  : 	{	// convert to unchecked
; 265  : 	return (_Iter._Unchecked());
; 266  : 	}
; 267  : 
; 268  : template<class _Myvec> inline
; 269  : 	_Vector_const_iterator<_Myvec>&
; 270  : 		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
; 271  : 			typename _Vector_const_iterator<_Myvec>
; 272  : 				::_Unchecked_type _Right)
; 273  : 	{	// convert to checked
; 274  : 	return (_Iter._Rechecked(_Right));
; 275  : 	}
; 276  : 
; 277  : template<class _Myvec> inline
; 278  : 	_Vector_const_iterator<_Myvec> operator+(
; 279  : 		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
; 280  : 		_Vector_const_iterator<_Myvec> _Next)
; 281  : 	{	// add offset to iterator
; 282  : 	return (_Next += _Off);
; 283  : 	}
; 284  : 
; 285  : 		// TEMPLATE CLASS _Vector_iterator
; 286  : template<class _Myvec>
; 287  : 	class _Vector_iterator
; 288  : 		: public _Vector_const_iterator<_Myvec>
; 289  : 	{	// iterator for mutable vector
; 290  : public:
; 291  : 	typedef _Vector_iterator<_Myvec> _Myiter;
; 292  : 	typedef _Vector_const_iterator<_Myvec> _Mybase;
; 293  : 	typedef random_access_iterator_tag iterator_category;
; 294  : 
; 295  : 	typedef typename _Myvec::value_type value_type;
; 296  : 	typedef typename _Myvec::difference_type difference_type;
; 297  : 	typedef typename _Myvec::pointer pointer;
; 298  : 	typedef typename _Myvec::reference reference;
; 299  : 
; 300  : 	_Vector_iterator()
; 301  : 		{	// construct with null vector pointer
; 302  : 		}
; 303  : 
; 304  : 	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
; 305  : 		: _Mybase(_Parg, _Pvector)
; 306  : 		{	// construct with pointer _Parg
; 307  : 		}
; 308  : 
; 309  : 	typedef pointer _Unchecked_type;
; 310  : 
; 311  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 312  : 		{	// reset from unchecked iterator
; 313  : 		this->_Ptr = _Right;
; 314  : 		return (*this);
; 315  : 		}
; 316  : 
; 317  : 	_Unchecked_type _Unchecked() const
; 318  : 		{	// make an unchecked iterator
; 319  : 		return (_Unchecked_type(this->_Ptr));
; 320  : 		}
; 321  : 
; 322  : 	reference operator*() const
; 323  : 		{	// return designated object
; 324  : 		return ((reference)**(_Mybase *)this);
; 325  : 		}
; 326  : 
; 327  : 	pointer operator->() const
; 328  : 		{	// return pointer to class object
; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 330  : 		}
; 331  : 
; 332  : 	_Myiter& operator++()
; 333  : 		{	// preincrement
; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);
; 336  : 		}
; 337  : 
; 338  : 	_Myiter operator++(int)
; 339  : 		{	// postincrement
; 340  : 		_Myiter _Tmp = *this;
; 341  : 		++*this;
; 342  : 		return (_Tmp);
; 343  : 		}
; 344  : 
; 345  : 	_Myiter& operator--()
; 346  : 		{	// predecrement
; 347  : 		--*(_Mybase *)this;
; 348  : 		return (*this);
; 349  : 		}
; 350  : 
; 351  : 	_Myiter operator--(int)
; 352  : 		{	// postdecrement
; 353  : 		_Myiter _Tmp = *this;
; 354  : 		--*this;
; 355  : 		return (_Tmp);
; 356  : 		}
; 357  : 
; 358  : 	_Myiter& operator+=(difference_type _Off)
; 359  : 		{	// increment by integer
; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);
; 362  : 		}
; 363  : 
; 364  : 	_Myiter operator+(difference_type _Off) const
; 365  : 		{	// return this + integer
; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);
; 368  : 		}
; 369  : 
; 370  : 	_Myiter& operator-=(difference_type _Off)
; 371  : 		{	// decrement by integer
; 372  : 		return (*this += -_Off);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator-(difference_type _Off) const
; 376  : 		{	// return this - integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);
; 379  : 		}
; 380  : 
; 381  : 	difference_type operator-(const _Mybase& _Right) const
; 382  : 		{	// return difference of iterators
; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}
; 385  : 
; 386  : 	reference operator[](difference_type _Off) const
; 387  : 		{	// subscript
; 388  : 		return (*(*this + _Off));
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : template<class _Myvec> inline
; 393  : 	typename _Vector_iterator<_Myvec>::_Unchecked_type
; 394  : 		_Unchecked(_Vector_iterator<_Myvec> _Iter)
; 395  : 	{	// convert to unchecked
; 396  : 	return (_Iter._Unchecked());
; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 443  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 444  : 
; 445  : 
; 446  : 	typedef typename _Alty::pointer _Tptr;
; 447  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 448  : 
; 449  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 450  : 		_Simple_types<typename _Alty::value_type>,
; 451  : 		_Vec_iter_types<typename _Alty::value_type,
; 452  : 			typename _Alty::size_type,
; 453  : 			typename _Alty::difference_type,
; 454  : 			typename _Alty::pointer,
; 455  : 			typename _Alty::const_pointer,
; 456  : 			typename _Alty::reference,
; 457  : 			typename _Alty::const_reference> >::type
; 458  : 		_Val_types;
; 459  : 	};
; 460  : 
; 461  : 		// TEMPLATE CLASS _Vector_val
; 462  : template<class _Val_types>
; 463  : 	class _Vector_val
; 464  : 		: public _Container_base
; 465  : 	{	// base class for vector to hold data
; 466  : public:
; 467  : 	typedef _Vector_val<_Val_types> _Myt;
; 468  : 
; 469  : 	typedef typename _Val_types::value_type value_type;
; 470  : 	typedef typename _Val_types::size_type size_type;
; 471  : 	typedef typename _Val_types::difference_type difference_type;
; 472  : 	typedef typename _Val_types::pointer pointer;
; 473  : 	typedef typename _Val_types::const_pointer const_pointer;
; 474  : 	typedef typename _Val_types::reference reference;
; 475  : 	typedef typename _Val_types::const_reference const_reference;
; 476  : 
; 477  : 	typedef _Vector_iterator<_Myt> iterator;
; 478  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 479  : 
; 480  : 	_Vector_val()
; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  0000a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 483  : 		_Mylast = pointer();

  00010	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 484  : 		_Myend = pointer();

  00017	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0001e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00021	2b 06		 sub	 eax, DWORD PTR [esi]
  00023	c1 f8 02	 sar	 eax, 2

; 722  : 		if (_Buy(_Right.size()))

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?_Buy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@IAE_NI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Buy
  0002c	84 c0		 test	 al, al
  0002e	74 22		 je	 SHORT $LN55@vector

; 61   : 		return (_Unchecked_type(this->_Ptr));

  00030	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File a:\vs\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00032	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00035	2b c1		 sub	 eax, ecx
  00037	c1 f8 02	 sar	 eax, 2

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0003a	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00041	56		 push	 esi
  00042	51		 push	 ecx
  00043	ff 37		 push	 DWORD PTR [edi]
  00045	e8 00 00 00 00	 call	 _memmove
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	03 c6		 add	 eax, esi
; File a:\vs\vc\include\vector

; 725  : 				this->_Myfirst);

  0004f	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN55@vector:

; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}

  00052	8b c7		 mov	 eax, edi
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
??0?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::vector<CTerrain *,std::allocator<CTerrain *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::vector<CTerrain *,std::allocator<CTerrain *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::vector<CTerrain *,std::allocator<CTerrain *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CTerrain *,std::allocator<CTerrain *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CTerrain *,std::allocator<CTerrain *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTerrain@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTerrain@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CTerrain *,std::allocator<CTerrain *> > >::_Vector_alloc<0,std::_Vec_base_types<CTerrain *,std::allocator<CTerrain *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTerrain@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CTerrain *,std::allocator<CTerrain *> > >::_Vector_alloc<0,std::_Vec_base_types<CTerrain *,std::allocator<CTerrain *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CTerrain *> >::_Vector_val<std::_Simple_types<CTerrain *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CTerrain *> >::_Vector_val<std::_Simple_types<CTerrain *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CTerrain *> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CTerrain *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXPAPAVCTerrain@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXPAPAVCTerrain@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CTerrain *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXPAPAVCTerrain@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CTerrain *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CTerrain *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CTerrain *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@ABV?$allocator@PAVCTerrain@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@ABV?$allocator@PAVCTerrain@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<CTerrain *> >::_Wrap_alloc<std::allocator<CTerrain *> >, COMDAT
; _this$ = ecx

; 807  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@ABV?$allocator@PAVCTerrain@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<CTerrain *> >::_Wrap_alloc<std::allocator<CTerrain *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CTerrain *> >::_Wrap_alloc<std::allocator<CTerrain *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CTerrain *> >::_Wrap_alloc<std::allocator<CTerrain *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<CTerrain *> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 778  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 780  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVCTerrain@@@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<CTerrain *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SA?AV?$allocator@PAVCTerrain@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SA?AV?$allocator@PAVCTerrain@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<CTerrain *> >::select_on_container_copy_construction, COMDAT

; 740  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 741  : 		return (_Al.select_on_container_copy_construction());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 742  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SA?AV?$allocator@PAVCTerrain@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<CTerrain *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SAIABV?$allocator@PAVCTerrain@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SAIABV?$allocator@PAVCTerrain@@@2@@Z PROC ; std::allocator_traits<std::allocator<CTerrain *> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVCTerrain@@@std@@@std@@SAIABV?$allocator@PAVCTerrain@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CTerrain *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVCTerrain@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCTerrain@@@std@@QBEIXZ PROC	; std::allocator<CTerrain *>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVCTerrain@@@std@@QBEIXZ ENDP	; std::allocator<CTerrain *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVCTerrain@@@std@@QAEXPAPAVCTerrain@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCTerrain@@@std@@QAEXPAPAVCTerrain@@ABQAV3@@Z PROC ; std::allocator<CTerrain *>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 594  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAVCTerrain@@@std@@QAEXPAPAVCTerrain@@ABQAV3@@Z ENDP ; std::allocator<CTerrain *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVCTerrain@@@std@@QAEPAPAVCTerrain@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCTerrain@@@std@@QAEPAPAVCTerrain@@I@Z PROC ; std::allocator<CTerrain *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAVCTerrain@@@std@@QAEPAPAVCTerrain@@I@Z ENDP ; std::allocator<CTerrain *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCTerrain@@@std@@QAEXPAPAVCTerrain@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCTerrain@@@std@@QAEXPAPAVCTerrain@@I@Z PROC ; std::allocator<CTerrain *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCTerrain@@@std@@QAEXPAPAVCTerrain@@I@Z ENDP ; std::allocator<CTerrain *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCTerrain@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCTerrain@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CTerrain *>::allocator<CTerrain *>, COMDAT
; _this$ = ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@PAVCTerrain@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CTerrain *>::allocator<CTerrain *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCTerrain@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCTerrain@@@std@@QAE@XZ PROC		; std::allocator<CTerrain *>::allocator<CTerrain *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCTerrain@@@std@@QAE@XZ ENDP		; std::allocator<CTerrain *>::allocator<CTerrain *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@PAVCTerrain@@@std@@QBE?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@PAVCTerrain@@@std@@QBE?AV12@XZ PROC ; std::allocator<CTerrain *>::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 532  : 		{	// return this allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 533  : 		return (*this);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 534  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?select_on_container_copy_construction@?$allocator@PAVCTerrain@@@std@@QBE?AV12@XZ ENDP ; std::allocator<CTerrain *>::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\areaterrain.h
;	COMDAT ?GetCoordinate@CTerrain@@QAEXPAG0@Z
_TEXT	SEGMENT
_usCoordX$ = 8						; size = 4
_usCoordY$ = 12						; size = 4
?GetCoordinate@CTerrain@@QAEXPAG0@Z PROC		; CTerrain::GetCoordinate, COMDAT
; _this$ = ecx

; 91   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   : 			*usCoordX = m_wX;

  00003	8b 45 08	 mov	 eax, DWORD PTR _usCoordX$[ebp]
  00006	66 8b 91 6c a5
	06 00		 mov	 dx, WORD PTR [ecx+435564]
  0000d	66 89 10	 mov	 WORD PTR [eax], dx

; 93   : 			*usCoordY = m_wY;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _usCoordY$[ebp]
  00013	66 8b 89 6e a5
	06 00		 mov	 cx, WORD PTR [ecx+435566]
  0001a	66 89 08	 mov	 WORD PTR [eax], cx

; 94   : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?GetCoordinate@CTerrain@@QAEXPAG0@Z ENDP		; CTerrain::GetCoordinate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetMaxZ@CTerrainPatchProxy@@QAEMXZ
_TEXT	SEGMENT
?GetMaxZ@CTerrainPatchProxy@@QAEMXZ PROC		; CTerrainPatchProxy::GetMaxZ, COMDAT
; _this$ = ecx

; 242  : 	return m_pTerrainPatch->GetMaxZ();

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	d9 40 14	 fld	 DWORD PTR [eax+20]

; 243  : }

  00006	c3		 ret	 0
?GetMaxZ@CTerrainPatchProxy@@QAEMXZ ENDP		; CTerrainPatchProxy::GetMaxZ
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetMinZ@CTerrainPatchProxy@@QAEMXZ
_TEXT	SEGMENT
?GetMinZ@CTerrainPatchProxy@@QAEMXZ PROC		; CTerrainPatchProxy::GetMinZ, COMDAT
; _this$ = ecx

; 237  : 	return m_pTerrainPatch->GetMinZ();

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	d9 40 10	 fld	 DWORD PTR [eax+16]

; 238  : }

  00006	c3		 ret	 0
?GetMinZ@CTerrainPatchProxy@@QAEMXZ ENDP		; CTerrainPatchProxy::GetMinZ
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetMaxY@CTerrainPatchProxy@@QAEMXZ
_TEXT	SEGMENT
?GetMaxY@CTerrainPatchProxy@@QAEMXZ PROC		; CTerrainPatchProxy::GetMaxY, COMDAT
; _this$ = ecx

; 232  : 	return m_pTerrainPatch->GetMaxY();

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	d9 40 0c	 fld	 DWORD PTR [eax+12]

; 233  : }

  00006	c3		 ret	 0
?GetMaxY@CTerrainPatchProxy@@QAEMXZ ENDP		; CTerrainPatchProxy::GetMaxY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetMinY@CTerrainPatchProxy@@QAEMXZ
_TEXT	SEGMENT
?GetMinY@CTerrainPatchProxy@@QAEMXZ PROC		; CTerrainPatchProxy::GetMinY, COMDAT
; _this$ = ecx

; 227  : 	return m_pTerrainPatch->GetMinY();

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	d9 40 08	 fld	 DWORD PTR [eax+8]

; 228  : }

  00006	c3		 ret	 0
?GetMinY@CTerrainPatchProxy@@QAEMXZ ENDP		; CTerrainPatchProxy::GetMinY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetMaxX@CTerrainPatchProxy@@QAEMXZ
_TEXT	SEGMENT
?GetMaxX@CTerrainPatchProxy@@QAEMXZ PROC		; CTerrainPatchProxy::GetMaxX, COMDAT
; _this$ = ecx

; 222  : 	return m_pTerrainPatch->GetMaxX();

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	d9 40 04	 fld	 DWORD PTR [eax+4]

; 223  : }

  00006	c3		 ret	 0
?GetMaxX@CTerrainPatchProxy@@QAEMXZ ENDP		; CTerrainPatchProxy::GetMaxX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetMinX@CTerrainPatchProxy@@QAEMXZ
_TEXT	SEGMENT
?GetMinX@CTerrainPatchProxy@@QAEMXZ PROC		; CTerrainPatchProxy::GetMinX, COMDAT
; _this$ = ecx

; 64   : 	float GetMinX()											{ return m_fMinX; }

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 217  : 	return m_pTerrainPatch->GetMinX();

  00003	d9 00		 fld	 DWORD PTR [eax]

; 218  : }

  00005	c3		 ret	 0
?GetMinX@CTerrainPatchProxy@@QAEMXZ ENDP		; CTerrainPatchProxy::GetMinX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?SetTerrainPatch@CTerrainPatchProxy@@QAEXPAVCTerrainPatch@@@Z
_TEXT	SEGMENT
_pTerrainPatch$ = 8					; size = 4
?SetTerrainPatch@CTerrainPatchProxy@@QAEXPAVCTerrainPatch@@@Z PROC ; CTerrainPatchProxy::SetTerrainPatch, COMDAT
; _this$ = ecx

; 179  : 	void SetTerrainPatch(CTerrainPatch * pTerrainPatch)								{ m_pTerrainPatch = pTerrainPatch;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _pTerrainPatch$[ebp]
  00006	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetTerrainPatch@CTerrainPatchProxy@@QAEXPAVCTerrainPatch@@@Z ENDP ; CTerrainPatchProxy::SetTerrainPatch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?SetTerrainNum@CTerrainPatchProxy@@QAEXE@Z
_TEXT	SEGMENT
_byTerrainNum$ = 8					; size = 1
?SetTerrainNum@CTerrainPatchProxy@@QAEXE@Z PROC		; CTerrainPatchProxy::SetTerrainNum, COMDAT
; _this$ = ecx

; 177  : 	void SetTerrainNum(BYTE byTerrainNum)											{ m_byTerrainNum = byTerrainNum; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8a 45 08	 mov	 al, BYTE PTR _byTerrainNum$[ebp]
  00006	88 41 08	 mov	 BYTE PTR [ecx+8], al
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetTerrainNum@CTerrainPatchProxy@@QAEXE@Z ENDP		; CTerrainPatchProxy::SetTerrainNum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetTerrainNum@CTerrainPatchProxy@@QAEEXZ
_TEXT	SEGMENT
?GetTerrainNum@CTerrainPatchProxy@@QAEEXZ PROC		; CTerrainPatchProxy::GetTerrainNum, COMDAT
; _this$ = ecx

; 176  : 	BYTE GetTerrainNum()															{ return m_byTerrainNum; }

  00000	8a 41 08	 mov	 al, BYTE PTR [ecx+8]
  00003	c3		 ret	 0
?GetTerrainNum@CTerrainPatchProxy@@QAEEXZ ENDP		; CTerrainPatchProxy::GetTerrainNum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?SetPatchNum@CTerrainPatchProxy@@QAEXF@Z
_TEXT	SEGMENT
_sPatchNum$ = 8						; size = 2
?SetPatchNum@CTerrainPatchProxy@@QAEXF@Z PROC		; CTerrainPatchProxy::SetPatchNum, COMDAT
; _this$ = ecx

; 174  : 	void SetPatchNum(short sPatchNum)												{ m_sPatchNum = sPatchNum; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	66 8b 45 08	 mov	 ax, WORD PTR _sPatchNum$[ebp]
  00007	66 89 41 06	 mov	 WORD PTR [ecx+6], ax
  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?SetPatchNum@CTerrainPatchProxy@@QAEXF@Z ENDP		; CTerrainPatchProxy::SetPatchNum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?SetUsed@CTerrainPatchProxy@@QAEX_N@Z
_TEXT	SEGMENT
_bUsed$ = 8						; size = 1
?SetUsed@CTerrainPatchProxy@@QAEX_N@Z PROC		; CTerrainPatchProxy::SetUsed, COMDAT
; _this$ = ecx

; 171  : 	void SetUsed(bool bUsed)														{ m_bUsed = bUsed; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8a 45 08	 mov	 al, BYTE PTR _bUsed$[ebp]
  00006	88 41 04	 mov	 BYTE PTR [ecx+4], al
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetUsed@CTerrainPatchProxy@@QAEX_N@Z ENDP		; CTerrainPatchProxy::SetUsed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?isUsed@CTerrainPatchProxy@@QAE_NXZ
_TEXT	SEGMENT
?isUsed@CTerrainPatchProxy@@QAE_NXZ PROC		; CTerrainPatchProxy::isUsed, COMDAT
; _this$ = ecx

; 170  : 	bool isUsed()																	{ return m_bUsed; }

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	c3		 ret	 0
?isUsed@CTerrainPatchProxy@@QAE_NXZ ENDP		; CTerrainPatchProxy::isUsed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetMaxZ@CTerrainPatch@@QAEMXZ
_TEXT	SEGMENT
?GetMaxZ@CTerrainPatch@@QAEMXZ PROC			; CTerrainPatch::GetMaxZ, COMDAT
; _this$ = ecx

; 79   : 	float GetMaxZ()											{ return m_fMaxZ; }

  00000	d9 41 14	 fld	 DWORD PTR [ecx+20]
  00003	c3		 ret	 0
?GetMaxZ@CTerrainPatch@@QAEMXZ ENDP			; CTerrainPatch::GetMaxZ
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetMinZ@CTerrainPatch@@QAEMXZ
_TEXT	SEGMENT
?GetMinZ@CTerrainPatch@@QAEMXZ PROC			; CTerrainPatch::GetMinZ, COMDAT
; _this$ = ecx

; 76   : 	float GetMinZ()											{ return m_fMinZ; }

  00000	d9 41 10	 fld	 DWORD PTR [ecx+16]
  00003	c3		 ret	 0
?GetMinZ@CTerrainPatch@@QAEMXZ ENDP			; CTerrainPatch::GetMinZ
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetMaxY@CTerrainPatch@@QAEMXZ
_TEXT	SEGMENT
?GetMaxY@CTerrainPatch@@QAEMXZ PROC			; CTerrainPatch::GetMaxY, COMDAT
; _this$ = ecx

; 73   : 	float GetMaxY()											{ return m_fMaxY; }

  00000	d9 41 0c	 fld	 DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?GetMaxY@CTerrainPatch@@QAEMXZ ENDP			; CTerrainPatch::GetMaxY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetMinY@CTerrainPatch@@QAEMXZ
_TEXT	SEGMENT
?GetMinY@CTerrainPatch@@QAEMXZ PROC			; CTerrainPatch::GetMinY, COMDAT
; _this$ = ecx

; 70   : 	float GetMinY()											{ return m_fMinY; }

  00000	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?GetMinY@CTerrainPatch@@QAEMXZ ENDP			; CTerrainPatch::GetMinY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetMaxX@CTerrainPatch@@QAEMXZ
_TEXT	SEGMENT
?GetMaxX@CTerrainPatch@@QAEMXZ PROC			; CTerrainPatch::GetMaxX, COMDAT
; _this$ = ecx

; 67   : 	float GetMaxX()											{ return m_fMaxX; }

  00000	d9 41 04	 fld	 DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetMaxX@CTerrainPatch@@QAEMXZ ENDP			; CTerrainPatch::GetMaxX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetMinX@CTerrainPatch@@QAEMXZ
_TEXT	SEGMENT
?GetMinX@CTerrainPatch@@QAEMXZ PROC			; CTerrainPatch::GetMinX, COMDAT
; _this$ = ecx

; 64   : 	float GetMinX()											{ return m_fMinX; }

  00000	d9 01		 fld	 DWORD PTR [ecx]
  00002	c3		 ret	 0
?GetMinX@CTerrainPatch@@QAEMXZ ENDP			; CTerrainPatch::GetMinX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBEXPAPAVCArea@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBEXPAPAVCArea@@0@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBEXPAPAVCArea@@0@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBEXXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBEXXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXI@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 02	 sar	 eax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 02	 sar	 esi, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 02	 sar	 edx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXI@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXI@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXI@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi

; 23   : 	void *_Ptr = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
; File a:\vs\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 db		 test	 ebx, ebx
  0000f	74 1e		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00017	77 5d		 ja	 SHORT $LN61@Reallocate
  00019	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 04	 add	 esp, 4
  0002b	85 f6		 test	 esi, esi
  0002d	74 47		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File a:\vs\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 e0 fc	 and	 eax, -4			; fffffffcH
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00041	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00046	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00049	2b c1		 sub	 eax, ecx
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN56@Reallocate
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File a:\vs\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0005e	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00066	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00069	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0006c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 1609 : 		}

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN61@Reallocate:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00076	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0007b	cc		 int	 3
?_Reallocate@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBE_NPBQAVCArea@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBE_NPBQAVCArea@@@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBE_NPBQAVCArea@@@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBEII@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IBEII@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXPAPAVCArea@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXPAPAVCArea@@0@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXPAPAVCArea@@0@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Buy, COMDAT
; _this$ = ecx

; 1546 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00016	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN4@Buy

; 1552 : 			return (false);

  00021	32 c0		 xor	 al, al
  00023	5e		 pop	 esi

; 1562 : 		}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN4@Buy:

; 1553 : 		else if (max_size() < _Capacity)

  00028	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0002d	77 27		 ja	 SHORT $LN35@Buy
  0002f	57		 push	 edi
; File a:\vs\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00030	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  00037	57		 push	 edi
  00038	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003d	83 c4 04	 add	 esp, 4
  00040	85 c0		 test	 eax, eax
  00042	74 1c		 je	 SHORT $LN26@Buy
; File a:\vs\vc\include\vector

; 1558 : 			this->_Mylast = this->_Myfirst;

  00044	89 06		 mov	 DWORD PTR [esi], eax
  00046	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;

  00049	03 c7		 add	 eax, edi
  0004b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1560 : 			}
; 1561 : 		return (true);

  0004e	b0 01		 mov	 al, 1
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 1562 : 		}

  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
$LN35@Buy:

; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0005b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN37@Buy:
$LN26@Buy:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00060	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN38@Buy:
$LN34@Buy:
  00065	cc		 int	 3
?_Buy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Pop_back_n@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Pop_back_n@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXI@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Pop_back_n, COMDAT
; _this$ = ecx

; 1495 : 		{	// erase _Count elements at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1496 : 		pointer _Ptr = this->_Mylast - _Count;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	f7 d8		 neg	 eax
  00008	c1 e0 02	 shl	 eax, 2

; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;

  0000b	01 41 04	 add	 DWORD PTR [ecx+4], eax

; 1504 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Pop_back_n@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Pop_back_n
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::erase, COMDAT
; _this$ = ecx

; 1452 : 		{	// erase element at where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
; File a:\vs\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  0000d	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00010	2b d6		 sub	 edx, esi

; 2431 : 		_Count * sizeof (*_First));

  00012	83 e2 fc	 and	 edx, -4			; fffffffcH
  00015	52		 push	 edx
  00016	56		 push	 esi
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File a:\vs\vc\include\xutility

; 2431 : 		_Count * sizeof (*_First));

  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1456 : 		--this->_Mylast;

  00023	83 47 04 fc	 add	 DWORD PTR [edi+4], -4	; fffffffcH

; 47   : 		{	// construct with pointer _Parg

  00027	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  0002a	5f		 pop	 edi
  0002b	89 08		 mov	 DWORD PTR [eax], ecx
  0002d	5e		 pop	 esi

; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
?erase@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXABQAVCArea@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXABQAVCArea@@@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 31		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2b		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXI@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Reserve
$LN3@push_back:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 2a		 je	 SHORT $LN49@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00036	89 01		 mov	 DWORD PTR [ecx], eax
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00038	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00042	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00045	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXI@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Reserve
$LN1@push_back:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	85 c9		 test	 ecx, ecx
  00055	74 04		 je	 SHORT $LN49@push_back
  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	89 01		 mov	 DWORD PTR [ecx], eax
$LN49@push_back:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  0005b	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?push_back@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXABQAVCArea@@@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??A?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEAAPAVCArea@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEAAPAVCArea@@I@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::operator[], COMDAT
; _this$ = ecx

; 1197 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00008	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1210 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEAAPAVCArea@@I@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?empty@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE_NXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
;	COMDAT ?resize@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXI@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::resize, COMDAT
; _this$ = ecx

; 1100 : 		{	// determine new length, padding as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx
  00006	56		 push	 esi

; 1101 : 		if (_Newsize < size())

  00007	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0000a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0000d	8b d0		 mov	 edx, eax
  0000f	2b 13		 sub	 edx, DWORD PTR [ebx]
  00011	c1 fa 02	 sar	 edx, 2

; 1101 : 		if (_Newsize < size())

  00014	3b d6		 cmp	 edx, esi
  00016	76 0e		 jbe	 SHORT $LN42@resize

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;

  00018	2b f2		 sub	 esi, edx
  0001a	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
  0001d	5e		 pop	 esi

; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();

  0001e	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00021	5b		 pop	 ebx

; 1115 : 			}
; 1116 : 		}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN42@resize:

; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)

  00026	73 32		 jae	 SHORT $LN2@resize

; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());

  00028	8b c6		 mov	 eax, esi
  0002a	57		 push	 edi
  0002b	2b c2		 sub	 eax, edx
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAEXI@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Reserve

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00033	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]

; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);

  00036	8b ce		 mov	 ecx, esi

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00038	8b c7		 mov	 eax, edi
  0003a	2b 03		 sub	 eax, DWORD PTR [ebx]
  0003c	c1 f8 02	 sar	 eax, 2

; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);

  0003f	2b c8		 sub	 ecx, eax
; File a:\vs\vc\include\xutility

; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00041	74 04		 je	 SHORT $LN33@resize
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00043	33 c0		 xor	 eax, eax
  00045	f3 ab		 rep stosd
$LN33@resize:
  00047	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0004a	8b c1		 mov	 eax, ecx
  0004c	2b 03		 sub	 eax, DWORD PTR [ebx]
  0004e	c1 f8 02	 sar	 eax, 2

; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();

  00051	2b f0		 sub	 esi, eax
  00053	5f		 pop	 edi
  00054	8d 04 b1	 lea	 eax, DWORD PTR [ecx+esi*4]
  00057	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN2@resize:
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx

; 1115 : 			}
; 1116 : 		}

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?resize@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Make_iter, COMDAT
; _this$ = ecx

; 1044 : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::end, COMDAT
; _this$ = ecx

; 1039 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::begin, COMDAT
; _this$ = ecx

; 1029 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@2@XZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::~vector<CArea *,std::allocator<CArea *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::~vector<CArea *,std::allocator<CArea *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::vector<CArea *,std::allocator<CArea *> >, COMDAT
; _this$ = ecx

; 721  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi

; 721  : 		{	// construct by copying _Right

  00008	8b f9		 mov	 edi, ecx

; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);
; 206  : 		}
; 207  : 
; 208  : 	bool operator!=(const _Myiter& _Right) const
; 209  : 		{	// test for iterator inequality
; 210  : 		return (!(*this == _Right));
; 211  : 		}
; 212  : 
; 213  : 	bool operator<(const _Myiter& _Right) const
; 214  : 		{	// test if this < _Right
; 215  : 		_Compat(_Right);
; 216  : 		return (this->_Ptr < _Right._Ptr);
; 217  : 		}
; 218  : 
; 219  : 	bool operator>(const _Myiter& _Right) const
; 220  : 		{	// test if this > _Right
; 221  : 		return (_Right < *this);
; 222  : 		}
; 223  : 
; 224  : 	bool operator<=(const _Myiter& _Right) const
; 225  : 		{	// test if this <= _Right
; 226  : 		return (!(_Right < *this));
; 227  : 		}
; 228  : 
; 229  : 	bool operator>=(const _Myiter& _Right) const
; 230  : 		{	// test if this >= _Right
; 231  : 		return (!(*this < _Right));
; 232  : 		}
; 233  : 
; 234  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 235  : 	void _Compat(const _Myiter& _Right) const
; 236  : 		{	// test for compatible iterator pair
; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())
; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");
; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 242  : 			}
; 243  : 		}
; 244  : 
; 245  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 246  : 	void _Compat(const _Myiter& _Right) const
; 247  : 		{	// test for compatible iterator pair
; 248  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 249  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 250  : 		}
; 251  : 
; 252  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 253  : 	void _Compat(const _Myiter&) const
; 254  : 		{	// test for compatible iterator pair
; 255  : 		}
; 256  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 257  : 
; 258  : 	_Tptr _Ptr;	// pointer to element in vector
; 259  : 	};
; 260  : 
; 261  : template<class _Myvec> inline
; 262  : 	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
; 263  : 		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
; 264  : 	{	// convert to unchecked
; 265  : 	return (_Iter._Unchecked());
; 266  : 	}
; 267  : 
; 268  : template<class _Myvec> inline
; 269  : 	_Vector_const_iterator<_Myvec>&
; 270  : 		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
; 271  : 			typename _Vector_const_iterator<_Myvec>
; 272  : 				::_Unchecked_type _Right)
; 273  : 	{	// convert to checked
; 274  : 	return (_Iter._Rechecked(_Right));
; 275  : 	}
; 276  : 
; 277  : template<class _Myvec> inline
; 278  : 	_Vector_const_iterator<_Myvec> operator+(
; 279  : 		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
; 280  : 		_Vector_const_iterator<_Myvec> _Next)
; 281  : 	{	// add offset to iterator
; 282  : 	return (_Next += _Off);
; 283  : 	}
; 284  : 
; 285  : 		// TEMPLATE CLASS _Vector_iterator
; 286  : template<class _Myvec>
; 287  : 	class _Vector_iterator
; 288  : 		: public _Vector_const_iterator<_Myvec>
; 289  : 	{	// iterator for mutable vector
; 290  : public:
; 291  : 	typedef _Vector_iterator<_Myvec> _Myiter;
; 292  : 	typedef _Vector_const_iterator<_Myvec> _Mybase;
; 293  : 	typedef random_access_iterator_tag iterator_category;
; 294  : 
; 295  : 	typedef typename _Myvec::value_type value_type;
; 296  : 	typedef typename _Myvec::difference_type difference_type;
; 297  : 	typedef typename _Myvec::pointer pointer;
; 298  : 	typedef typename _Myvec::reference reference;
; 299  : 
; 300  : 	_Vector_iterator()
; 301  : 		{	// construct with null vector pointer
; 302  : 		}
; 303  : 
; 304  : 	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
; 305  : 		: _Mybase(_Parg, _Pvector)
; 306  : 		{	// construct with pointer _Parg
; 307  : 		}
; 308  : 
; 309  : 	typedef pointer _Unchecked_type;
; 310  : 
; 311  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 312  : 		{	// reset from unchecked iterator
; 313  : 		this->_Ptr = _Right;
; 314  : 		return (*this);
; 315  : 		}
; 316  : 
; 317  : 	_Unchecked_type _Unchecked() const
; 318  : 		{	// make an unchecked iterator
; 319  : 		return (_Unchecked_type(this->_Ptr));
; 320  : 		}
; 321  : 
; 322  : 	reference operator*() const
; 323  : 		{	// return designated object
; 324  : 		return ((reference)**(_Mybase *)this);
; 325  : 		}
; 326  : 
; 327  : 	pointer operator->() const
; 328  : 		{	// return pointer to class object
; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 330  : 		}
; 331  : 
; 332  : 	_Myiter& operator++()
; 333  : 		{	// preincrement
; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);
; 336  : 		}
; 337  : 
; 338  : 	_Myiter operator++(int)
; 339  : 		{	// postincrement
; 340  : 		_Myiter _Tmp = *this;
; 341  : 		++*this;
; 342  : 		return (_Tmp);
; 343  : 		}
; 344  : 
; 345  : 	_Myiter& operator--()
; 346  : 		{	// predecrement
; 347  : 		--*(_Mybase *)this;
; 348  : 		return (*this);
; 349  : 		}
; 350  : 
; 351  : 	_Myiter operator--(int)
; 352  : 		{	// postdecrement
; 353  : 		_Myiter _Tmp = *this;
; 354  : 		--*this;
; 355  : 		return (_Tmp);
; 356  : 		}
; 357  : 
; 358  : 	_Myiter& operator+=(difference_type _Off)
; 359  : 		{	// increment by integer
; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);
; 362  : 		}
; 363  : 
; 364  : 	_Myiter operator+(difference_type _Off) const
; 365  : 		{	// return this + integer
; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);
; 368  : 		}
; 369  : 
; 370  : 	_Myiter& operator-=(difference_type _Off)
; 371  : 		{	// decrement by integer
; 372  : 		return (*this += -_Off);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator-(difference_type _Off) const
; 376  : 		{	// return this - integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);
; 379  : 		}
; 380  : 
; 381  : 	difference_type operator-(const _Mybase& _Right) const
; 382  : 		{	// return difference of iterators
; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}
; 385  : 
; 386  : 	reference operator[](difference_type _Off) const
; 387  : 		{	// subscript
; 388  : 		return (*(*this + _Off));
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : template<class _Myvec> inline
; 393  : 	typename _Vector_iterator<_Myvec>::_Unchecked_type
; 394  : 		_Unchecked(_Vector_iterator<_Myvec> _Iter)
; 395  : 	{	// convert to unchecked
; 396  : 	return (_Iter._Unchecked());
; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 443  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 444  : 
; 445  : 
; 446  : 	typedef typename _Alty::pointer _Tptr;
; 447  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 448  : 
; 449  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 450  : 		_Simple_types<typename _Alty::value_type>,
; 451  : 		_Vec_iter_types<typename _Alty::value_type,
; 452  : 			typename _Alty::size_type,
; 453  : 			typename _Alty::difference_type,
; 454  : 			typename _Alty::pointer,
; 455  : 			typename _Alty::const_pointer,
; 456  : 			typename _Alty::reference,
; 457  : 			typename _Alty::const_reference> >::type
; 458  : 		_Val_types;
; 459  : 	};
; 460  : 
; 461  : 		// TEMPLATE CLASS _Vector_val
; 462  : template<class _Val_types>
; 463  : 	class _Vector_val
; 464  : 		: public _Container_base
; 465  : 	{	// base class for vector to hold data
; 466  : public:
; 467  : 	typedef _Vector_val<_Val_types> _Myt;
; 468  : 
; 469  : 	typedef typename _Val_types::value_type value_type;
; 470  : 	typedef typename _Val_types::size_type size_type;
; 471  : 	typedef typename _Val_types::difference_type difference_type;
; 472  : 	typedef typename _Val_types::pointer pointer;
; 473  : 	typedef typename _Val_types::const_pointer const_pointer;
; 474  : 	typedef typename _Val_types::reference reference;
; 475  : 	typedef typename _Val_types::const_reference const_reference;
; 476  : 
; 477  : 	typedef _Vector_iterator<_Myt> iterator;
; 478  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 479  : 
; 480  : 	_Vector_val()
; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  0000a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 483  : 		_Mylast = pointer();

  00010	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 484  : 		_Myend = pointer();

  00017	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0001e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00021	2b 06		 sub	 eax, DWORD PTR [esi]
  00023	c1 f8 02	 sar	 eax, 2

; 722  : 		if (_Buy(_Right.size()))

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?_Buy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@IAE_NI@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Buy
  0002c	84 c0		 test	 al, al
  0002e	74 22		 je	 SHORT $LN55@vector

; 61   : 		return (_Unchecked_type(this->_Ptr));

  00030	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File a:\vs\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00032	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00035	2b c1		 sub	 eax, ecx
  00037	c1 f8 02	 sar	 eax, 2

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0003a	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00041	56		 push	 esi
  00042	51		 push	 ecx
  00043	ff 37		 push	 DWORD PTR [edi]
  00045	e8 00 00 00 00	 call	 _memmove
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	03 c6		 add	 eax, esi
; File a:\vs\vc\include\vector

; 725  : 				this->_Myfirst);

  0004f	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN55@vector:

; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}

  00052	8b c7		 mov	 eax, edi
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
??0?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::vector<CArea *,std::allocator<CArea *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::vector<CArea *,std::allocator<CArea *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::vector<CArea *,std::allocator<CArea *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CArea *,std::allocator<CArea *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CArea *,std::allocator<CArea *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCArea@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCArea@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CArea *,std::allocator<CArea *> > >::_Vector_alloc<0,std::_Vec_base_types<CArea *,std::allocator<CArea *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCArea@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CArea *,std::allocator<CArea *> > >::_Vector_alloc<0,std::_Vec_base_types<CArea *,std::allocator<CArea *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CArea *> >::_Vector_val<std::_Simple_types<CArea *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CArea *> >::_Vector_val<std::_Simple_types<CArea *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CArea *> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CArea *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEXPAPAVCArea@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEXPAPAVCArea@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CArea *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEXPAPAVCArea@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CArea *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CArea *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CArea *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAE@ABV?$allocator@PAVCArea@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAE@ABV?$allocator@PAVCArea@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<CArea *> >::_Wrap_alloc<std::allocator<CArea *> >, COMDAT
; _this$ = ecx

; 807  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAE@ABV?$allocator@PAVCArea@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<CArea *> >::_Wrap_alloc<std::allocator<CArea *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CArea *> >::_Wrap_alloc<std::allocator<CArea *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CArea *> >::_Wrap_alloc<std::allocator<CArea *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<CArea *> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 778  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 780  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVCArea@@@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<CArea *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SA?AV?$allocator@PAVCArea@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SA?AV?$allocator@PAVCArea@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<CArea *> >::select_on_container_copy_construction, COMDAT

; 740  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 741  : 		return (_Al.select_on_container_copy_construction());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 742  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SA?AV?$allocator@PAVCArea@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<CArea *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SAIABV?$allocator@PAVCArea@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SAIABV?$allocator@PAVCArea@@@2@@Z PROC ; std::allocator_traits<std::allocator<CArea *> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVCArea@@@std@@@std@@SAIABV?$allocator@PAVCArea@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CArea *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVCArea@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCArea@@@std@@QBEIXZ PROC	; std::allocator<CArea *>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVCArea@@@std@@QBEIXZ ENDP	; std::allocator<CArea *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVCArea@@@std@@QAEXPAPAVCArea@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCArea@@@std@@QAEXPAPAVCArea@@ABQAV3@@Z PROC ; std::allocator<CArea *>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 594  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAVCArea@@@std@@QAEXPAPAVCArea@@ABQAV3@@Z ENDP ; std::allocator<CArea *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVCArea@@@std@@QAEPAPAVCArea@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCArea@@@std@@QAEPAPAVCArea@@I@Z PROC ; std::allocator<CArea *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAVCArea@@@std@@QAEPAPAVCArea@@I@Z ENDP ; std::allocator<CArea *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCArea@@@std@@QAEXPAPAVCArea@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCArea@@@std@@QAEXPAPAVCArea@@I@Z PROC ; std::allocator<CArea *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCArea@@@std@@QAEXPAPAVCArea@@I@Z ENDP ; std::allocator<CArea *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCArea@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCArea@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CArea *>::allocator<CArea *>, COMDAT
; _this$ = ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@PAVCArea@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CArea *>::allocator<CArea *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCArea@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCArea@@@std@@QAE@XZ PROC		; std::allocator<CArea *>::allocator<CArea *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCArea@@@std@@QAE@XZ ENDP		; std::allocator<CArea *>::allocator<CArea *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@PAVCArea@@@std@@QBE?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@PAVCArea@@@std@@QBE?AV12@XZ PROC ; std::allocator<CArea *>::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 532  : 		{	// return this allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 533  : 		return (*this);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 534  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?select_on_container_copy_construction@?$allocator@PAVCArea@@@std@@QBE?AV12@XZ ENDP ; std::allocator<CArea *>::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCSpeedTreeForestDirectX8@@@@SAAAVCSpeedTreeForestDirectX8@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCSpeedTreeForestDirectX8@@@@SAAAVCSpeedTreeForestDirectX8@@XZ PROC ; CSingleton<CSpeedTreeForestDirectX8>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCSpeedTreeForestDirectX8@@@@SAAAVCSpeedTreeForestDirectX8@@XZ ENDP ; CSingleton<CSpeedTreeForestDirectX8>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator-, COMDAT
; _this$ = ecx

; 382  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	c1 f8 02	 sar	 eax, 2

; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator++, COMDAT
; _this$ = ecx

; 112  : 		++this->_Ptr;

  00000	83 01 04	 add	 DWORD PTR [ecx], 4

; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 336  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEAAPAVCGraphicObjectInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEAAPAVCGraphicObjectInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEAAPAVCGraphicObjectInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicObjectInstance@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicObjectInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicObjectInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAEAAV12@PAPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAEAAV12@PAPAVCGraphicObjectInstance@@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Rechecked, COMDAT
; _this$ = ecx

; 312  : 		{	// reset from unchecked iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		this->_Ptr = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 314  : 		return (*this);

  00008	8b c1		 mov	 eax, ecx

; 315  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAEAAV12@PAPAVCGraphicObjectInstance@@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >, COMDAT
; _this$ = ecx

; 42   : 		{	// construct with null pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 301  : 		{	// construct with null vector pointer
; 302  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 211  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 206  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator-, COMDAT
; _this$ = ecx

; 192  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	c1 f8 02	 sar	 eax, 2

; 195  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  00000	83 01 04	 add	 DWORD PTR [ecx], 4

; 113  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 114  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEABQAVCGraphicObjectInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEABQAVCGraphicObjectInstance@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEABQAVCGraphicObjectInstance@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >, COMDAT
; _this$ = ecx

; 42   : 		{	// construct with null pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 43   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBEXPAPAVCGraphicObjectInstance@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBEXPAPAVCGraphicObjectInstance@@0@Z PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBEXPAPAVCGraphicObjectInstance@@0@Z ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBEXXZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBEXXZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXXZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXXZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 02	 sar	 eax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 02	 sar	 esi, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 02	 sar	 edx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi

; 23   : 	void *_Ptr = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
; File a:\vs\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 db		 test	 ebx, ebx
  0000f	74 1e		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00017	77 5d		 ja	 SHORT $LN61@Reallocate
  00019	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 04	 add	 esp, 4
  0002b	85 f6		 test	 esi, esi
  0002d	74 47		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File a:\vs\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 e0 fc	 and	 eax, -4			; fffffffcH
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00041	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00046	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00049	2b c1		 sub	 eax, ecx
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN56@Reallocate
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File a:\vs\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0005e	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00066	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00069	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0006c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 1609 : 		}

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN61@Reallocate:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00076	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0007b	cc		 int	 3
?_Reallocate@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBE_NPBQAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBE_NPBQAVCGraphicObjectInstance@@@Z PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBE_NPBQAVCGraphicObjectInstance@@@Z ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBEII@Z PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IBEII@Z ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXPAPAVCGraphicObjectInstance@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXPAPAVCGraphicObjectInstance@@0@Z PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXPAPAVCGraphicObjectInstance@@0@Z ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXABQAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXABQAVCGraphicObjectInstance@@@Z PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 31		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2b		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Reserve
$LN3@push_back:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 2a		 je	 SHORT $LN49@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00036	89 01		 mov	 DWORD PTR [ecx], eax
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00038	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00042	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00045	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Reserve
$LN1@push_back:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	85 c9		 test	 ecx, ecx
  00055	74 04		 je	 SHORT $LN49@push_back
  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	89 01		 mov	 DWORD PTR [ecx], eax
$LN49@push_back:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  0005b	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?push_back@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXABQAVCGraphicObjectInstance@@@Z ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::~vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::~vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicObjectInstance@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicObjectInstance@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicObjectInstance@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> >::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> >::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXPAPAVCGraphicObjectInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXPAPAVCGraphicObjectInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEXPAPAVCGraphicObjectInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEPAPAVCGraphicObjectInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEPAPAVCGraphicObjectInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAEPAPAVCGraphicObjectInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >::_Wrap_alloc<std::allocator<CGraphicObjectInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@SAIABV?$allocator@PAVCGraphicObjectInstance@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@SAIABV?$allocator@PAVCGraphicObjectInstance@@@2@@Z PROC ; std::allocator_traits<std::allocator<CGraphicObjectInstance *> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@SAIABV?$allocator@PAVCGraphicObjectInstance@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CGraphicObjectInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVCGraphicObjectInstance@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCGraphicObjectInstance@@@std@@QBEIXZ PROC ; std::allocator<CGraphicObjectInstance *>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVCGraphicObjectInstance@@@std@@QBEIXZ ENDP ; std::allocator<CGraphicObjectInstance *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEXPAPAVCGraphicObjectInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEXPAPAVCGraphicObjectInstance@@ABQAV3@@Z PROC ; std::allocator<CGraphicObjectInstance *>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 594  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEXPAPAVCGraphicObjectInstance@@ABQAV3@@Z ENDP ; std::allocator<CGraphicObjectInstance *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEPAPAVCGraphicObjectInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEPAPAVCGraphicObjectInstance@@I@Z PROC ; std::allocator<CGraphicObjectInstance *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEPAPAVCGraphicObjectInstance@@I@Z ENDP ; std::allocator<CGraphicObjectInstance *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEXPAPAVCGraphicObjectInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEXPAPAVCGraphicObjectInstance@@I@Z PROC ; std::allocator<CGraphicObjectInstance *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCGraphicObjectInstance@@@std@@QAEXPAPAVCGraphicObjectInstance@@I@Z ENDP ; std::allocator<CGraphicObjectInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCGraphicObjectInstance@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCGraphicObjectInstance@@@std@@QAE@XZ PROC ; std::allocator<CGraphicObjectInstance *>::allocator<CGraphicObjectInstance *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCGraphicObjectInstance@@@std@@QAE@XZ ENDP ; std::allocator<CGraphicObjectInstance *>::allocator<CGraphicObjectInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?RangeTest@CCullingManager@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_radius$ = 12						; size = 4
_callback$ = 16						; size = 4
?RangeTest@CCullingManager@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z PROC ; CCullingManager::RangeTest, COMDAT
; _this$ = ecx

; 94   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   : 		m_Factory->RangeTest(p, radius, callback);

  00003	ff 75 10	 push	 DWORD PTR _callback$[ebp]
  00006	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _radius$[ebp]
  0000b	51		 push	 ecx
  0000c	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0000f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00014	ff 75 08	 push	 DWORD PTR _p$[ebp]
  00017	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest

; 96   : 	}

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
?RangeTest@CCullingManager@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ENDP ; CCullingManager::RangeTest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ PROC ; CSingleton<CCullingManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ ENDP ; CSingleton<CCullingManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ?GetUserData@SpherePack@@QBEPAXXZ
_TEXT	SEGMENT
?GetUserData@SpherePack@@QBEPAXXZ PROC			; SpherePack::GetUserData, COMDAT
; _this$ = ecx

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00000	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00003	c3		 ret	 0
?GetUserData@SpherePack@@QBEPAXXZ ENDP			; SpherePack::GetUserData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ??_GSpherePackCallback@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GSpherePackCallback@@UAEPAXI@Z PROC			; SpherePackCallback::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 56   : 	virtual ~SpherePackCallback() {}

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7SpherePackCallback@@6B@
  00010	74 09		 je	 SHORT $LN6@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN6@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_GSpherePackCallback@@UAEPAXI@Z ENDP			; SpherePackCallback::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_searchpos$ = 8						; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::PointTest2dCallback, COMDAT
; _this$ = ecx

; 79   : 	{};

  00000	c2 0c 00	 ret	 12			; 0000000cH
?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::PointTest2dCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_searchpos$ = 8						; size = 4
_distance$ = 12						; size = 4
_sphere$ = 16						; size = 4
_state$ = 20						; size = 4
?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::RangeTestCallback, COMDAT
; _this$ = ecx

; 74   : 	{};

  00000	c2 10 00	 ret	 16			; 00000010H
?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::RangeTestCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_distance$ = 16						; size = 4
_sect$ = 20						; size = 4
_sphere$ = 24						; size = 4
?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z PROC ; SpherePackCallback::RayTraceCallback, COMDAT
; _this$ = ecx

; 68   : 	{};

  00000	c2 14 00	 ret	 20			; 00000014H
?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ENDP ; SpherePackCallback::RayTraceCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::VisibilityCallback, COMDAT
; _this$ = ecx

; 61   : 	{};

  00000	c2 0c 00	 ret	 12			; 0000000cH
?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::VisibilityCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ??1SpherePackCallback@@UAE@XZ
_TEXT	SEGMENT
??1SpherePackCallback@@UAE@XZ PROC			; SpherePackCallback::~SpherePackCallback, COMDAT
; _this$ = ecx

; 56   : 	virtual ~SpherePackCallback() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SpherePackCallback@@6B@
  00006	c3		 ret	 0
??1SpherePackCallback@@UAE@XZ ENDP			; SpherePackCallback::~SpherePackCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ??0SpherePackCallback@@QAE@XZ
_TEXT	SEGMENT
??0SpherePackCallback@@QAE@XZ PROC			; SpherePackCallback::SpherePackCallback, COMDAT
; _this$ = ecx

; 55   : 	SpherePackCallback() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SpherePackCallback@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0SpherePackCallback@@QAE@XZ ENDP			; SpherePackCallback::SpherePackCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ PROC ; CSingleton<CCameraManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ ENDP ; CSingleton<CCameraManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
;	COMDAT ?GetDistance@CCamera@@QBEMXZ
_TEXT	SEGMENT
?GetDistance@CCamera@@QBEMXZ PROC			; CCamera::GetDistance, COMDAT
; _this$ = ecx

; 186  : 		float GetDistance() const { return m_fDistance; }

  00000	d9 81 34 01 00
	00		 fld	 DWORD PTR [ecx+308]
  00006	c3		 ret	 0
?GetDistance@CCamera@@QBEMXZ ENDP			; CCamera::GetDistance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
;	COMDAT ?GetView@CCamera@@QBEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
?GetView@CCamera@@QBEABUD3DXVECTOR3@@XZ PROC		; CCamera::GetView, COMDAT
; _this$ = ecx

; 171  : 		const D3DXVECTOR3 & GetView() const		{ return m_v3View; }

  00000	8d 41 54	 lea	 eax, DWORD PTR [ecx+84]
  00003	c3		 ret	 0
?GetView@CCamera@@QBEABUD3DXVECTOR3@@XZ ENDP		; CCamera::GetView
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
;	COMDAT ?GetTarget@CCamera@@QBEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
?GetTarget@CCamera@@QBEABUD3DXVECTOR3@@XZ PROC		; CCamera::GetTarget, COMDAT
; _this$ = ecx

; 169  : 		const D3DXVECTOR3 & GetTarget() const	{ return m_v3Target; }

  00000	8d 41 3c	 lea	 eax, DWORD PTR [ecx+60]
  00003	c3		 ret	 0
?GetTarget@CCamera@@QBEABUD3DXVECTOR3@@XZ ENDP		; CCamera::GetTarget
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
;	COMDAT ?GetEye@CCamera@@QBEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
?GetEye@CCamera@@QBEABUD3DXVECTOR3@@XZ PROC		; CCamera::GetEye, COMDAT
; _this$ = ecx

; 168  : 		const D3DXVECTOR3 & GetEye() const		{ return m_v3Eye; }

  00000	8d 41 30	 lea	 eax, DWORD PTR [ecx+48]
  00003	c3		 ret	 0
?GetEye@CCamera@@QBEABUD3DXVECTOR3@@XZ ENDP		; CCamera::GetEye
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ?Set@Vector3d@@QAEXMMM@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
?Set@Vector3d@@QAEXMMM@Z PROC				; Vector3d::Set, COMDAT
; _this$ = ecx

; 106  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 107  : 		x = a;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _a$[ebp]
  00008	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 108  : 		y = b;

  0000c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _b$[ebp]
  00011	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 109  : 		z = c;

  00016	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _c$[ebp]
  0001b	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0

; 110  : 	};

  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
?Set@Vector3d@@QAEXMMM@Z ENDP				; Vector3d::Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ??0Vector3d@@QAE@XZ
_TEXT	SEGMENT
??0Vector3d@@QAE@XZ PROC				; Vector3d::Vector3d, COMDAT
; _this$ = ecx

; 26   : 	Vector3d(void) { };  // null constructor, does not inialize point.

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0Vector3d@@QAE@XZ ENDP				; Vector3d::Vector3d
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0CDynamicSphereInstance@@QAE@XZ
_TEXT	SEGMENT
??0CDynamicSphereInstance@@QAE@XZ PROC			; CDynamicSphereInstance::CDynamicSphereInstance, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0CDynamicSphereInstance@@QAE@XZ ENDP			; CDynamicSphereInstance::CDynamicSphereInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ PROC	; CSingleton<CTimer>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ ENDP	; CSingleton<CTimer>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv160 = 8						; size = 4
_pV$ = 8						; size = 4
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z PROC		; D3DXVec3LengthSq, COMDAT

; 1247 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pV$[ebp]
  00006	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0000b	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0000f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00014	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00018	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0001c	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00020	f3 0f 58 d1	 addss	 xmm2, xmm1
  00024	f3 0f 58 d0	 addss	 xmm2, xmm0
  00028	f3 0f 11 55 08	 movss	 DWORD PTR tv160[ebp], xmm2
  0002d	d9 45 08	 fld	 DWORD PTR tv160[ebp]

; 1254 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3LengthSq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv161 = -4						; size = 4
_pV$ = 8						; size = 4
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z PROC		; D3DXVec3Length, COMDAT

; 1232 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00009	8b 45 08	 mov	 eax, DWORD PTR _pV$[ebp]
  0000c	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00011	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  00015	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0001a	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0001e	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00022	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00026	f3 0f 58 d1	 addss	 xmm2, xmm1
  0002a	f3 0f 58 d0	 addss	 xmm2, xmm0
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  0002e	0f 5a c2	 cvtps2pd xmm0, xmm2
  00031	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00036	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  0003a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv161[esp+8], xmm0
  00040	d9 44 24 04	 fld	 DWORD PTR tv161[esp+8]

; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3Length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec2Dot@@YAMPBUD3DXVECTOR2@@0@Z
_TEXT	SEGMENT
_pV1$ = 8						; size = 4
_pV2$ = 12						; size = 4
?D3DXVec2Dot@@YAMPBUD3DXVECTOR2@@0@Z PROC		; D3DXVec2Dot, COMDAT

; 1126 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pV1$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _pV2$[ebp]
  00009	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0000c	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0000f	d9 01		 fld	 DWORD PTR [ecx]
  00011	d8 08		 fmul	 DWORD PTR [eax]
  00013	de c1		 faddp	 ST(1), ST(0)

; 1133 : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?D3DXVec2Dot@@YAMPBUD3DXVECTOR2@@0@Z ENDP		; D3DXVec2Dot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??D@YA?AUD3DXVECTOR3@@MABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
_v$ = 16						; size = 4
??D@YA?AUD3DXVECTOR3@@MABU0@@Z PROC			; operator*, COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]

; 180  :     x = fx;

  0000b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0000e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00012	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 180  :     x = fx;

  00016	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0001a	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001f	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 181  :     y = fy;

  00023	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00028	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0002d	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 182  :     z = fz;

  00031	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 284  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??D@YA?AUD3DXVECTOR3@@MABU0@@Z ENDP			; operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  0000a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0000d	f3 0f 5c 02	 subss	 xmm0, DWORD PTR [edx]

; 180  :     x = fx;

  00011	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00015	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001a	f3 0f 5c 42 04	 subss	 xmm0, DWORD PTR [edx+4]

; 181  :     y = fy;

  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00024	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00029	f3 0f 5c 42 08	 subss	 xmm0, DWORD PTR [edx+8]

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 264  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+, COMDAT
; _this$ = ecx

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]

; 180  :     x = fx;

  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00009	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000d	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  00011	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00015	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  0001a	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]

; 181  :     y = fy;

  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00024	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
  00029	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 258  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??XD3DXVECTOR3@@QAEAAU0@M@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
??XD3DXVECTOR3@@QAEAAU0@M@Z PROC			; D3DXVECTOR3::operator*=, COMDAT
; _this$ = ecx

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 222  :     x *= f;

  00003	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 223  :     y *= f;
; 224  :     z *= f;
; 225  :     return *this;

  00007	8b c1		 mov	 eax, ecx
  00009	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _f$[ebp]
  0000e	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00012	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  00016	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001b	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0001f	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00024	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00029	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0002d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0

; 226  : }

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??XD3DXVECTOR3@@QAEAAU0@M@Z ENDP			; D3DXVECTOR3::operator*=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]

; 181  :     y = fy;
; 182  :     z = fz;
; 183  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR2@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR2@@QAE@XZ PROC				; D3DXVECTOR2::D3DXVECTOR2, COMDAT
; _this$ = ecx

; 46   :     D3DXVECTOR2() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR2@@QAE@XZ ENDP				; D3DXVECTOR2::D3DXVECTOR2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 65   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 61   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv68 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 774  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 775  :     return (float)sqrt(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00016	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0001a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv68[esp+8], xmm0
  00020	d9 44 24 04	 fld	 DWORD PTR tv68[esp+8]

; 776  : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	4e		 dec	 esi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	57		 push	 edi
  0000f	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b cf		 mov	 ecx, edi
  00014	ff d3		 call	 ebx
  00016	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  00019	4e		 dec	 esi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5f		 pop	 edi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
