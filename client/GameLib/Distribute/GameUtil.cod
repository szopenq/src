; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	A:\From C\Desktop\Serwer\Source\Source Client\client\GameLib\GameUtil.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_acosf
PUBLIC	_floorf
PUBLIC	_fmodf
PUBLIC	?floor@@YAMM@Z					; floor
PUBLIC	?fmod@@YAMMM@Z					; fmod
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator-
PUBLIC	?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z	; D3DXVec3LengthSq
PUBLIC	?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z		; D3DXVec3Dot
PUBLIC	?DetectCollisionDynamicSphereVSDynamicSphere@@YA_NABUCDynamicSphereInstance@@0@Z ; DetectCollisionDynamicSphereVSDynamicSphere
PUBLIC	?DetectCollisionDynamicZCylinderVSDynamicZCylinder@@YA_NABUCDynamicSphereInstance@@0@Z ; DetectCollisionDynamicZCylinderVSDynamicZCylinder
PUBLIC	?GetDegreeFromPosition@@YAMMM@Z			; GetDegreeFromPosition
PUBLIC	?GetDegreeFromPosition2@@YAMMMMM@Z		; GetDegreeFromPosition2
PUBLIC	?GetInterpolatedRotation@@YAMMMM@Z		; GetInterpolatedRotation
PUBLIC	?IsCWRotation@@YA_NMM@Z				; IsCWRotation
PUBLIC	?IsCCWRotation@@YA_NMM@Z			; IsCCWRotation
PUBLIC	?IsCWAcuteAngle@@YA_NMM@Z			; IsCWAcuteAngle
PUBLIC	?IsCCWAcuteAngle@@YA_NMM@Z			; IsCCWAcuteAngle
PUBLIC	?GetDegreeDifference@@YAMMM@Z			; GetDegreeDifference
PUBLIC	?GetRotatingDirection@@YAHMM@Z			; GetRotatingDirection
PUBLIC	?CameraRotationToCharacterRotation@@YAMM@Z	; CameraRotationToCharacterRotation
PUBLIC	?CharacterRotationToCameraRotation@@YAMM@Z	; CharacterRotationToCameraRotation
PUBLIC	??$swap@M@std@@YAXAAM0@Z			; std::swap<float>
PUBLIC	??$_Move@AAM@std@@YA$$QAMAAM@Z			; std::_Move<float &>
PUBLIC	__real@3f800000
PUBLIC	__real@4076800000000000
PUBLIC	__real@42652ee0
PUBLIC	__real@43340000
PUBLIC	__real@43b40000
PUBLIC	__real@44070000
EXTRN	_D3DXVec3Normalize@8:PROC
EXTRN	?GetLinearInterpolation@@YAMMMM@Z:PROC		; GetLinearInterpolation
EXTRN	?IntersectLineSegments@@YAXABUD3DXVECTOR3@@000AAU1@1@Z:PROC ; IntersectLineSegments
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIfmod:PROC
EXTRN	__libm_sse2_acos_precise:PROC
EXTRN	_floor:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@44070000
CONST	SEGMENT
__real@44070000 DD 044070000r			; 540
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@42652ee0
CONST	SEGMENT
__real@42652ee0 DD 042652ee0r			; 57.2958
CONST	ENDS
;	COMDAT __real@4076800000000000
CONST	SEGMENT
__real@4076800000000000 DQ 04076800000000000r	; 360
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$_Move@AAM@std@@YA$$QAMAAM@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAM@std@@YA$$QAMAAM@Z PROC			; std::_Move<float &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAM@std@@YA$$QAMAAM@Z ENDP			; std::_Move<float &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$swap@M@std@@YAXAAM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@M@std@@YAXAAM0@Z PROC				; std::swap<float>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00011	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 55   : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$swap@M@std@@YAXAAM0@Z ENDP				; std::swap<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
;	COMDAT ?CharacterRotationToCameraRotation@@YAMM@Z
_TEXT	SEGMENT
tv129 = -8						; size = 8
tv68 = 8						; size = 4
_fCharacterRotation$ = 8				; size = 4
?CharacterRotationToCameraRotation@@YAMM@Z PROC		; CharacterRotationToCameraRotation, COMDAT

; 399  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 400  : 	return fmod((540.0f - fCharacterRotation), 360.0f);

  00006	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44070000
  0000e	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _fCharacterRotation$[ebp]
; File a:\vs\vc\include\math.h

; 706  :     return (float)fmod(_X, _Y);

  00013	0f 5a c0	 cvtps2pd xmm0, xmm0
  00016	f2 0f 11 45 f8	 movsd	 QWORD PTR tv129[ebp], xmm0
  0001b	dd 45 f8	 fld	 QWORD PTR tv129[ebp]
  0001e	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4076800000000000
  00024	e8 00 00 00 00	 call	 __CIfmod
  00029	d9 5d 08	 fstp	 DWORD PTR tv68[ebp]
  0002c	d9 45 08	 fld	 DWORD PTR tv68[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 401  : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?CharacterRotationToCameraRotation@@YAMM@Z ENDP		; CharacterRotationToCameraRotation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
;	COMDAT ?CameraRotationToCharacterRotation@@YAMM@Z
_TEXT	SEGMENT
tv129 = -8						; size = 8
tv68 = 8						; size = 4
_fCameraRotation$ = 8					; size = 4
?CameraRotationToCharacterRotation@@YAMM@Z PROC		; CameraRotationToCharacterRotation, COMDAT

; 394  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 395  : 	return fmod((540.0f - fCameraRotation), 360.0f);

  00006	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44070000
  0000e	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _fCameraRotation$[ebp]
; File a:\vs\vc\include\math.h

; 706  :     return (float)fmod(_X, _Y);

  00013	0f 5a c0	 cvtps2pd xmm0, xmm0
  00016	f2 0f 11 45 f8	 movsd	 QWORD PTR tv129[ebp], xmm0
  0001b	dd 45 f8	 fld	 QWORD PTR tv129[ebp]
  0001e	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4076800000000000
  00024	e8 00 00 00 00	 call	 __CIfmod
  00029	d9 5d 08	 fstp	 DWORD PTR tv68[ebp]
  0002c	d9 45 08	 fld	 DWORD PTR tv68[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 396  : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?CameraRotationToCharacterRotation@@YAMM@Z ENDP		; CameraRotationToCharacterRotation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
;	COMDAT ?GetRotatingDirection@@YAHMM@Z
_TEXT	SEGMENT
_fSource$ = 8						; size = 4
_fTarget$ = 12						; size = 4
?GetRotatingDirection@@YAHMM@Z PROC			; GetRotatingDirection, COMDAT

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 366  : 	if (fSource < 180.0f)

  00003	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@43340000
  0000b	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fSource$[ebp]
  00010	0f 2f d1	 comiss	 xmm2, xmm1

; 367  : 	{
; 368  : 		if (fTarget < fSource)

  00013	f3 0f 10 5d 0c	 movss	 xmm3, DWORD PTR _fTarget$[ebp]
  00018	76 27		 jbe	 SHORT $LN8@GetRotatin
  0001a	0f 2f cb	 comiss	 xmm1, xmm3
  0001d	76 07		 jbe	 SHORT $LN7@GetRotatin

; 369  : 			return DEGREE_DIRECTION_RIGHT;

  0001f	b8 01 00 00 00	 mov	 eax, 1

; 383  : 		{
; 384  : 			return DEGREE_DIRECTION_LEFT;
; 385  : 		}
; 386  : 
; 387  : 		return DEGREE_DIRECTION_RIGHT;
; 388  : 	}
; 389  : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
$LN7@GetRotatin:

; 370  : 
; 371  : 		else if((360.0f - fTarget) + fSource < 180.0f)

  00026	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43b40000
  0002e	33 c0		 xor	 eax, eax
  00030	f3 0f 5c c3	 subss	 xmm0, xmm3
  00034	f3 0f 58 c1	 addss	 xmm0, xmm1
  00038	0f 2f d0	 comiss	 xmm2, xmm0
  0003b	0f 96 c0	 setbe	 al

; 381  : 		}
; 382  : 		else if ((360.0f - fSource) + fTarget < 180.0f)

  0003e	40		 inc	 eax

; 383  : 		{
; 384  : 			return DEGREE_DIRECTION_LEFT;
; 385  : 		}
; 386  : 
; 387  : 		return DEGREE_DIRECTION_RIGHT;
; 388  : 	}
; 389  : }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN8@GetRotatin:

; 372  : 			return DEGREE_DIRECTION_RIGHT;
; 373  : 
; 374  : 		return DEGREE_DIRECTION_LEFT;
; 375  : 	}
; 376  : 	else
; 377  : 	{
; 378  : 		if (fTarget > fSource)

  00041	0f 2f d9	 comiss	 xmm3, xmm1
  00044	76 07		 jbe	 SHORT $LN3@GetRotatin

; 379  : 		{
; 380  : 			return DEGREE_DIRECTION_LEFT;

  00046	b8 02 00 00 00	 mov	 eax, 2

; 383  : 		{
; 384  : 			return DEGREE_DIRECTION_LEFT;
; 385  : 		}
; 386  : 
; 387  : 		return DEGREE_DIRECTION_RIGHT;
; 388  : 	}
; 389  : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN3@GetRotatin:

; 381  : 		}
; 382  : 		else if ((360.0f - fSource) + fTarget < 180.0f)

  0004d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43b40000
  00055	33 c0		 xor	 eax, eax
  00057	f3 0f 5c c1	 subss	 xmm0, xmm1
  0005b	f3 0f 58 c3	 addss	 xmm0, xmm3
  0005f	0f 2f d0	 comiss	 xmm2, xmm0
  00062	0f 97 c0	 seta	 al
  00065	40		 inc	 eax

; 383  : 		{
; 384  : 			return DEGREE_DIRECTION_LEFT;
; 385  : 		}
; 386  : 
; 387  : 		return DEGREE_DIRECTION_RIGHT;
; 388  : 	}
; 389  : }

  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?GetRotatingDirection@@YAHMM@Z ENDP			; GetRotatingDirection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
;	COMDAT ?GetDegreeDifference@@YAMMM@Z
_TEXT	SEGMENT
tv131 = 8						; size = 4
tv130 = 8						; size = 4
_fSource$ = 8						; size = 4
_fTarget$ = 12						; size = 4
?GetDegreeDifference@@YAMMM@Z PROC			; GetDegreeDifference, COMDAT

; 340  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 341  : 	if (fSource < 180.0f)

  00003	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@43340000
  0000b	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fSource$[ebp]
  00010	0f 2f d0	 comiss	 xmm2, xmm0

; 342  : 	{
; 343  : 		if (fTarget < fSource)

  00013	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _fTarget$[ebp]
  00018	76 2b		 jbe	 SHORT $LN8@GetDegreeD
  0001a	0f 2f c1	 comiss	 xmm0, xmm1
  0001d	76 08		 jbe	 SHORT $LN7@GetDegreeD

; 344  : 			return fSource - fTarget;

  0001f	d9 45 08	 fld	 DWORD PTR _fSource$[ebp]
  00022	d8 65 0c	 fsub	 DWORD PTR _fTarget$[ebp]

; 362  : 	}
; 363  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN7@GetDegreeD:

; 345  : 
; 346  : 		else if(fTarget - fSource > 180.0f)

  00027	f3 0f 5c c8	 subss	 xmm1, xmm0
  0002b	0f 2f ca	 comiss	 xmm1, xmm2
  0002e	f3 0f 11 4d 08	 movss	 DWORD PTR tv131[ebp], xmm1
  00033	76 0b		 jbe	 SHORT $LN5@GetDegreeD

; 347  : 			return (360.0f - (fTarget - fSource));

  00035	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@43b40000
  0003b	d8 65 08	 fsub	 DWORD PTR tv131[ebp]

; 362  : 	}
; 363  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN5@GetDegreeD:

; 348  : 
; 349  : 		return fTarget - fSource;

  00040	d9 45 08	 fld	 DWORD PTR tv131[ebp]

; 362  : 	}
; 363  : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
$LN8@GetDegreeD:

; 350  : 	}
; 351  : 	else
; 352  : 	{
; 353  : 		if (fTarget > fSource)

  00045	0f 2f c8	 comiss	 xmm1, xmm0
  00048	76 08		 jbe	 SHORT $LN3@GetDegreeD

; 354  : 			return fTarget - fSource;

  0004a	d9 45 0c	 fld	 DWORD PTR _fTarget$[ebp]
  0004d	d8 65 08	 fsub	 DWORD PTR _fSource$[ebp]

; 362  : 	}
; 363  : }

  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN3@GetDegreeD:

; 355  : 
; 356  : 		else if (fSource - fTarget > 180.0f)

  00052	f3 0f 5c c1	 subss	 xmm0, xmm1
  00056	0f 2f c2	 comiss	 xmm0, xmm2
  00059	f3 0f 11 45 08	 movss	 DWORD PTR tv130[ebp], xmm0
  0005e	76 0b		 jbe	 SHORT $LN1@GetDegreeD

; 357  : 		{
; 358  : 			return (360.0f - (fSource - fTarget));

  00060	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@43b40000
  00066	d8 65 08	 fsub	 DWORD PTR tv130[ebp]

; 362  : 	}
; 363  : }

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$LN1@GetDegreeD:

; 359  : 		}
; 360  : 
; 361  : 		return fSource - fTarget;

  0006b	d9 45 08	 fld	 DWORD PTR tv130[ebp]

; 362  : 	}
; 363  : }

  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?GetDegreeDifference@@YAMMM@Z ENDP			; GetDegreeDifference
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
;	COMDAT ?IsCCWAcuteAngle@@YA_NMM@Z
_TEXT	SEGMENT
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
?IsCCWAcuteAngle@@YA_NMM@Z PROC				; IsCCWAcuteAngle, COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 283  : 	// abs(360 - dest + src) 	// 시계 방향
; 284  : 	// dest - src				// 시계 반대 방향
; 285  : 	int fValue = abs((int) (360.0f - end + begin));

  00003	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43b40000
  0000b	f3 0f 10 55 0c	 movss	 xmm2, DWORD PTR _end$[ebp]
  00010	f3 0f 5c c2	 subss	 xmm0, xmm2

; 286  : 	return fValue >= (end - begin) ? true : false;

  00014	f3 0f 5c 55 08	 subss	 xmm2, DWORD PTR _begin$[ebp]
  00019	f3 0f 58 45 08	 addss	 xmm0, DWORD PTR _begin$[ebp]
  0001e	f3 0f 2c c0	 cvttss2si eax, xmm0
  00022	99		 cdq
  00023	33 c2		 xor	 eax, edx
  00025	2b c2		 sub	 eax, edx
  00027	66 0f 6e c0	 movd	 xmm0, eax
  0002b	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0002e	0f 2f c2	 comiss	 xmm0, xmm2
  00031	0f 93 c0	 setae	 al

; 287  : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?IsCCWAcuteAngle@@YA_NMM@Z ENDP				; IsCCWAcuteAngle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
;	COMDAT ?IsCWAcuteAngle@@YA_NMM@Z
_TEXT	SEGMENT
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
?IsCWAcuteAngle@@YA_NMM@Z PROC				; IsCWAcuteAngle, COMDAT

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 276  : 	// 360 - src + dest		// 시계 반대 방향
; 277  : 	// src - dest			// 시계 방향
; 278  : 	return ((360.0f - begin + end) > (begin - end));

  00003	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _begin$[ebp]
  00008	33 c0		 xor	 eax, eax
  0000a	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@43b40000
  00012	f3 0f 5c d1	 subss	 xmm2, xmm1
  00016	f3 0f 5c 4d 0c	 subss	 xmm1, DWORD PTR _end$[ebp]
  0001b	f3 0f 58 55 0c	 addss	 xmm2, DWORD PTR _end$[ebp]
  00020	0f 2f d1	 comiss	 xmm2, xmm1
  00023	0f 97 c0	 seta	 al

; 279  : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?IsCWAcuteAngle@@YA_NMM@Z ENDP				; IsCWAcuteAngle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
;	COMDAT ?IsCCWRotation@@YA_NMM@Z
_TEXT	SEGMENT
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
?IsCCWRotation@@YA_NMM@Z PROC				; IsCCWRotation, COMDAT

; 295  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 296  : 	//     180
; 297  : 	// 270      90
; 298  : 	//      0
; 299  : 	//
; 300  : 	// 시계 반대
; 301  : 	return (begin - end < 0);

  00003	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _begin$[ebp]
  00008	0f 57 c0	 xorps	 xmm0, xmm0
  0000b	f3 0f 5c 4d 0c	 subss	 xmm1, DWORD PTR _end$[ebp]
  00010	33 c0		 xor	 eax, eax
  00012	0f 2f c1	 comiss	 xmm0, xmm1
  00015	0f 97 c0	 seta	 al

; 302  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?IsCCWRotation@@YA_NMM@Z ENDP				; IsCCWRotation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
;	COMDAT ?IsCWRotation@@YA_NMM@Z
_TEXT	SEGMENT
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
?IsCWRotation@@YA_NMM@Z PROC				; IsCWRotation, COMDAT

; 290  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 291  : 	return !IsCCWRotation(begin, end);

  00003	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _end$[ebp]
  00008	83 ec 08	 sub	 esp, 8
  0000b	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00011	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _begin$[ebp]
  00016	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001b	e8 00 00 00 00	 call	 ?IsCCWRotation@@YA_NMM@Z ; IsCCWRotation
  00020	33 c9		 xor	 ecx, ecx
  00022	83 c4 08	 add	 esp, 8
  00025	84 c0		 test	 al, al
  00027	0f 94 c1	 sete	 cl
  0002a	8a c1		 mov	 al, cl

; 292  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?IsCWRotation@@YA_NMM@Z ENDP				; IsCWRotation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
;	COMDAT ?GetInterpolatedRotation@@YAMMMM@Z
_TEXT	SEGMENT
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
_curRate$ = 16						; size = 4
?GetInterpolatedRotation@@YAMMMM@Z PROC			; GetInterpolatedRotation, COMDAT

; 305  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 306  : 	if (IsCCWRotation(begin, end))

  00003	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _end$[ebp]
  00008	83 ec 08	 sub	 esp, 8
  0000b	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00011	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _begin$[ebp]
  00016	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001b	e8 00 00 00 00	 call	 ?IsCCWRotation@@YA_NMM@Z ; IsCCWRotation

; 307  : 	{
; 308  : 		if (IsCCWAcuteAngle(begin, end))

  00020	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _end$[ebp]
  00025	83 c4 08	 add	 esp, 8
  00028	83 ec 08	 sub	 esp, 8
  0002b	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00031	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _begin$[ebp]
  00036	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003b	84 c0		 test	 al, al
  0003d	74 47		 je	 SHORT $LN3@GetInterpo
  0003f	e8 00 00 00 00	 call	 ?IsCCWAcuteAngle@@YA_NMM@Z ; IsCCWAcuteAngle

; 309  : 			return GetLinearInterpolation(begin, end, curRate);

  00044	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _curRate$[ebp]
  00049	83 c4 08	 add	 esp, 8
  0004c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0004f	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00055	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _end$[ebp]
  0005a	84 c0		 test	 al, al
  0005c	75 4f		 jne	 SHORT $LN6@GetInterpo

; 310  : 
; 311  : 		return (360.0f + GetLinearInterpolation(begin, end - 360.0f, curRate));

  0005e	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@43b40000
  00066	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0006c	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _begin$[ebp]
  00071	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00076	e8 00 00 00 00	 call	 ?GetLinearInterpolation@@YAMMMM@Z ; GetLinearInterpolation
  0007b	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@43b40000

; 316  : 
; 317  : 	return GetLinearInterpolation(begin, end + 360.0f, curRate);								

  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 318  : }

  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
$LN3@GetInterpo:

; 312  : 	}
; 313  : 
; 314  : 	if (IsCWAcuteAngle(begin, end))

  00086	e8 00 00 00 00	 call	 ?IsCWAcuteAngle@@YA_NMM@Z ; IsCWAcuteAngle

; 315  : 		return GetLinearInterpolation(begin, end, curRate);

  0008b	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _curRate$[ebp]
  00090	83 c4 08	 add	 esp, 8
  00093	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00096	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0009c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _end$[ebp]
  000a1	84 c0		 test	 al, al
  000a3	75 08		 jne	 SHORT $LN6@GetInterpo

; 316  : 
; 317  : 	return GetLinearInterpolation(begin, end + 360.0f, curRate);								

  000a5	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@43b40000
$LN6@GetInterpo:
  000ad	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000b3	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _begin$[ebp]
  000b8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bd	e8 00 00 00 00	 call	 ?GetLinearInterpolation@@YAMMMM@Z ; GetLinearInterpolation
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 318  : }

  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
?GetInterpolatedRotation@@YAMMMM@Z ENDP			; GetInterpolatedRotation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
;	COMDAT ?GetDegreeFromPosition2@@YAMMMMM@Z
_TEXT	SEGMENT
_sx$ = 8						; size = 4
_sy$ = 12						; size = 4
_ex$ = 16						; size = 4
_ey$ = 20						; size = 4
?GetDegreeFromPosition2@@YAMMMMM@Z PROC			; GetDegreeFromPosition2, COMDAT

; 335  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 336  : 	return GetDegreeFromPosition(ex - sx, ey - sy);

  00003	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _ey$[ebp]
  00008	83 ec 08	 sub	 esp, 8
  0000b	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _sy$[ebp]
  00010	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00016	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _ex$[ebp]
  0001b	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _sx$[ebp]
  00020	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00025	e8 00 00 00 00	 call	 ?GetDegreeFromPosition@@YAMMM@Z ; GetDegreeFromPosition
  0002a	83 c4 08	 add	 esp, 8

; 337  : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?GetDegreeFromPosition2@@YAMMMMM@Z ENDP			; GetDegreeFromPosition2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
;	COMDAT ?GetDegreeFromPosition@@YAMMM@Z
_TEXT	SEGMENT
tv267 = -24						; size = 8
tv261 = -24						; size = 8
tv258 = -24						; size = 8
tv252 = -24						; size = 8
_ret$ = -20						; size = 4
_vtDir$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetDegreeFromPosition@@YAMMM@Z PROC			; GetDegreeFromPosition, COMDAT

; 321  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
; File a:\vs\vc\include\math.h

; 701  :     return (float)floor(_X);

  00015	83 ec 08	 sub	 esp, 8
  00018	0f 5a c0	 cvtps2pd xmm0, xmm0
  0001b	f2 0f 11 45 e8	 movsd	 QWORD PTR tv267[ebp], xmm0
  00020	dd 45 e8	 fld	 QWORD PTR tv267[ebp]
  00023	dd 1c 24	 fstp	 QWORD PTR [esp]
  00026	e8 00 00 00 00	 call	 _floor
  0002b	dd 5d e8	 fstp	 QWORD PTR tv261[ebp]
  0002e	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR tv261[ebp]
  00033	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00037	f3 0f 11 45 f0	 movss	 DWORD PTR _vtDir$[ebp], xmm0
  0003c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
; File a:\vs\vc\include\math.h

; 701  :     return (float)floor(_X);

  00041	0f 5a c0	 cvtps2pd xmm0, xmm0
  00044	f2 0f 11 45 e8	 movsd	 QWORD PTR tv258[ebp], xmm0
  00049	dd 45 e8	 fld	 QWORD PTR tv258[ebp]
  0004c	dd 1c 24	 fstp	 QWORD PTR [esp]
  0004f	e8 00 00 00 00	 call	 _floor
  00054	dd 5d e8	 fstp	 QWORD PTR tv252[ebp]
  00057	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR tv252[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 323  : 	D3DXVec3Normalize(&vtDir, &vtDir);

  0005c	8d 45 f0	 lea	 eax, DWORD PTR _vtDir$[ebp]
; File a:\vs\vc\include\math.h

; 701  :     return (float)floor(_X);

  0005f	83 c4 08	 add	 esp, 8
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00062	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _vtDir$[ebp+8], 0
; File a:\vs\vc\include\math.h

; 701  :     return (float)floor(_X);

  00069	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 323  : 	D3DXVec3Normalize(&vtDir, &vtDir);

  0006d	50		 push	 eax
  0006e	50		 push	 eax
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 181  :     y = fy;

  0006f	f3 0f 11 45 f4	 movss	 DWORD PTR _vtDir$[ebp+4], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 323  : 	D3DXVec3Normalize(&vtDir, &vtDir);

  00074	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00079	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _vtDir$[ebp]
  0007e	0f 57 d2	 xorps	 xmm2, xmm2
  00081	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _vtDir$[ebp+4]
  00086	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f800000
  0008e	f3 0f 59 ca	 mulss	 xmm1, xmm2
  00092	f3 0f 5c c8	 subss	 xmm1, xmm0
  00096	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _vtDir$[ebp+8]
  0009b	f3 0f 59 c2	 mulss	 xmm0, xmm2
  0009f	f3 0f 58 c8	 addss	 xmm1, xmm0
; File a:\vs\vc\include\math.h

; 639  :     return (float)acos(_X);

  000a3	0f 5a c1	 cvtps2pd xmm0, xmm1
  000a6	e8 00 00 00 00	 call	 __libm_sse2_acos_precise
  000ab	0f 57 c9	 xorps	 xmm1, xmm1
  000ae	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0
  000b2	0f 57 c0	 xorps	 xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 328  : 	if (vtDir.x < 0.0f)

  000b5	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _vtDir$[ebp]
  000b9	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@42652ee0
  000c1	f3 0f 11 4d ec	 movss	 DWORD PTR _ret$[ebp], xmm1
  000c6	76 11		 jbe	 SHORT $LN20@GetDegreeF

; 329  : 		ret = 360.0f - ret;

  000c8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43b40000
  000d0	f3 0f 5c c1	 subss	 xmm0, xmm1
  000d4	f3 0f 11 45 ec	 movss	 DWORD PTR _ret$[ebp], xmm0
$LN20@GetDegreeF:

; 330  : 
; 331  : 	return ret;
; 332  : }

  000d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dc	d9 45 ec	 fld	 DWORD PTR _ret$[ebp]
  000df	33 cd		 xor	 ecx, ebp
  000e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
?GetDegreeFromPosition@@YAMMM@Z ENDP			; GetDegreeFromPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
;	COMDAT ?DetectCollisionDynamicZCylinderVSDynamicZCylinder@@YA_NABUCDynamicSphereInstance@@0@Z
_TEXT	SEGMENT
_mi1$ = -140						; size = 12
_mi4$ = -128						; size = 12
_rsq$1$ = -116						; size = 4
_mi1$4$ = -112						; size = 4
_mi1$6$ = -108						; size = 4
_mi2$4$ = -104						; size = 4
_mi4$2$ = -100						; size = 4
_mi3$2$ = -96						; size = 4
_mi1$2$ = -92						; size = 4
_mi2$2$ = -88						; size = 4
_c_rCylinder2$ = -84					; size = 28
_c_rCylinder1$ = -56					; size = 28
_vA$ = -28						; size = 12
_mi3$ = -28						; size = 12
_vB$ = -16						; size = 12
_mi2$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_c_rSphere1$ = 8					; size = 4
_c_rSphere2$ = 12					; size = 4
?DetectCollisionDynamicZCylinderVSDynamicZCylinder@@YA_NABUCDynamicSphereInstance@@0@Z PROC ; DetectCollisionDynamicZCylinderVSDynamicZCylinder, COMDAT

; 7    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _c_rSphere1$[ebp]
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _c_rSphere2$[ebp]

; 8    : 	CDynamicSphereInstance c_rCylinder1=c_rSphere1;

  00019	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  0001d	f3 0f 7f 45 c8	 movdqu	 XMMWORD PTR _c_rCylinder1$[ebp], xmm0

; 9    : 	CDynamicSphereInstance c_rCylinder2=c_rSphere2;
; 10   : 
; 11   : 	c_rCylinder1.v3Position.z=0;

  00022	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _c_rCylinder1$[ebp+8], 0
  00029	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0002e	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00031	66 0f d6 45 d8	 movq	 QWORD PTR _c_rCylinder1$[ebp+16], xmm0
  00036	f3 0f 6f 01	 movdqu	 xmm0, XMMWORD PTR [ecx]
  0003a	89 45 e0	 mov	 DWORD PTR _c_rCylinder1$[ebp+24], eax
  0003d	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00040	f3 0f 7f 45 ac	 movdqu	 XMMWORD PTR _c_rCylinder2$[ebp], xmm0
  00045	89 45 c4	 mov	 DWORD PTR _c_rCylinder2$[ebp+24], eax
  00048	f3 0f 7e 41 10	 movq	 xmm0, QWORD PTR [ecx+16]
  0004d	66 0f d6 45 bc	 movq	 QWORD PTR _c_rCylinder2$[ebp+16], xmm0

; 12   : 	c_rCylinder1.v3LastPosition.z=0;
; 13   : 
; 14   : 	c_rCylinder2.v3Position.z=0;
; 15   : 	c_rCylinder2.v3LastPosition.z=0;
; 16   : 
; 17   : 	float r = c_rCylinder1.fRadius+c_rCylinder2.fRadius;

  00052	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _c_rCylinder2$[ebp+24]
  00057	f3 0f 58 45 e0	 addss	 xmm0, DWORD PTR _c_rCylinder1$[ebp+24]

; 18   : 	float rsq = r*r;
; 19   : 
; 20   : 	// AABB check
; 21   : 	D3DXVECTOR3 mi1=c_rCylinder1.v3LastPosition, mi2 = c_rCylinder1.v3Position;
; 22   : 	D3DXVECTOR3 mi3=c_rCylinder2.v3LastPosition, mi4 = c_rCylinder2.v3Position;
; 23   : 	if (mi1.x>mi2.x) std::swap(mi1.x,mi2.x);

  0005c	f3 0f 10 5d c8	 movss	 xmm3, DWORD PTR _c_rCylinder1$[ebp]
  00061	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _c_rCylinder1$[ebp+20], 0
  00068	8b 45 dc	 mov	 eax, DWORD PTR _c_rCylinder1$[ebp+20]
  0006b	89 85 7c ff ff
	ff		 mov	 DWORD PTR _mi1$[ebp+8], eax
  00071	8b 45 d0	 mov	 eax, DWORD PTR _c_rCylinder1$[ebp+8]
  00074	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00078	89 45 f8	 mov	 DWORD PTR _mi2$[ebp+8], eax
  0007b	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _c_rCylinder2$[ebp+20], 0
  00082	8b 45 c0	 mov	 eax, DWORD PTR _c_rCylinder2$[ebp+20]
  00085	f3 0f 11 45 8c	 movss	 DWORD PTR _rsq$1$[ebp], xmm0
  0008a	f3 0f 7e 45 d4	 movq	 xmm0, QWORD PTR _c_rCylinder1$[ebp+12]
  0008f	66 0f d6 85 74
	ff ff ff	 movq	 QWORD PTR _mi1$[ebp], xmm0
  00097	f3 0f 7e 45 c8	 movq	 xmm0, QWORD PTR _c_rCylinder1$[ebp]
  0009c	66 0f d6 45 f0	 movq	 QWORD PTR _mi2$[ebp], xmm0
  000a1	f3 0f 7e 45 b8	 movq	 xmm0, QWORD PTR _c_rCylinder2$[ebp+12]
  000a6	66 0f d6 45 e4	 movq	 QWORD PTR _mi3$[ebp], xmm0
  000ab	f3 0f 7e 45 ac	 movq	 xmm0, QWORD PTR _c_rCylinder2$[ebp]
  000b0	66 0f d6 45 80	 movq	 QWORD PTR _mi4$[ebp], xmm0
  000b5	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _c_rCylinder1$[ebp+12]
  000ba	0f 2f c3	 comiss	 xmm0, xmm3
  000bd	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _c_rCylinder2$[ebp+8], 0
  000c4	89 45 ec	 mov	 DWORD PTR _mi3$[ebp+8], eax
  000c7	8b 45 b4	 mov	 eax, DWORD PTR _c_rCylinder2$[ebp+8]
  000ca	89 45 88	 mov	 DWORD PTR _mi4$[ebp+8], eax
  000cd	f3 0f 11 45 a8	 movss	 DWORD PTR _mi2$2$[ebp], xmm0
  000d2	f3 0f 11 5d a4	 movss	 DWORD PTR _mi1$2$[ebp], xmm3
  000d7	77 17		 ja	 SHORT $LN15@DetectColl
; File a:\vs\vc\include\utility

; 54   : 	_Right = _Move(_Tmp);

  000d9	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _mi1$[ebp]
  000e1	f3 0f 11 45 a4	 movss	 DWORD PTR _mi1$2$[ebp], xmm0
  000e6	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _mi2$[ebp]
  000eb	f3 0f 11 45 a8	 movss	 DWORD PTR _mi2$2$[ebp], xmm0
$LN15@DetectColl:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 24   : 	if (mi1.y>mi2.y) std::swap(mi1.y,mi2.y);

  000f0	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _mi2$[ebp+4]
  000f5	f3 0f 10 8d 78
	ff ff ff	 movss	 xmm1, DWORD PTR _mi1$[ebp+4]
  000fd	0f 2f ca	 comiss	 xmm1, xmm2
  00100	f3 0f 11 55 98	 movss	 DWORD PTR _mi2$4$[ebp], xmm2
  00105	76 0e		 jbe	 SHORT $LN23@DetectColl
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00107	0f 28 c1	 movaps	 xmm0, xmm1

; 53   : 	_Left = _Move(_Right);

  0010a	0f 28 ca	 movaps	 xmm1, xmm2

; 54   : 	_Right = _Move(_Tmp);

  0010d	0f 28 d0	 movaps	 xmm2, xmm0
  00110	f3 0f 11 55 98	 movss	 DWORD PTR _mi2$4$[ebp], xmm2
$LN23@DetectColl:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 25   : 	if (mi1.z>mi2.z) std::swap(mi1.z,mi2.z);

  00115	f3 0f 10 9d 7c
	ff ff ff	 movss	 xmm3, DWORD PTR _mi1$[ebp+8]
  0011d	f3 0f 10 65 f8	 movss	 xmm4, DWORD PTR _mi2$[ebp+8]
  00122	0f 2f dc	 comiss	 xmm3, xmm4
  00125	76 09		 jbe	 SHORT $LN31@DetectColl
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00127	0f 28 c3	 movaps	 xmm0, xmm3

; 53   : 	_Left = _Move(_Right);

  0012a	0f 28 dc	 movaps	 xmm3, xmm4

; 54   : 	_Right = _Move(_Tmp);

  0012d	0f 28 e0	 movaps	 xmm4, xmm0
$LN31@DetectColl:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 26   : 	if (mi3.x>mi4.x) std::swap(mi3.x,mi4.x);

  00130	f3 0f 10 75 b8	 movss	 xmm6, DWORD PTR _c_rCylinder2$[ebp+12]
  00135	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _c_rCylinder2$[ebp]
  0013a	0f 2f f0	 comiss	 xmm6, xmm0
  0013d	f3 0f 11 75 9c	 movss	 DWORD PTR _mi4$2$[ebp], xmm6
  00142	f3 0f 11 45 a0	 movss	 DWORD PTR _mi3$2$[ebp], xmm0
  00147	77 14		 ja	 SHORT $LN39@DetectColl
; File a:\vs\vc\include\utility

; 54   : 	_Right = _Move(_Tmp);

  00149	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _mi3$[ebp]
  0014e	f3 0f 11 45 a0	 movss	 DWORD PTR _mi3$2$[ebp], xmm0
  00153	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _mi4$[ebp]
  00158	f3 0f 11 45 9c	 movss	 DWORD PTR _mi4$2$[ebp], xmm0
$LN39@DetectColl:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 27   : 	if (mi3.y>mi4.y) std::swap(mi3.y,mi4.y);

  0015d	f3 0f 10 6d e8	 movss	 xmm5, DWORD PTR _mi3$[ebp+4]
  00162	f3 0f 10 7d 84	 movss	 xmm7, DWORD PTR _mi4$[ebp+4]
  00167	0f 2f ef	 comiss	 xmm5, xmm7
  0016a	76 09		 jbe	 SHORT $LN47@DetectColl
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  0016c	0f 28 c5	 movaps	 xmm0, xmm5

; 53   : 	_Left = _Move(_Right);

  0016f	0f 28 ef	 movaps	 xmm5, xmm7

; 54   : 	_Right = _Move(_Tmp);

  00172	0f 28 f8	 movaps	 xmm7, xmm0
$LN47@DetectColl:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 28   : 	if (mi3.z>mi4.z) std::swap(mi3.z,mi4.z);

  00175	f3 0f 10 75 ec	 movss	 xmm6, DWORD PTR _mi3$[ebp+8]
  0017a	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _mi4$[ebp+8]
  0017f	0f 2f f0	 comiss	 xmm6, xmm0
  00182	76 08		 jbe	 SHORT $LN55@DetectColl
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00184	0f 28 c6	 movaps	 xmm0, xmm6

; 53   : 	_Left = _Move(_Right);

  00187	f3 0f 10 75 88	 movss	 xmm6, DWORD PTR _mi4$[ebp+8]
$LN55@DetectColl:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 29   : 	mi1.x -= c_rCylinder1.fRadius; mi1.y -= c_rCylinder1.fRadius; mi1.z -= c_rCylinder1.fRadius;

  0018c	f3 0f 5c 4d e0	 subss	 xmm1, DWORD PTR _c_rCylinder1$[ebp+24]
  00191	f3 0f 10 55 a4	 movss	 xmm2, DWORD PTR _mi1$2$[ebp]
  00196	f3 0f 5c 55 e0	 subss	 xmm2, DWORD PTR _c_rCylinder1$[ebp+24]
  0019b	f3 0f 11 4d 90	 movss	 DWORD PTR _mi1$4$[ebp], xmm1
  001a0	f3 0f 10 4d e0	 movss	 xmm1, DWORD PTR _c_rCylinder1$[ebp+24]
  001a5	f3 0f 5c d9	 subss	 xmm3, xmm1
  001a9	f3 0f 11 55 a4	 movss	 DWORD PTR _mi1$2$[ebp], xmm2

; 30   : 	mi2.x += c_rCylinder1.fRadius; mi2.y += c_rCylinder1.fRadius; mi2.z += c_rCylinder1.fRadius;

  001ae	f3 0f 10 55 98	 movss	 xmm2, DWORD PTR _mi2$4$[ebp]
  001b3	f3 0f 58 e1	 addss	 xmm4, xmm1
  001b7	f3 0f 58 d1	 addss	 xmm2, xmm1
  001bb	f3 0f 11 5d 94	 movss	 DWORD PTR _mi1$6$[ebp], xmm3
  001c0	f3 0f 10 5d a8	 movss	 xmm3, DWORD PTR _mi2$2$[ebp]
  001c5	f3 0f 58 d9	 addss	 xmm3, xmm1

; 31   : 	mi3.x -= c_rCylinder2.fRadius; mi3.y -= c_rCylinder2.fRadius; mi3.z -= c_rCylinder2.fRadius;

  001c9	f3 0f 10 4d c4	 movss	 xmm1, DWORD PTR _c_rCylinder2$[ebp+24]
  001ce	f3 0f 5c e9	 subss	 xmm5, xmm1
  001d2	f3 0f 5c f1	 subss	 xmm6, xmm1

; 32   : 	mi4.x += c_rCylinder2.fRadius; mi4.y += c_rCylinder2.fRadius; mi4.z += c_rCylinder2.fRadius;

  001d6	f3 0f 58 f9	 addss	 xmm7, xmm1
  001da	f3 0f 58 c1	 addss	 xmm0, xmm1
  001de	f3 0f 11 5d a8	 movss	 DWORD PTR _mi2$2$[ebp], xmm3
  001e3	f3 0f 10 5d a0	 movss	 xmm3, DWORD PTR _mi3$2$[ebp]
  001e8	f3 0f 5c d9	 subss	 xmm3, xmm1
  001ec	f3 0f 11 5d a0	 movss	 DWORD PTR _mi3$2$[ebp], xmm3
  001f1	f3 0f 10 5d 9c	 movss	 xmm3, DWORD PTR _mi4$2$[ebp]
  001f6	f3 0f 58 d9	 addss	 xmm3, xmm1

; 33   : 	if (mi4.x<mi1.x || mi2.x<mi3.x) return false;

  001fa	f3 0f 10 4d a4	 movss	 xmm1, DWORD PTR _mi1$2$[ebp]
  001ff	0f 2f cb	 comiss	 xmm1, xmm3
  00202	f3 0f 10 4d 90	 movss	 xmm1, DWORD PTR _mi1$4$[ebp]
  00207	0f 87 95 00 00
	00		 ja	 $LN5@DetectColl
  0020d	f3 0f 10 5d a0	 movss	 xmm3, DWORD PTR _mi3$2$[ebp]
  00212	0f 2f 5d a8	 comiss	 xmm3, DWORD PTR _mi2$2$[ebp]
  00216	f3 0f 10 5d 94	 movss	 xmm3, DWORD PTR _mi1$6$[ebp]
  0021b	0f 87 81 00 00
	00		 ja	 $LN5@DetectColl

; 34   : 	if (mi4.y<mi1.y || mi2.y<mi3.y) return false;

  00221	0f 2f cf	 comiss	 xmm1, xmm7
  00224	77 7c		 ja	 SHORT $LN5@DetectColl
  00226	0f 2f ea	 comiss	 xmm5, xmm2
  00229	77 77		 ja	 SHORT $LN5@DetectColl

; 35   : 	if (mi4.z<mi1.z || mi2.z<mi3.z) return false;

  0022b	0f 2f d8	 comiss	 xmm3, xmm0
  0022e	77 72		 ja	 SHORT $LN5@DetectColl
  00230	0f 2f f4	 comiss	 xmm6, xmm4
  00233	77 6d		 ja	 SHORT $LN5@DetectColl

; 40   : 		vA, vB);

  00235	8d 45 f0	 lea	 eax, DWORD PTR _vB$[ebp]
  00238	50		 push	 eax
  00239	8d 45 e4	 lea	 eax, DWORD PTR _vA$[ebp]
  0023c	50		 push	 eax
  0023d	8d 45 ac	 lea	 eax, DWORD PTR _c_rCylinder2$[ebp]
  00240	50		 push	 eax
  00241	8d 45 b8	 lea	 eax, DWORD PTR _c_rCylinder2$[ebp+12]
  00244	50		 push	 eax
  00245	8d 45 c8	 lea	 eax, DWORD PTR _c_rCylinder1$[ebp]
  00248	50		 push	 eax
  00249	8d 45 d4	 lea	 eax, DWORD PTR _c_rCylinder1$[ebp+12]
  0024c	50		 push	 eax
  0024d	e8 00 00 00 00	 call	 ?IntersectLineSegments@@YAXABUD3DXVECTOR3@@000AAU1@1@Z ; IntersectLineSegments
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00252	f3 0f 10 4d e4	 movss	 xmm1, DWORD PTR _vA$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 41   : 	return (D3DXVec3LengthSq(&(vA-vB))<=rsq);

  00257	33 c0		 xor	 eax, eax
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00259	f3 0f 10 55 e8	 movss	 xmm2, DWORD PTR _vA$[ebp+4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 40   : 		vA, vB);

  0025e	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00261	f3 0f 5c 55 f4	 subss	 xmm2, DWORD PTR _vB$[ebp+4]
  00266	f3 0f 5c 4d f0	 subss	 xmm1, DWORD PTR _vB$[ebp]
  0026b	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _vA$[ebp+8]
  00270	f3 0f 5c 45 f8	 subss	 xmm0, DWORD PTR _vB$[ebp+8]

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00275	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00279	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0027d	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00281	f3 0f 58 d1	 addss	 xmm2, xmm1
  00285	f3 0f 58 d0	 addss	 xmm2, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 41   : 	return (D3DXVec3LengthSq(&(vA-vB))<=rsq);

  00289	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _rsq$1$[ebp]
  0028e	0f 2f c2	 comiss	 xmm0, xmm2
  00291	0f 93 c0	 setae	 al

; 42   : }

  00294	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00297	33 cd		 xor	 ecx, ebp
  00299	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0029e	8b e5		 mov	 esp, ebp
  002a0	5d		 pop	 ebp
  002a1	c3		 ret	 0
$LN5@DetectColl:
  002a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a5	32 c0		 xor	 al, al
  002a7	33 cd		 xor	 ecx, ebp
  002a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ae	8b e5		 mov	 esp, ebp
  002b0	5d		 pop	 ebp
  002b1	c3		 ret	 0
?DetectCollisionDynamicZCylinderVSDynamicZCylinder@@YA_NABUCDynamicSphereInstance@@0@Z ENDP ; DetectCollisionDynamicZCylinderVSDynamicZCylinder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp
;	COMDAT ?DetectCollisionDynamicSphereVSDynamicSphere@@YA_NABUCDynamicSphereInstance@@0@Z
_TEXT	SEGMENT
_mi1$ = -88						; size = 12
_mi2$6$ = -76						; size = 4
_rsq$1$ = -72						; size = 4
_mi1$6$ = -68						; size = 4
_mi2$4$ = -64						; size = 4
_mi4$ = -60						; size = 12
_mi4$5$ = -48						; size = 4
_mi4$1$ = -44						; size = 4
_mi2$2$ = -40						; size = 4
_mi2$1$ = -40						; size = 4
_mi1$2$ = -36						; size = 4
_mi4$4$ = -32						; size = 4
_mi4$3$ = -32						; size = 4
_vA$ = -28						; size = 12
_mi3$ = -28						; size = 12
_vB$ = -16						; size = 12
_mi2$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_c_rSphere1$ = 8					; size = 4
_c_rSphere2$ = 12					; size = 4
?DetectCollisionDynamicSphereVSDynamicSphere@@YA_NABUCDynamicSphereInstance@@0@Z PROC ; DetectCollisionDynamicSphereVSDynamicSphere, COMDAT

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _c_rSphere1$[ebp]
  00013	8b 55 0c	 mov	 edx, DWORD PTR _c_rSphere2$[ebp]

; 46   : 	float r = c_rSphere1.fRadius+c_rSphere2.fRadius;
; 47   : 	float rsq = r*r;
; 48   : 
; 49   : 	/*if (D3DXVec3LengthSq(&(c_rSphere1.v3Position		-c_rSphere2.v3Position		))<=rsq) return true;
; 50   : 	if (D3DXVec3LengthSq(&(c_rSphere1.v3Position		-c_rSphere2.v3LastPosition	))<=rsq) return true;
; 51   : 	if (D3DXVec3LengthSq(&(c_rSphere1.v3LastPosition	-c_rSphere2.v3Position		))<=rsq) return true;
; 52   : 	if (D3DXVec3LengthSq(&(c_rSphere1.v3LastPosition	-c_rSphere2.v3LastPosition	))<=rsq) return true;*/
; 53   : 
; 54   : 	/*
; 55   : 	if (square_distance_between_linesegment_and_point(
; 56   : 		c_rSphere1.v3Position,
; 57   : 		c_rSphere1.v3LastPosition,
; 58   : 		c_rSphere2.v3Position
; 59   : 		)<=rsq) return true;
; 60   : 	if (square_distance_between_linesegment_and_point(
; 61   : 		c_rSphere1.v3Position,
; 62   : 		c_rSphere1.v3LastPosition,
; 63   : 		c_rSphere2.v3LastPosition
; 64   : 		)<=rsq) return true;
; 65   : 	if (square_distance_between_linesegment_and_point(
; 66   : 		c_rSphere2.v3Position,
; 67   : 		c_rSphere2.v3LastPosition,
; 68   : 		c_rSphere1.v3Position
; 69   : 		)<=rsq) return true;
; 70   : 	if (square_distance_between_linesegment_and_point(
; 71   : 		c_rSphere2.v3Position,
; 72   : 		c_rSphere2.v3LastPosition,
; 73   : 		c_rSphere1.v3LastPosition
; 74   : 		)<=rsq) return true;
; 75   : 
; 76   : 	D3DXVECTOR3 da=c_rSphere1.v3Position-c_rSphere1.v3LastPosition;
; 77   : 	D3DXVECTOR3 db=c_rSphere2.v3Position-c_rSphere2.v3LastPosition;
; 78   : 	D3DXVECTOR3 n;
; 79   : 	float la = D3DXVec3Length(&da);
; 80   : 	float lb = D3DXVec3Length(&db);
; 81   : 	if (la==0||lb==0)
; 82   : 	{
; 83   : 		D3DXVECTOR3 vA, vB;
; 84   : 		IntersectLineSegments(
; 85   : 			c_rSphere1.v3LastPosition.x,c_rSphere1.v3LastPosition.y,c_rSphere1.v3LastPosition.z,
; 86   : 			c_rSphere1.v3Position.x,	c_rSphere1.v3Position.y,	c_rSphere1.v3Position.z,
; 87   : 			c_rSphere2.v3LastPosition.x,c_rSphere2.v3LastPosition.y,c_rSphere2.v3LastPosition.z,
; 88   : 			c_rSphere2.v3Position.x,	c_rSphere2.v3Position.y,	c_rSphere2.v3Position.z,
; 89   : 			false, 1.e-5f, vA.x, vA.y, vA.z, vB.x, vB.y, vB.z);
; 90   : 		return (D3DXVec3LengthSq(&(vA-vB))<=r*r);
; 91   : 	}
; 92   : 	D3DXVECTOR3 p=c_rSphere2.v3Position - c_rSphere1.v3LastPosition;
; 93   : 	D3DXVec3Cross(&n, &da, &db);
; 94   : 	float from_plane = D3DXVec3Dot(&n,&p)/la/lb;
; 95   : 	if (from_plane>r || from_plane<-r)
; 96   : 		return false;
; 97   : 	p-=(from_plane/la/lb)*n;
; 98   : 	float ta = D3DXVec3Dot(&p,&da)/la/la;
; 99   : 	float tb = D3DXVec3Dot(&p,&db)/lb/lb;
; 100  : 
; 101  : 	// FIXME 구 체크가 아니다
; 102  : 
; 103  : 	if (ta<0)
; 104  : 		return false;
; 105  : 	if (tb<0)
; 106  : 		return false;
; 107  : 	if (ta>1)
; 108  : 		return false;
; 109  : 	if (tb>1)
; 110  : 		return false;
; 111  : 	return true;
; 112  : 
; 113  :   */
; 114  : 	//*/
; 115  : 	// using gpg line-collision
; 116  : 
; 117  : 	// AABB check
; 118  : 
; 119  : 	D3DXVECTOR3 mi1=c_rSphere1.v3LastPosition, mi2 = c_rSphere1.v3Position;

  00016	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00019	56		 push	 esi
  0001a	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
  0001f	8d 71 0c	 lea	 esi, DWORD PTR [ecx+12]
  00022	f3 0f 58 42 18	 addss	 xmm0, DWORD PTR [edx+24]
  00027	57		 push	 edi
  00028	89 45 b0	 mov	 DWORD PTR _mi1$[ebp+8], eax

; 120  : 	D3DXVECTOR3 mi3=c_rSphere2.v3LastPosition, mi4 = c_rSphere2.v3Position;

  0002b	8d 7a 0c	 lea	 edi, DWORD PTR [edx+12]
  0002e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00031	89 45 f8	 mov	 DWORD PTR _mi2$[ebp+8], eax
  00034	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00037	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0003b	89 45 ec	 mov	 DWORD PTR _mi3$[ebp+8], eax
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	89 45 cc	 mov	 DWORD PTR _mi4$[ebp+8], eax
  00044	f3 0f 11 45 b8	 movss	 DWORD PTR _rsq$1$[ebp], xmm0
  00049	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]
  0004d	66 0f d6 45 a8	 movq	 QWORD PTR _mi1$[ebp], xmm0
  00052	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]

; 121  : 	if (mi1.x>mi2.x) std::swap(mi1.x,mi2.x);

  00056	f3 0f 10 4d a8	 movss	 xmm1, DWORD PTR _mi1$[ebp]
  0005b	66 0f d6 45 f0	 movq	 QWORD PTR _mi2$[ebp], xmm0
  00060	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  00064	f3 0f 10 55 f0	 movss	 xmm2, DWORD PTR _mi2$[ebp]
  00069	0f 2f ca	 comiss	 xmm1, xmm2
  0006c	66 0f d6 45 e4	 movq	 QWORD PTR _mi3$[ebp], xmm0
  00071	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  00075	66 0f d6 45 c4	 movq	 QWORD PTR _mi4$[ebp], xmm0
  0007a	f3 0f 11 4d dc	 movss	 DWORD PTR _mi1$2$[ebp], xmm1
  0007f	f3 0f 11 55 d8	 movss	 DWORD PTR _mi2$1$[ebp], xmm2
  00084	76 10		 jbe	 SHORT $LN15@DetectColl
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00086	0f 28 c1	 movaps	 xmm0, xmm1

; 53   : 	_Left = _Move(_Right);

  00089	0f 28 ca	 movaps	 xmm1, xmm2
  0008c	f3 0f 11 4d dc	 movss	 DWORD PTR _mi1$2$[ebp], xmm1

; 54   : 	_Right = _Move(_Tmp);

  00091	f3 0f 11 45 d8	 movss	 DWORD PTR _mi2$1$[ebp], xmm0
$LN15@DetectColl:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 122  : 	if (mi1.y>mi2.y) std::swap(mi1.y,mi2.y);

  00096	f3 0f 10 4d ac	 movss	 xmm1, DWORD PTR _mi1$[ebp+4]
  0009b	f3 0f 10 75 f4	 movss	 xmm6, DWORD PTR _mi2$[ebp+4]
  000a0	0f 2f ce	 comiss	 xmm1, xmm6
  000a3	76 09		 jbe	 SHORT $LN23@DetectColl
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  000a5	0f 28 c1	 movaps	 xmm0, xmm1

; 53   : 	_Left = _Move(_Right);

  000a8	0f 28 ce	 movaps	 xmm1, xmm6

; 54   : 	_Right = _Move(_Tmp);

  000ab	0f 28 f0	 movaps	 xmm6, xmm0
$LN23@DetectColl:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 123  : 	if (mi1.z>mi2.z) std::swap(mi1.z,mi2.z);

  000ae	f3 0f 10 55 b0	 movss	 xmm2, DWORD PTR _mi1$[ebp+8]
  000b3	f3 0f 10 7d f8	 movss	 xmm7, DWORD PTR _mi2$[ebp+8]
  000b8	0f 2f d7	 comiss	 xmm2, xmm7
  000bb	76 09		 jbe	 SHORT $LN31@DetectColl
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  000bd	0f 28 c2	 movaps	 xmm0, xmm2

; 53   : 	_Left = _Move(_Right);

  000c0	0f 28 d7	 movaps	 xmm2, xmm7

; 54   : 	_Right = _Move(_Tmp);

  000c3	0f 28 f8	 movaps	 xmm7, xmm0
$LN31@DetectColl:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 124  : 	if (mi3.x>mi4.x) std::swap(mi3.x,mi4.x);

  000c6	f3 0f 10 6d c4	 movss	 xmm5, DWORD PTR _mi4$[ebp]
  000cb	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR _mi3$[ebp]
  000d0	0f 2f dd	 comiss	 xmm3, xmm5
  000d3	f3 0f 11 6d d4	 movss	 DWORD PTR _mi4$1$[ebp], xmm5
  000d8	76 0b		 jbe	 SHORT $LN39@DetectColl
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  000da	0f 28 c3	 movaps	 xmm0, xmm3

; 53   : 	_Left = _Move(_Right);

  000dd	0f 28 dd	 movaps	 xmm3, xmm5

; 54   : 	_Right = _Move(_Tmp);

  000e0	f3 0f 11 45 d4	 movss	 DWORD PTR _mi4$1$[ebp], xmm0
$LN39@DetectColl:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 125  : 	if (mi3.y>mi4.y) std::swap(mi3.y,mi4.y);

  000e5	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _mi4$[ebp+4]
  000ea	f3 0f 10 65 e8	 movss	 xmm4, DWORD PTR _mi3$[ebp+4]
  000ef	0f 2f e0	 comiss	 xmm4, xmm0
  000f2	f3 0f 11 45 e0	 movss	 DWORD PTR _mi4$3$[ebp], xmm0
  000f7	76 0d		 jbe	 SHORT $LN47@DetectColl
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  000f9	0f 28 c4	 movaps	 xmm0, xmm4

; 53   : 	_Left = _Move(_Right);

  000fc	f3 0f 10 65 c8	 movss	 xmm4, DWORD PTR _mi4$[ebp+4]

; 54   : 	_Right = _Move(_Tmp);

  00101	f3 0f 11 45 e0	 movss	 DWORD PTR _mi4$3$[ebp], xmm0
$LN47@DetectColl:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 126  : 	if (mi3.z>mi4.z) std::swap(mi3.z,mi4.z);

  00106	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _mi4$[ebp+8]
  0010b	f3 0f 10 6d ec	 movss	 xmm5, DWORD PTR _mi3$[ebp+8]
  00110	0f 2f e8	 comiss	 xmm5, xmm0
  00113	f3 0f 11 45 d0	 movss	 DWORD PTR _mi4$5$[ebp], xmm0
  00118	76 0d		 jbe	 SHORT $LN55@DetectColl
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  0011a	0f 28 c5	 movaps	 xmm0, xmm5

; 53   : 	_Left = _Move(_Right);

  0011d	f3 0f 10 6d cc	 movss	 xmm5, DWORD PTR _mi4$[ebp+8]

; 54   : 	_Right = _Move(_Tmp);

  00122	f3 0f 11 45 d0	 movss	 DWORD PTR _mi4$5$[ebp], xmm0
$LN55@DetectColl:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 127  : 	mi1.x -= c_rSphere1.fRadius; mi1.y -= c_rSphere1.fRadius; mi1.z -= c_rSphere1.fRadius;

  00127	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _mi1$2$[ebp]
  0012c	f3 0f 5c 41 18	 subss	 xmm0, DWORD PTR [ecx+24]
  00131	f3 0f 11 45 dc	 movss	 DWORD PTR _mi1$2$[ebp], xmm0
  00136	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
  0013b	f3 0f 5c d0	 subss	 xmm2, xmm0
  0013f	f3 0f 5c c8	 subss	 xmm1, xmm0
  00143	f3 0f 11 55 bc	 movss	 DWORD PTR _mi1$6$[ebp], xmm2

; 128  : 	mi2.x += c_rSphere1.fRadius; mi2.y += c_rSphere1.fRadius; mi2.z += c_rSphere1.fRadius;

  00148	0f 28 d0	 movaps	 xmm2, xmm0
  0014b	f3 0f 58 55 d8	 addss	 xmm2, DWORD PTR _mi2$1$[ebp]
  00150	f3 0f 11 55 d8	 movss	 DWORD PTR _mi2$2$[ebp], xmm2
  00155	0f 28 d0	 movaps	 xmm2, xmm0
  00158	f3 0f 58 d6	 addss	 xmm2, xmm6

; 129  : 	mi3.x -= c_rSphere2.fRadius; mi3.y -= c_rSphere2.fRadius; mi3.z -= c_rSphere2.fRadius;
; 130  : 	mi4.x += c_rSphere2.fRadius; mi4.y += c_rSphere2.fRadius; mi4.z += c_rSphere2.fRadius;
; 131  : 	if (mi4.x<mi1.x || mi2.x<mi3.x) return false;

  0015c	f3 0f 10 75 dc	 movss	 xmm6, DWORD PTR _mi1$2$[ebp]
  00161	f3 0f 58 c7	 addss	 xmm0, xmm7
  00165	f3 0f 10 7a 18	 movss	 xmm7, DWORD PTR [edx+24]
  0016a	f3 0f 5c df	 subss	 xmm3, xmm7
  0016e	f3 0f 5c e7	 subss	 xmm4, xmm7
  00172	f3 0f 5c ef	 subss	 xmm5, xmm7
  00176	f3 0f 11 55 c0	 movss	 DWORD PTR _mi2$4$[ebp], xmm2
  0017b	0f 28 d7	 movaps	 xmm2, xmm7
  0017e	f3 0f 58 55 e0	 addss	 xmm2, DWORD PTR _mi4$3$[ebp]
  00183	f3 0f 11 45 b4	 movss	 DWORD PTR _mi2$6$[ebp], xmm0
  00188	0f 28 c7	 movaps	 xmm0, xmm7
  0018b	f3 0f 58 45 d4	 addss	 xmm0, DWORD PTR _mi4$1$[ebp]
  00190	f3 0f 58 7d d0	 addss	 xmm7, DWORD PTR _mi4$5$[ebp]
  00195	f3 0f 11 55 e0	 movss	 DWORD PTR _mi4$4$[ebp], xmm2
  0019a	f3 0f 10 55 bc	 movss	 xmm2, DWORD PTR _mi1$6$[ebp]
  0019f	0f 2f f0	 comiss	 xmm6, xmm0
  001a2	0f 87 80 00 00
	00		 ja	 $LN5@DetectColl
  001a8	0f 2f 5d d8	 comiss	 xmm3, DWORD PTR _mi2$2$[ebp]
  001ac	77 7a		 ja	 SHORT $LN5@DetectColl

; 132  : 	if (mi4.y<mi1.y || mi2.y<mi3.y) return false;

  001ae	0f 2f 4d e0	 comiss	 xmm1, DWORD PTR _mi4$4$[ebp]
  001b2	77 74		 ja	 SHORT $LN5@DetectColl
  001b4	0f 2f 65 c0	 comiss	 xmm4, DWORD PTR _mi2$4$[ebp]
  001b8	77 6e		 ja	 SHORT $LN5@DetectColl

; 133  : 	if (mi4.z<mi1.z || mi2.z<mi3.z) return false;

  001ba	0f 2f d7	 comiss	 xmm2, xmm7
  001bd	77 69		 ja	 SHORT $LN5@DetectColl
  001bf	0f 2f 6d b4	 comiss	 xmm5, DWORD PTR _mi2$6$[ebp]
  001c3	77 63		 ja	 SHORT $LN5@DetectColl

; 144  : 		vA, vB);

  001c5	8d 45 f0	 lea	 eax, DWORD PTR _vB$[ebp]
  001c8	50		 push	 eax
  001c9	8d 45 e4	 lea	 eax, DWORD PTR _vA$[ebp]
  001cc	50		 push	 eax
  001cd	52		 push	 edx
  001ce	57		 push	 edi
  001cf	51		 push	 ecx
  001d0	56		 push	 esi
  001d1	e8 00 00 00 00	 call	 ?IntersectLineSegments@@YAXABUD3DXVECTOR3@@000AAU1@1@Z ; IntersectLineSegments
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001d6	f3 0f 10 4d e4	 movss	 xmm1, DWORD PTR _vA$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 144  : 		vA, vB);

  001db	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001de	f3 0f 10 55 e8	 movss	 xmm2, DWORD PTR _vA$[ebp+4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 145  : 	return (D3DXVec3LengthSq(&(vA-vB))<=rsq);

  001e3	33 c0		 xor	 eax, eax
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001e5	f3 0f 5c 55 f4	 subss	 xmm2, DWORD PTR _vB$[ebp+4]
  001ea	f3 0f 5c 4d f0	 subss	 xmm1, DWORD PTR _vB$[ebp]
  001ef	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _vA$[ebp+8]
  001f4	f3 0f 5c 45 f8	 subss	 xmm0, DWORD PTR _vB$[ebp+8]
  001f9	5f		 pop	 edi

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  001fa	f3 0f 59 d2	 mulss	 xmm2, xmm2
  001fe	5e		 pop	 esi
  001ff	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00203	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00207	f3 0f 58 d1	 addss	 xmm2, xmm1
  0020b	f3 0f 58 d0	 addss	 xmm2, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\gameutil.cpp

; 145  : 	return (D3DXVec3LengthSq(&(vA-vB))<=rsq);

  0020f	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _rsq$1$[ebp]
  00214	0f 2f c2	 comiss	 xmm0, xmm2
  00217	0f 93 c0	 setae	 al

; 146  : 	//*/
; 147  : 
; 148  : 	/*
; 149  : 	// NOTE : AABB 체크 할 것
; 150  : 	///////////////////////////////////////////////////////////////////////////////////////////////
; 151  : 	D3DXVECTOR3 v3Distance = c_rSphere1.v3Position - c_rSphere2.v3Position;
; 152  : 	float fDistance = D3DXVec3Length(&v3Distance);
; 153  : 	float fRadiusSummary = c_rSphere1.fRadius + c_rSphere2.fRadius;
; 154  : 
; 155  : 	if (fDistance < fRadiusSummary)
; 156  : 		return true;
; 157  : 
; 158  : 	///////////////////////////////////////////////////////////////////////////////////////////////
; 159  : 	D3DXVECTOR3 v3LastDistance = c_rSphere1.v3LastPosition - c_rSphere2.v3LastPosition; // A
; 160  : 	D3DXVECTOR3 v3Advance = c_rSphere1.v3Advance - c_rSphere2.v3Advance;                // B
; 161  : 
; 162  : 	float fdotAdvanceAdvance = D3DXVec3Dot(&v3Advance, &v3Advance);
; 163  : 	if (0.0f == fdotAdvanceAdvance)
; 164  : 		return false;
; 165  : 
; 166  : 	float fdotDistanceAdvance = D3DXVec3Dot(&v3LastDistance, &v3Advance);
; 167  : 	float fdotDistanceDistance = D3DXVec3Dot(&v3LastDistance, &v3LastDistance);
; 168  : 	float Value1 = fdotDistanceAdvance - fdotAdvanceAdvance * (fdotDistanceDistance - (fRadiusSummary * fRadiusSummary));
; 169  : 	if (Value1 < 0.0f)
; 170  : 		return false;
; 171  : 
; 172  : 	float Value2 = (-fdotDistanceAdvance - sqrtf(Value1)) / fdotAdvanceAdvance;
; 173  : 	if (Value2 < 0.0f)
; 174  : 		return false;
; 175  : 	if (Value2 >= 1.0f)
; 176  : 		return false;
; 177  : 
; 178  : 	return true;*/
; 179  : }

  0021a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021d	33 cd		 xor	 ecx, ebp
  0021f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00224	8b e5		 mov	 esp, ebp
  00226	5d		 pop	 ebp
  00227	c3		 ret	 0
$LN5@DetectColl:
  00228	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0022b	32 c0		 xor	 al, al
  0022d	5f		 pop	 edi
  0022e	33 cd		 xor	 ecx, ebp
  00230	5e		 pop	 esi
  00231	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00236	8b e5		 mov	 esp, ebp
  00238	5d		 pop	 ebp
  00239	c3		 ret	 0
?DetectCollisionDynamicSphereVSDynamicSphere@@YA_NABUCDynamicSphereInstance@@0@Z ENDP ; DetectCollisionDynamicSphereVSDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_pV1$ = 8						; size = 4
_pV2$ = 12						; size = 4
?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z PROC		; D3DXVec3Dot, COMDAT

; 1258 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pV1$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _pV2$[ebp]
  00009	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0000c	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0000f	d9 01		 fld	 DWORD PTR [ecx]
  00011	d8 08		 fmul	 DWORD PTR [eax]
  00013	de c1		 faddp	 ST(1), ST(0)
  00015	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00018	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0001b	de c1		 faddp	 ST(1), ST(0)

; 1265 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z ENDP		; D3DXVec3Dot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv160 = 8						; size = 4
_pV$ = 8						; size = 4
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z PROC		; D3DXVec3LengthSq, COMDAT

; 1247 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pV$[ebp]
  00006	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0000b	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0000f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00014	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00018	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0001c	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00020	f3 0f 58 d1	 addss	 xmm2, xmm1
  00024	f3 0f 58 d0	 addss	 xmm2, xmm0
  00028	f3 0f 11 55 08	 movss	 DWORD PTR tv160[ebp], xmm2
  0002d	d9 45 08	 fld	 DWORD PTR tv160[ebp]

; 1254 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3LengthSq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  0000a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0000d	f3 0f 5c 02	 subss	 xmm0, DWORD PTR [edx]

; 180  :     x = fx;

  00011	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00015	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001a	f3 0f 5c 42 04	 subss	 xmm0, DWORD PTR [edx+4]

; 181  :     y = fy;

  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00024	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00029	f3 0f 5c 42 08	 subss	 xmm0, DWORD PTR [edx+8]

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 264  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]

; 181  :     y = fy;
; 182  :     z = fz;
; 183  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT ?fmod@@YAMMM@Z
_TEXT	SEGMENT
tv66 = -8						; size = 8
tv65 = -8						; size = 8
tv81 = 8						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
?fmod@@YAMMM@Z PROC					; fmod, COMDAT

; 1078 :         {return (fmodf(_X, _Y)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 706  :     return (float)fmod(_X, _Y);

  0000b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000e	f2 0f 11 45 f8	 movsd	 QWORD PTR tv66[ebp], xmm0
  00013	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR __Y$[ebp]
  00018	dd 45 f8	 fld	 QWORD PTR tv66[ebp]
  0001b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0001e	f2 0f 11 45 f8	 movsd	 QWORD PTR tv65[ebp], xmm0
  00023	dd 45 f8	 fld	 QWORD PTR tv65[ebp]
  00026	e8 00 00 00 00	 call	 __CIfmod
  0002b	d9 5d 08	 fstp	 DWORD PTR tv81[ebp]
  0002e	d9 45 08	 fld	 DWORD PTR tv81[ebp]

; 1078 :         {return (fmodf(_X, _Y)); }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?fmod@@YAMMM@Z ENDP					; fmod
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT ?floor@@YAMM@Z
_TEXT	SEGMENT
tv71 = -8						; size = 8
tv75 = 8						; size = 4
__X$ = 8						; size = 4
?floor@@YAMM@Z PROC					; floor, COMDAT

; 1070 :         {return (floorf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 701  :     return (float)floor(_X);

  0000b	83 ec 08	 sub	 esp, 8
  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	f2 0f 11 45 f8	 movsd	 QWORD PTR tv71[ebp], xmm0
  00016	dd 45 f8	 fld	 QWORD PTR tv71[ebp]
  00019	dd 1c 24	 fstp	 QWORD PTR [esp]
  0001c	e8 00 00 00 00	 call	 _floor
  00021	d9 5d 08	 fstp	 DWORD PTR tv75[ebp]
  00024	d9 45 08	 fld	 DWORD PTR tv75[ebp]
  00027	83 c4 08	 add	 esp, 8

; 1070 :         {return (floorf(_X)); }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?floor@@YAMM@Z ENDP					; floor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT _fmodf
_TEXT	SEGMENT
tv75 = -8						; size = 8
tv70 = -8						; size = 8
tv81 = 8						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_fmodf	PROC						; COMDAT

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 706  :     return (float)fmod(_X, _Y);

  0000b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000e	f2 0f 11 45 f8	 movsd	 QWORD PTR tv70[ebp], xmm0
  00013	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR __Y$[ebp]
  00018	dd 45 f8	 fld	 QWORD PTR tv70[ebp]
  0001b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0001e	f2 0f 11 45 f8	 movsd	 QWORD PTR tv75[ebp], xmm0
  00023	dd 45 f8	 fld	 QWORD PTR tv75[ebp]
  00026	e8 00 00 00 00	 call	 __CIfmod
  0002b	d9 5d 08	 fstp	 DWORD PTR tv81[ebp]
  0002e	d9 45 08	 fld	 DWORD PTR tv81[ebp]

; 707  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
_fmodf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT _floorf
_TEXT	SEGMENT
tv69 = -8						; size = 8
tv75 = 8						; size = 4
__X$ = 8						; size = 4
_floorf	PROC						; COMDAT

; 700  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 701  :     return (float)floor(_X);

  0000b	83 ec 08	 sub	 esp, 8
  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	f2 0f 11 45 f8	 movsd	 QWORD PTR tv69[ebp], xmm0
  00016	dd 45 f8	 fld	 QWORD PTR tv69[ebp]
  00019	dd 1c 24	 fstp	 QWORD PTR [esp]
  0001c	e8 00 00 00 00	 call	 _floor
  00021	d9 5d 08	 fstp	 DWORD PTR tv75[ebp]
  00024	d9 45 08	 fld	 DWORD PTR tv75[ebp]
  00027	83 c4 08	 add	 esp, 8

; 702  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_floorf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT _acosf
_TEXT	SEGMENT
tv68 = 8						; size = 4
__X$ = 8						; size = 4
_acosf	PROC						; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 639  :     return (float)acos(_X);

  00008	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000b	e8 00 00 00 00	 call	 __libm_sse2_acos_precise
  00010	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00014	f3 0f 11 45 08	 movss	 DWORD PTR tv68[ebp], xmm0
  00019	d9 45 08	 fld	 DWORD PTR tv68[ebp]

; 640  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_acosf	ENDP
_TEXT	ENDS
END
