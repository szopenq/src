; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	A:\From C\Desktop\Serwer\Source\Source Client\client\GameLib\MapOutdoorWater.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ ; CSingleton<CTimer>::Instance
PUBLIC	?GetD3DVertexBuffer@CGraphicVertexBuffer@@QBEPAUIDirect3DVertexBuffer8@@XZ ; CGraphicVertexBuffer::GetD3DVertexBuffer
PUBLIC	?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ ; CSingleton<CStateManager>::Instance
PUBLIC	?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ ; CSingleton<CResourceManager>::Instance
PUBLIC	?IsWaterExist@CTerrainPatch@@QAE_NXZ		; CTerrainPatch::IsWaterExist
PUBLIC	?GetWaterVertexBufferPointer@CTerrainPatch@@QAEPAVCGraphicVertexBuffer@@XZ ; CTerrainPatch::GetWaterVertexBufferPointer
PUBLIC	?isUsed@CTerrainPatchProxy@@QAE_NXZ		; CTerrainPatchProxy::isUsed
PUBLIC	?isWaterExists@CTerrainPatchProxy@@QAE_NXZ	; CTerrainPatchProxy::isWaterExists
PUBLIC	?GetWaterVertexBufferPointer@CTerrainPatchProxy@@QAEPAVCGraphicVertexBuffer@@XZ ; CTerrainPatchProxy::GetWaterVertexBufferPointer
PUBLIC	?RenderWater@CMapOutdoor@@QAEXXZ		; CMapOutdoor::RenderWater
PUBLIC	?begin@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::begin
PUBLIC	?end@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::end
PUBLIC	?empty@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBE_NXZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::empty
PUBLIC	?DrawWater@CMapOutdoor@@IAEXJ@Z			; CMapOutdoor::DrawWater
PUBLIC	?LoadWaterTexture@CMapOutdoor@@IAEXXZ		; CMapOutdoor::LoadWaterTexture
PUBLIC	?UnloadWaterTexture@CMapOutdoor@@IAEXXZ		; CMapOutdoor::UnloadWaterTexture
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEABU?$pair@MJ@1@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEAAU?$pair@MJ@1@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator*
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEPAU?$pair@MJ@1@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator->
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator++
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@MJ@std@@@std@@SAPAU?$pair@MJ@2@AAU32@@Z ; std::pointer_traits<std::pair<float,long> *>::pointer_to
PUBLIC	??$addressof@U?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@AAU10@@Z ; std::addressof<std::pair<float,long> >
PUBLIC	?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	??_C@_0CE@FMFHOAGL@d?3?1ymir?5Work?1special?1water?1?$CF02d?4@ ; `string'
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_sprintf:PROC
EXTRN	?random_range@@YAJJJ@Z:PROC			; random_range
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	_D3DXMatrixScaling@16:PROC
EXTRN	?GetCurrentMillisecond@CTimer@@QAEKXZ:PROC	; CTimer::GetCurrentMillisecond
EXTRN	?ELTimer_GetMSec@@YAKXZ:PROC			; ELTimer_GetMSec
EXTRN	?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ:PROC ; CGraphicTexture::GetD3DTexture
EXTRN	?Destroy@CGraphicImageInstance@@QAEXXZ:PROC	; CGraphicImageInstance::Destroy
EXTRN	?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z:PROC ; CGraphicImageInstance::SetImagePointer
EXTRN	?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ:PROC ; CGraphicImageInstance::GetTexturePointer
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SaveTextureStageState
EXTRN	?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z:PROC ; CStateManager::RestoreTextureStageState
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SaveVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SaveVertexShader
EXTRN	?RestoreVertexShader@CStateManager@@QAEXXZ:PROC	; CStateManager::RestoreVertexShader
EXTRN	?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SaveTransform
EXTRN	?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z:PROC ; CStateManager::RestoreTransform
EXTRN	?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SetTransform
EXTRN	?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z:PROC ; CStateManager::SetStreamSource
EXTRN	?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z:PROC ; CStateManager::DrawPrimitive
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	?GetWaterFaceCount@CTerrainPatchProxy@@QAEIXZ:PROC ; CTerrainPatchProxy::GetWaterFaceCount
EXTRN	?IsVisiblePart@CMapOutdoor@@IAE_NH@Z:PROC	; CMapOutdoor::IsVisiblePart
EXTRN	?__GetFogDistance@CMapOutdoor@@IAEMXZ:PROC	; CMapOutdoor::__GetFogDistance
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?ms_faceCount@CGraphicBase@@1KA:DWORD		; CGraphicBase::ms_faceCount
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A DD 01H DUP (?) ; CSingleton<CTimer>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?s_fWaterHeightCurrent@?5??RenderWater@CMapOutdoor@@QAEXXZ@4MA
_BSS	SEGMENT
?s_fWaterHeightCurrent@?5??RenderWater@CMapOutdoor@@QAEXXZ@4MA DD 01H DUP (?) ; `CMapOutdoor::RenderWater'::`6'::s_fWaterHeightCurrent
_BSS	ENDS
;	COMDAT ?s_fWaterHeightBegin@?5??RenderWater@CMapOutdoor@@QAEXXZ@4MA
_BSS	SEGMENT
?s_fWaterHeightBegin@?5??RenderWater@CMapOutdoor@@QAEXXZ@4MA DD 01H DUP (?) ; `CMapOutdoor::RenderWater'::`6'::s_fWaterHeightBegin
_BSS	ENDS
;	COMDAT ?s_fWaterHeightEnd@?5??RenderWater@CMapOutdoor@@QAEXXZ@4MA
_BSS	SEGMENT
?s_fWaterHeightEnd@?5??RenderWater@CMapOutdoor@@QAEXXZ@4MA DD 01H DUP (?) ; `CMapOutdoor::RenderWater'::`6'::s_fWaterHeightEnd
_BSS	ENDS
;	COMDAT ?s_dwLastHeightChangeTime@?5??RenderWater@CMapOutdoor@@QAEXXZ@4KA
_BSS	SEGMENT
?s_dwLastHeightChangeTime@?5??RenderWater@CMapOutdoor@@QAEXXZ@4KA DD 01H DUP (?) ; `CMapOutdoor::RenderWater'::`6'::s_dwLastHeightChangeTime
_BSS	ENDS
;	COMDAT ?$S1@?5??RenderWater@CMapOutdoor@@QAEXXZ@4IA
_BSS	SEGMENT
?$S1@?5??RenderWater@CMapOutdoor@@QAEXXZ@4IA DD 01H DUP (?) ; `CMapOutdoor::RenderWater'::`6'::$S1
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT ?s_dwBlendtime@?5??RenderWater@CMapOutdoor@@QAEXXZ@4KA
_DATA	SEGMENT
?s_dwBlendtime@?5??RenderWater@CMapOutdoor@@QAEXXZ@4KA DD 012cH ; `CMapOutdoor::RenderWater'::`6'::s_dwBlendtime
_DATA	ENDS
;	COMDAT ??_C@_0CE@FMFHOAGL@d?3?1ymir?5Work?1special?1water?1?$CF02d?4@
CONST	SEGMENT
??_C@_0CE@FMFHOAGL@d?3?1ymir?5Work?1special?1water?1?$CF02d?4@ DB 'd:/ymi'
	DB	'r Work/special/water/%02d.dds', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RenderWater@CMapOutdoor@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RenderWater@CMapOutdoor@@QAEXXZ$0
__ehfuncinfo$?RenderWater@CMapOutdoor@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RenderWater@CMapOutdoor@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@AAU10@@Z PROC ; std::addressof<std::pair<float,long> >, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@AAU10@@Z ENDP ; std::addressof<std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@MJ@std@@@std@@SAPAU?$pair@MJ@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU?$pair@MJ@std@@@std@@SAPAU?$pair@MJ@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<float,long> *>::pointer_to, COMDAT

; 233  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 235  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU?$pair@MJ@std@@@std@@SAPAU?$pair@MJ@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<float,long> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator++, COMDAT
; _this$ = ecx

; 112  : 		++this->_Ptr;

  00000	83 01 08	 add	 DWORD PTR [ecx], 8

; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 336  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEPAU?$pair@MJ@1@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEPAU?$pair@MJ@1@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator->, COMDAT
; _this$ = ecx

; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 330  : 		}

  00002	c3		 ret	 0
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEPAU?$pair@MJ@1@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEAAU?$pair@MJ@1@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEAAU?$pair@MJ@1@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEAAU?$pair@MJ@1@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >, COMDAT
; _this$ = ecx

; 42   : 		{	// construct with null pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 301  : 		{	// construct with null vector pointer
; 302  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 211  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 206  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  00000	83 01 08	 add	 DWORD PTR [ecx], 8

; 113  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 114  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEABU?$pair@MJ@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEABU?$pair@MJ@1@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEABU?$pair@MJ@1@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >, COMDAT
; _this$ = ecx

; 42   : 		{	// construct with null pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 43   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp
;	COMDAT ?UnloadWaterTexture@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
?UnloadWaterTexture@CMapOutdoor@@IAEXXZ PROC		; CMapOutdoor::UnloadWaterTexture, COMDAT
; _this$ = ecx

; 20   : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 21   : 	for (int i = 0; i < 30; ++i)

  00002	8d b1 28 0a 00
	00		 lea	 esi, DWORD PTR [ecx+2600]
  00008	bf 1e 00 00 00	 mov	 edi, 30			; 0000001eH
  0000d	8d 49 00	 npad	 3
$LL3@UnloadWate:

; 22   : 		m_WaterInstances[i].Destroy();

  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?Destroy@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Destroy
  00017	83 c6 20	 add	 esi, 32			; 00000020H
  0001a	4f		 dec	 edi
  0001b	75 f3		 jne	 SHORT $LL3@UnloadWate

; 23   : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	c3		 ret	 0
?UnloadWaterTexture@CMapOutdoor@@IAEXXZ ENDP		; CMapOutdoor::UnloadWaterTexture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp
;	COMDAT ?LoadWaterTexture@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_buf$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
?LoadWaterTexture@CMapOutdoor@@IAEXXZ PROC		; CMapOutdoor::LoadWaterTexture, COMDAT
; _this$ = ecx

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b f9		 mov	 edi, ecx

; 10   : 	UnloadWaterTexture();

  00017	e8 00 00 00 00	 call	 ?UnloadWaterTexture@CMapOutdoor@@IAEXXZ ; CMapOutdoor::UnloadWaterTexture

; 11   : 	char buf[256];
; 12   : 	for (int i = 0; i < 30; ++i)

  0001c	33 f6		 xor	 esi, esi
  0001e	81 c7 28 0a 00
	00		 add	 edi, 2600		; 00000a28H
$LL3@LoadWaterT:

; 13   : 	{
; 14   : 		sprintf(buf, "d:/ymir Work/special/water/%02d.dds", i+1);

  00024	46		 inc	 esi
  00025	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0002b	56		 push	 esi
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@FMFHOAGL@d?3?1ymir?5Work?1special?1water?1?$CF02d?4@
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _sprintf

; 15   : 		m_WaterInstances[i].SetImagePointer((CGraphicImage *) CResourceManager::Instance().GetResourcePointer(buf));

  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  0003d	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  0004c	50		 push	 eax
  0004d	8b cf		 mov	 ecx, edi
  0004f	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer
  00054	83 c7 20	 add	 edi, 32			; 00000020H
  00057	83 fe 1e	 cmp	 esi, 30			; 0000001eH
  0005a	7c c8		 jl	 SHORT $LL3@LoadWaterT

; 16   : 	}
; 17   : }

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	5f		 pop	 edi
  00060	33 cd		 xor	 ecx, ebp
  00062	5e		 pop	 esi
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?LoadWaterTexture@CMapOutdoor@@IAEXXZ ENDP		; CMapOutdoor::LoadWaterTexture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp
;	COMDAT ?DrawWater@CMapOutdoor@@IAEXJ@Z
_TEXT	SEGMENT
_patchnum$ = 8						; size = 4
?DrawWater@CMapOutdoor@@IAEXJ@Z PROC			; CMapOutdoor::DrawWater, COMDAT
; _this$ = ecx

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 143  : 	assert(NULL!=m_pTerrainPatchProxyList);
; 144  : 	if (!m_pTerrainPatchProxyList)

  00003	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00006	85 d2		 test	 edx, edx
  00008	74 61		 je	 SHORT $LN7@DrawWater

; 145  : 		return;
; 146  : 
; 147  : 	CTerrainPatchProxy& rkTerrainPatchProxy = m_pTerrainPatchProxyList[patchnum];

  0000a	8b 45 08	 mov	 eax, DWORD PTR _patchnum$[ebp]
  0000d	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00014	2b c8		 sub	 ecx, eax

; 148  : 
; 149  : 	if (!rkTerrainPatchProxy.isUsed())

  00016	80 7c 8a 04 00	 cmp	 BYTE PTR [edx+ecx*4+4], 0
  0001b	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  0001e	74 4b		 je	 SHORT $LN7@DrawWater
  00020	56		 push	 esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 84   : 	bool IsWaterExist()										{ return m_bWaterExist; }

  00021	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp

; 152  : 	if (!rkTerrainPatchProxy.isWaterExists())

  00024	80 7e 19 00	 cmp	 BYTE PTR [esi+25], 0
  00028	74 40		 je	 SHORT $LN27@DrawWater
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 126  : 	CGraphicVertexBuffer* GetWaterVertexBufferPointer()	{ return &m_WaterVertexBuffer;}

  0002a	83 c6 24	 add	 esi, 36			; 00000024H
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp

; 156  : 	if (!pkVB)

  0002d	74 3b		 je	 SHORT $LN27@DrawWater

; 157  : 		return;
; 158  : 	
; 159  : 	if (!pkVB->GetD3DVertexBuffer())

  0002f	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00033	74 35		 je	 SHORT $LN27@DrawWater

; 160  : 		return;
; 161  : 
; 162  : 	UINT uPriCount=rkTerrainPatchProxy.GetWaterFaceCount();

  00035	57		 push	 edi
  00036	e8 00 00 00 00	 call	 ?GetWaterFaceCount@CTerrainPatchProxy@@QAEIXZ ; CTerrainPatchProxy::GetWaterFaceCount
  0003b	8b f8		 mov	 edi, eax

; 163  : 	if (!uPriCount)

  0003d	85 ff		 test	 edi, edi
  0003f	74 28		 je	 SHORT $LN28@DrawWater

; 164  : 		return;
; 165  : 	
; 166  : 	STATEMANAGER.SetStreamSource(0, pkVB->GetD3DVertexBuffer(), sizeof(SWaterVertex));

  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00047	6a 10		 push	 16			; 00000010H
  00049	ff 76 04	 push	 DWORD PTR [esi+4]
  0004c	6a 00		 push	 0
  0004e	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 167  : 	STATEMANAGER.DrawPrimitive(D3DPT_TRIANGLELIST, 0, uPriCount);

  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00059	57		 push	 edi
  0005a	6a 00		 push	 0
  0005c	6a 04		 push	 4
  0005e	e8 00 00 00 00	 call	 ?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z ; CStateManager::DrawPrimitive

; 168  : 
; 169  : 	ms_faceCount += uPriCount;

  00063	01 3d 00 00 00
	00		 add	 DWORD PTR ?ms_faceCount@CGraphicBase@@1KA, edi ; CGraphicBase::ms_faceCount
$LN28@DrawWater:
  00069	5f		 pop	 edi
$LN27@DrawWater:
  0006a	5e		 pop	 esi
$LN7@DrawWater:

; 170  : }

  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
?DrawWater@CMapOutdoor@@IAEXJ@Z ENDP			; CMapOutdoor::DrawWater
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?empty@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBE_NXZ PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBE_NXZ ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp
;	COMDAT ?RenderWater@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
_fFogDistance$ = -84					; size = 4
_matTexTransformWater$ = -80				; size = 64
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?RenderWater@CMapOutdoor@@QAEXXZ PROC			; CMapOutdoor::RenderWater, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RenderWater@CMapOutdoor@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  0002c	8b 87 18 01 00
	00		 mov	 eax, DWORD PTR [edi+280]
  00032	3b 87 1c 01 00
	00		 cmp	 eax, DWORD PTR [edi+284]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp

; 27   : 	if (m_PatchVector.empty())

  00038	0f 84 b9 04 00
	00		 je	 $LN15@RenderWate

; 28   : 		return;
; 29   : 
; 30   : 	if (!IsVisiblePart(PART_WATER))

  0003e	6a 03		 push	 3
  00040	e8 00 00 00 00	 call	 ?IsVisiblePart@CMapOutdoor@@IAE_NH@Z ; CMapOutdoor::IsVisiblePart
  00045	84 c0		 test	 al, al
  00047	0f 84 aa 04 00
	00		 je	 $LN15@RenderWate

; 31   : 		return;
; 32   : 
; 33   : 	//////////////////////////////////////////////////////////////////////////
; 34   : 	// RenderState
; 35   : 	D3DXMATRIX matTexTransformWater;
; 36   : 	
; 37   : 	STATEMANAGER.SaveRenderState(D3DRS_ZWRITEENABLE, FALSE);

  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00053	6a 00		 push	 0
  00055	6a 0e		 push	 14			; 0000000eH
  00057	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 38   : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00062	6a 01		 push	 1
  00064	6a 1b		 push	 27			; 0000001bH
  00066	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 39   : 	STATEMANAGER.SaveRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

  0006b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00071	6a 01		 push	 1
  00073	6a 16		 push	 22			; 00000016H
  00075	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 40   : 	STATEMANAGER.SaveRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);

  0007a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00080	6a 01		 push	 1
  00082	68 91 00 00 00	 push	 145			; 00000091H
  00087	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 41   : 	STATEMANAGER.SaveRenderState(D3DRS_COLORVERTEX, TRUE);

  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00092	6a 01		 push	 1
  00094	68 8d 00 00 00	 push	 141			; 0000008dH
  00099	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h

; 27   : 		return (*ms_singleton);

  0009e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp

; 43   : 	STATEMANAGER.SetTexture(0, m_WaterInstances[((ELTimer_GetMSec() / 70) % 30)].GetTexturePointer()->GetD3DTexture());

  000a4	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  000a9	8b c8		 mov	 ecx, eax
  000ab	b8 d5 41 1d d4	 mov	 eax, -736280107		; d41d41d5H
  000b0	f7 e1		 mul	 ecx
  000b2	2b ca		 sub	 ecx, edx
  000b4	d1 e9		 shr	 ecx, 1
  000b6	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  000b9	33 d2		 xor	 edx, edx
  000bb	c1 e8 06	 shr	 eax, 6
  000be	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  000c3	f7 f1		 div	 ecx
  000c5	8d 8f 28 0a 00
	00		 lea	 ecx, DWORD PTR [edi+2600]
  000cb	c1 e2 05	 shl	 edx, 5
  000ce	03 ca		 add	 ecx, edx
  000d0	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTexturePointer
  000d5	8b c8		 mov	 ecx, eax
  000d7	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  000dc	50		 push	 eax
  000dd	6a 00		 push	 0
  000df	8b ce		 mov	 ecx, esi
  000e1	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 44   : 
; 45   : 	D3DXMatrixScaling(&matTexTransformWater, m_fWaterTexCoordBase, -m_fWaterTexCoordBase, 0.0f);

  000e6	f3 0f 10 8f 0c
	09 00 00	 movss	 xmm1, DWORD PTR [edi+2316]
  000ee	8d 45 b0	 lea	 eax, DWORD PTR _matTexTransformWater$[ebp]
  000f1	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000f4	0f 28 c1	 movaps	 xmm0, xmm1
  000f7	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000fe	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR [esp+8], 0
  00106	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0010c	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 _D3DXMatrixScaling@16

; 46   : 	D3DXMatrixMultiply(&matTexTransformWater, &m_matViewInverse, &matTexTransformWater);

  00117	8d 45 b0	 lea	 eax, DWORD PTR _matTexTransformWater$[ebp]
  0011a	50		 push	 eax
  0011b	8d 87 88 07 00
	00		 lea	 eax, DWORD PTR [edi+1928]
  00121	50		 push	 eax
  00122	8d 45 b0	 lea	 eax, DWORD PTR _matTexTransformWater$[ebp]
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 47   : 	
; 48   : 	STATEMANAGER.SaveTransform(D3DTS_TEXTURE0, &matTexTransformWater);

  0012b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00131	8d 45 b0	 lea	 eax, DWORD PTR _matTexTransformWater$[ebp]
  00134	50		 push	 eax
  00135	6a 10		 push	 16			; 00000010H
  00137	e8 00 00 00 00	 call	 ?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SaveTransform

; 49   : 	STATEMANAGER.SaveVertexShader(D3DFVF_XYZ|D3DFVF_DIFFUSE);

  0013c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00142	6a 42		 push	 66			; 00000042H
  00144	e8 00 00 00 00	 call	 ?SaveVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SaveVertexShader

; 50   : 
; 51   : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION);

  00149	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0014f	68 00 00 02 00	 push	 131072			; 00020000H
  00154	6a 0b		 push	 11			; 0000000bH
  00156	6a 00		 push	 0
  00158	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 52   : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);

  0015d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00163	6a 02		 push	 2
  00165	6a 18		 push	 24			; 00000018H
  00167	6a 00		 push	 0
  00169	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 53   : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);

  0016e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00174	6a 02		 push	 2
  00176	6a 11		 push	 17			; 00000011H
  00178	6a 00		 push	 0
  0017a	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 54   : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);

  0017f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00185	6a 02		 push	 2
  00187	6a 10		 push	 16			; 00000010H
  00189	6a 00		 push	 0
  0018b	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 55   : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR);

  00190	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00196	6a 02		 push	 2
  00198	6a 12		 push	 18			; 00000012H
  0019a	6a 00		 push	 0
  0019c	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 56   : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);

  001a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001a7	6a 01		 push	 1
  001a9	6a 0d		 push	 13			; 0000000dH
  001ab	6a 00		 push	 0
  001ad	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 57   : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);

  001b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001b8	6a 01		 push	 1
  001ba	6a 0e		 push	 14			; 0000000eH
  001bc	6a 00		 push	 0
  001be	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 58   : 	
; 59   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  001c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001c9	6a 02		 push	 2
  001cb	6a 02		 push	 2
  001cd	6a 00		 push	 0
  001cf	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 60   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);

  001d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001da	6a 02		 push	 2
  001dc	6a 01		 push	 1
  001de	6a 00		 push	 0
  001e0	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 61   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);

  001e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001eb	6a 00		 push	 0
  001ed	6a 05		 push	 5
  001ef	6a 00		 push	 0
  001f1	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 62   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

  001f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001fc	6a 02		 push	 2
  001fe	6a 04		 push	 4
  00200	6a 00		 push	 0
  00202	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 63   : 	
; 64   : 
; 65   : 	STATEMANAGER.SetTexture(1,NULL);

  00207	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0020d	6a 00		 push	 0
  0020f	6a 01		 push	 1
  00211	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 66   : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);

  00216	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0021c	6a 01		 push	 1
  0021e	6a 01		 push	 1
  00220	6a 01		 push	 1
  00222	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 67   : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

  00227	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0022d	6a 01		 push	 1
  0022f	6a 04		 push	 4
  00231	6a 01		 push	 1
  00233	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 68   : 
; 69   : 	// RenderState
; 70   : 	//////////////////////////////////////////////////////////////////////////
; 71   : 
; 72   : 	//    ...
; 73   : 	static float s_fWaterHeightCurrent = 0;
; 74   : 	static float s_fWaterHeightBegin = 0;
; 75   : 	static float s_fWaterHeightEnd = 0;
; 76   : 	static DWORD s_dwLastHeightChangeTime = CTimer::Instance().GetCurrentMillisecond();

  00238	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?5??RenderWater@CMapOutdoor@@QAEXXZ@4IA
  0023d	a8 01		 test	 al, 1
  0023f	75 26		 jne	 SHORT $LN12@RenderWate
  00241	83 c8 01	 or	 eax, 1
  00244	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?5??RenderWater@CMapOutdoor@@QAEXXZ@4IA, eax
  00249	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  0024f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00256	e8 00 00 00 00	 call	 ?GetCurrentMillisecond@CTimer@@QAEKXZ ; CTimer::GetCurrentMillisecond
  0025b	a3 00 00 00 00	 mov	 DWORD PTR ?s_dwLastHeightChangeTime@?5??RenderWater@CMapOutdoor@@QAEXXZ@4KA, eax
  00260	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN12@RenderWate:

; 77   : 	static DWORD s_dwBlendtime = 300;
; 78   : 
; 79   : 	// 1.5  
; 80   : 	if ((CTimer::Instance().GetCurrentMillisecond() - s_dwLastHeightChangeTime) > s_dwBlendtime)

  00267	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  0026d	e8 00 00 00 00	 call	 ?GetCurrentMillisecond@CTimer@@QAEKXZ ; CTimer::GetCurrentMillisecond
  00272	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?s_dwLastHeightChangeTime@?5??RenderWater@CMapOutdoor@@QAEXXZ@4KA
  00278	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?s_dwBlendtime@?5??RenderWater@CMapOutdoor@@QAEXXZ@4KA
  0027e	76 74		 jbe	 SHORT $LN11@RenderWate

; 81   : 	{
; 82   : 		s_dwBlendtime = random_range(1000, 3000);

  00280	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  00285	68 e8 03 00 00	 push	 1000			; 000003e8H
  0028a	e8 00 00 00 00	 call	 ?random_range@@YAJJJ@Z	; random_range

; 83   : 
; 84   : 		if (s_fWaterHeightEnd == 0)

  0028f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?s_fWaterHeightEnd@?5??RenderWater@CMapOutdoor@@QAEXXZ@4MA
  00297	83 c4 08	 add	 esp, 8
  0029a	0f 57 c9	 xorps	 xmm1, xmm1
  0029d	a3 00 00 00 00	 mov	 DWORD PTR ?s_dwBlendtime@?5??RenderWater@CMapOutdoor@@QAEXXZ@4KA, eax
  002a2	0f 2e c1	 ucomiss xmm0, xmm1
  002a5	9f		 lahf
  002a6	f6 c4 44	 test	 ah, 68			; 00000044H
  002a9	7a 1f		 jp	 SHORT $LN10@RenderWate

; 85   : 			s_fWaterHeightEnd = -random_range(0, 15);

  002ab	6a 0f		 push	 15			; 0000000fH
  002ad	6a 00		 push	 0
  002af	e8 00 00 00 00	 call	 ?random_range@@YAJJJ@Z	; random_range
  002b4	83 c4 08	 add	 esp, 8
  002b7	f7 d8		 neg	 eax
  002b9	66 0f 6e c0	 movd	 xmm0, eax
  002bd	0f 5b c0	 cvtdq2ps xmm0, xmm0
  002c0	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?s_fWaterHeightEnd@?5??RenderWater@CMapOutdoor@@QAEXXZ@4MA, xmm0

; 86   : 		else

  002c8	eb 0a		 jmp	 SHORT $LN9@RenderWate
$LN10@RenderWate:

; 87   : 			s_fWaterHeightEnd = 0;

  002ca	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_fWaterHeightEnd@?5??RenderWater@CMapOutdoor@@QAEXXZ@4MA, 0
$LN9@RenderWate:

; 88   : 
; 89   : 		s_fWaterHeightBegin = s_fWaterHeightCurrent;

  002d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?s_fWaterHeightCurrent@?5??RenderWater@CMapOutdoor@@QAEXXZ@4MA

; 90   : 		s_dwLastHeightChangeTime = CTimer::Instance().GetCurrentMillisecond();

  002dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  002e2	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?s_fWaterHeightBegin@?5??RenderWater@CMapOutdoor@@QAEXXZ@4MA, xmm0
  002ea	e8 00 00 00 00	 call	 ?GetCurrentMillisecond@CTimer@@QAEKXZ ; CTimer::GetCurrentMillisecond
  002ef	a3 00 00 00 00	 mov	 DWORD PTR ?s_dwLastHeightChangeTime@?5??RenderWater@CMapOutdoor@@QAEXXZ@4KA, eax
$LN11@RenderWate:

; 91   : 	}
; 92   : 
; 93   : 	s_fWaterHeightCurrent = s_fWaterHeightBegin + (s_fWaterHeightEnd - s_fWaterHeightBegin) * (float) ((CTimer::Instance().GetCurrentMillisecond() - s_dwLastHeightChangeTime) / (float) s_dwBlendtime);

  002f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  002fa	e8 00 00 00 00	 call	 ?GetCurrentMillisecond@CTimer@@QAEKXZ ; CTimer::GetCurrentMillisecond
  002ff	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?s_dwLastHeightChangeTime@?5??RenderWater@CMapOutdoor@@QAEXXZ@4KA

; 94   : 	m_matWorldForCommonUse._43 = s_fWaterHeightCurrent;
; 95   : 
; 96   : 	m_matWorldForCommonUse._41 = 0.0f;

  00305	c7 87 78 07 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1912], 0

; 97   : 	m_matWorldForCommonUse._42 = 0.0f;

  0030f	c7 87 7c 07 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1916], 0
  00319	66 0f 6e c0	 movd	 xmm0, eax
  0031d	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00321	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00324	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0032d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_dwBlendtime@?5??RenderWater@CMapOutdoor@@QAEXXZ@4KA
  00332	66 0f 5a d0	 cvtpd2ps xmm2, xmm0
  00336	66 0f 6e c0	 movd	 xmm0, eax
  0033a	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0033e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00341	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 98   : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &m_matWorldForCommonUse);

  0034a	8d 87 48 07 00
	00		 lea	 eax, DWORD PTR [edi+1864]
  00350	50		 push	 eax
  00351	68 00 01 00 00	 push	 256			; 00000100H
  00356	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0035a	f3 0f 5e d0	 divss	 xmm2, xmm0
  0035e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?s_fWaterHeightEnd@?5??RenderWater@CMapOutdoor@@QAEXXZ@4MA
  00366	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR ?s_fWaterHeightBegin@?5??RenderWater@CMapOutdoor@@QAEXXZ@4MA
  0036e	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00372	f3 0f 58 15 00
	00 00 00	 addss	 xmm2, DWORD PTR ?s_fWaterHeightBegin@?5??RenderWater@CMapOutdoor@@QAEXXZ@4MA
  0037a	f3 0f 11 97 80
	07 00 00	 movss	 DWORD PTR [edi+1920], xmm2
  00382	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00388	f3 0f 11 15 00
	00 00 00	 movss	 DWORD PTR ?s_fWaterHeightCurrent@?5??RenderWater@CMapOutdoor@@QAEXXZ@4MA, xmm2
  00390	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 99   : 	
; 100  : 	float fFogDistance = __GetFogDistance();

  00395	8b cf		 mov	 ecx, edi
  00397	e8 00 00 00 00	 call	 ?__GetFogDistance@CMapOutdoor@@IAEMXZ ; CMapOutdoor::__GetFogDistance

; 104  : 	for(i = m_PatchVector.begin();i != m_PatchVector.end(); ++i)

  0039c	8b b7 18 01 00
	00		 mov	 esi, DWORD PTR [edi+280]
  003a2	d9 5d ac	 fstp	 DWORD PTR _fFogDistance$[ebp]
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  003a5	3b b7 1c 01 00
	00		 cmp	 esi, DWORD PTR [edi+284]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp

; 104  : 	for(i = m_PatchVector.begin();i != m_PatchVector.end(); ++i)

  003ab	74 24		 je	 SHORT $LN6@RenderWate
  003ad	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fFogDistance$[ebp]
$LL90@RenderWate:

; 105  : 	{
; 106  : 		if (i->first<fFogDistance)	

  003b2	0f 2f 06	 comiss	 xmm0, DWORD PTR [esi]
  003b5	76 0f		 jbe	 SHORT $LN7@RenderWate

; 107  : 			DrawWater(i->second);

  003b7	ff 76 04	 push	 DWORD PTR [esi+4]
  003ba	8b cf		 mov	 ecx, edi
  003bc	e8 00 00 00 00	 call	 ?DrawWater@CMapOutdoor@@IAEXJ@Z ; CMapOutdoor::DrawWater
  003c1	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fFogDistance$[ebp]
$LN7@RenderWate:
; File a:\vs\vc\include\vector

; 112  : 		++this->_Ptr;

  003c6	83 c6 08	 add	 esi, 8

; 205  : 		return (this->_Ptr == _Right._Ptr);

  003c9	3b b7 1c 01 00
	00		 cmp	 esi, DWORD PTR [edi+284]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp

; 104  : 	for(i = m_PatchVector.begin();i != m_PatchVector.end(); ++i)

  003cf	75 e1		 jne	 SHORT $LL90@RenderWate
$LN6@RenderWate:

; 108  : 	}
; 109  : 
; 110  : 	STATEMANAGER.SetTexture(0, NULL);

  003d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003d7	6a 00		 push	 0
  003d9	6a 00		 push	 0
  003db	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 111  : 	STATEMANAGER.SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);

  003e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003e6	6a 00		 push	 0
  003e8	6a 1b		 push	 27			; 0000001bH
  003ea	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 113  : 	for(i = m_PatchVector.begin();i != m_PatchVector.end(); ++i)

  003ef	8b b7 18 01 00
	00		 mov	 esi, DWORD PTR [edi+280]
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  003f5	3b b7 1c 01 00
	00		 cmp	 esi, DWORD PTR [edi+284]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp

; 113  : 	for(i = m_PatchVector.begin();i != m_PatchVector.end(); ++i)

  003fb	74 28		 je	 SHORT $LN2@RenderWate
  003fd	f3 0f 10 4d ac	 movss	 xmm1, DWORD PTR _fFogDistance$[ebp]
$LL140@RenderWate:

; 114  : 	{
; 115  : 		if (i->first>=fFogDistance)	

  00402	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00406	0f 2f c1	 comiss	 xmm0, xmm1
  00409	72 0f		 jb	 SHORT $LN3@RenderWate

; 116  : 			DrawWater(i->second);

  0040b	ff 76 04	 push	 DWORD PTR [esi+4]
  0040e	8b cf		 mov	 ecx, edi
  00410	e8 00 00 00 00	 call	 ?DrawWater@CMapOutdoor@@IAEXJ@Z ; CMapOutdoor::DrawWater
  00415	f3 0f 10 4d ac	 movss	 xmm1, DWORD PTR _fFogDistance$[ebp]
$LN3@RenderWate:
; File a:\vs\vc\include\vector

; 112  : 		++this->_Ptr;

  0041a	83 c6 08	 add	 esi, 8

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0041d	3b b7 1c 01 00
	00		 cmp	 esi, DWORD PTR [edi+284]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorwater.cpp

; 113  : 	for(i = m_PatchVector.begin();i != m_PatchVector.end(); ++i)

  00423	75 dd		 jne	 SHORT $LL140@RenderWate
$LN2@RenderWate:

; 117  : 	}
; 118  : 
; 119  : 	//     z  
; 120  : 	m_matWorldForCommonUse._43 = 0.0f;

  00425	c7 87 80 07 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1920], 0

; 121  : 
; 122  : 	//////////////////////////////////////////////////////////////////////////
; 123  : 	// RenderState
; 124  : 	STATEMANAGER.RestoreVertexShader();

  0042f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00435	e8 00 00 00 00	 call	 ?RestoreVertexShader@CStateManager@@QAEXXZ ; CStateManager::RestoreVertexShader

; 125  : 	STATEMANAGER.RestoreTransform(D3DTS_TEXTURE0);

  0043a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00440	6a 10		 push	 16			; 00000010H
  00442	e8 00 00 00 00	 call	 ?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z ; CStateManager::RestoreTransform

; 126  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_MINFILTER);

  00447	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0044d	6a 11		 push	 17			; 00000011H
  0044f	6a 00		 push	 0
  00451	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 127  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_MAGFILTER);

  00456	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0045c	6a 10		 push	 16			; 00000010H
  0045e	6a 00		 push	 0
  00460	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 128  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_MIPFILTER);

  00465	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0046b	6a 12		 push	 18			; 00000012H
  0046d	6a 00		 push	 0
  0046f	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 129  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_ADDRESSU);

  00474	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0047a	6a 0d		 push	 13			; 0000000dH
  0047c	6a 00		 push	 0
  0047e	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 130  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_ADDRESSV);

  00483	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00489	6a 0e		 push	 14			; 0000000eH
  0048b	6a 00		 push	 0
  0048d	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 131  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_TEXCOORDINDEX);

  00492	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00498	6a 0b		 push	 11			; 0000000bH
  0049a	6a 00		 push	 0
  0049c	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 132  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS);

  004a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004a7	6a 18		 push	 24			; 00000018H
  004a9	6a 00		 push	 0
  004ab	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 133  : 	
; 134  : 	STATEMANAGER.RestoreRenderState(D3DRS_DIFFUSEMATERIALSOURCE);

  004b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004b6	68 91 00 00 00	 push	 145			; 00000091H
  004bb	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 135  : 	STATEMANAGER.RestoreRenderState(D3DRS_COLORVERTEX);

  004c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004c6	68 8d 00 00 00	 push	 141			; 0000008dH
  004cb	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 136  : 	STATEMANAGER.RestoreRenderState(D3DRS_ZWRITEENABLE);

  004d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004d6	6a 0e		 push	 14			; 0000000eH
  004d8	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 137  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE);

  004dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004e3	6a 1b		 push	 27			; 0000001bH
  004e5	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 138  : 	STATEMANAGER.RestoreRenderState(D3DRS_CULLMODE);	

  004ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004f0	6a 16		 push	 22			; 00000016H
  004f2	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState
$LN15@RenderWate:

; 139  : }

  004f7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004fa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00501	59		 pop	 ecx
  00502	5f		 pop	 edi
  00503	5e		 pop	 esi
  00504	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00507	33 cd		 xor	 ecx, ebp
  00509	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0050e	8b e5		 mov	 esp, ebp
  00510	5d		 pop	 ebp
  00511	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RenderWater@CMapOutdoor@@QAEXXZ$0:
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?5??RenderWater@CMapOutdoor@@QAEXXZ@4IA
  00005	83 e0 fe	 and	 eax, -2			; fffffffeH
  00008	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?5??RenderWater@CMapOutdoor@@QAEXXZ@4IA, eax
  0000d	c3		 ret	 0
__ehhandler$?RenderWater@CMapOutdoor@@QAEXXZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RenderWater@CMapOutdoor@@QAEXXZ
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RenderWater@CMapOutdoor@@QAEXXZ ENDP			; CMapOutdoor::RenderWater
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetWaterVertexBufferPointer@CTerrainPatchProxy@@QAEPAVCGraphicVertexBuffer@@XZ
_TEXT	SEGMENT
?GetWaterVertexBufferPointer@CTerrainPatchProxy@@QAEPAVCGraphicVertexBuffer@@XZ PROC ; CTerrainPatchProxy::GetWaterVertexBufferPointer, COMDAT
; _this$ = ecx

; 126  : 	CGraphicVertexBuffer* GetWaterVertexBufferPointer()	{ return &m_WaterVertexBuffer;}

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	83 c0 24	 add	 eax, 36			; 00000024H

; 247  : 	return m_pTerrainPatch->GetWaterVertexBufferPointer();
; 248  : }

  00006	c3		 ret	 0
?GetWaterVertexBufferPointer@CTerrainPatchProxy@@QAEPAVCGraphicVertexBuffer@@XZ ENDP ; CTerrainPatchProxy::GetWaterVertexBufferPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?isWaterExists@CTerrainPatchProxy@@QAE_NXZ
_TEXT	SEGMENT
?isWaterExists@CTerrainPatchProxy@@QAE_NXZ PROC		; CTerrainPatchProxy::isWaterExists, COMDAT
; _this$ = ecx

; 212  : 	return m_pTerrainPatch->IsWaterExist();

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	8a 40 19	 mov	 al, BYTE PTR [eax+25]

; 213  : }

  00006	c3		 ret	 0
?isWaterExists@CTerrainPatchProxy@@QAE_NXZ ENDP		; CTerrainPatchProxy::isWaterExists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?isUsed@CTerrainPatchProxy@@QAE_NXZ
_TEXT	SEGMENT
?isUsed@CTerrainPatchProxy@@QAE_NXZ PROC		; CTerrainPatchProxy::isUsed, COMDAT
; _this$ = ecx

; 170  : 	bool isUsed()																	{ return m_bUsed; }

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	c3		 ret	 0
?isUsed@CTerrainPatchProxy@@QAE_NXZ ENDP		; CTerrainPatchProxy::isUsed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetWaterVertexBufferPointer@CTerrainPatch@@QAEPAVCGraphicVertexBuffer@@XZ
_TEXT	SEGMENT
?GetWaterVertexBufferPointer@CTerrainPatch@@QAEPAVCGraphicVertexBuffer@@XZ PROC ; CTerrainPatch::GetWaterVertexBufferPointer, COMDAT
; _this$ = ecx

; 126  : 	CGraphicVertexBuffer* GetWaterVertexBufferPointer()	{ return &m_WaterVertexBuffer;}

  00000	8d 41 24	 lea	 eax, DWORD PTR [ecx+36]
  00003	c3		 ret	 0
?GetWaterVertexBufferPointer@CTerrainPatch@@QAEPAVCGraphicVertexBuffer@@XZ ENDP ; CTerrainPatch::GetWaterVertexBufferPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?IsWaterExist@CTerrainPatch@@QAE_NXZ
_TEXT	SEGMENT
?IsWaterExist@CTerrainPatch@@QAE_NXZ PROC		; CTerrainPatch::IsWaterExist, COMDAT
; _this$ = ecx

; 84   : 	bool IsWaterExist()										{ return m_bWaterExist; }

  00000	8a 41 19	 mov	 al, BYTE PTR [ecx+25]
  00003	c3		 ret	 0
?IsWaterExist@CTerrainPatch@@QAE_NXZ ENDP		; CTerrainPatch::IsWaterExist
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ PROC ; CSingleton<CResourceManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ ENDP ; CSingleton<CResourceManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ PROC ; CSingleton<CStateManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ ENDP ; CSingleton<CStateManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpvertexbuffer.h
;	COMDAT ?GetD3DVertexBuffer@CGraphicVertexBuffer@@QBEPAUIDirect3DVertexBuffer8@@XZ
_TEXT	SEGMENT
?GetD3DVertexBuffer@CGraphicVertexBuffer@@QBEPAUIDirect3DVertexBuffer8@@XZ PROC ; CGraphicVertexBuffer::GetD3DVertexBuffer, COMDAT
; _this$ = ecx

; 33   : 		inline	LPDIRECT3DVERTEXBUFFER8 GetD3DVertexBuffer() const	{ return m_lpd3dVB; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetD3DVertexBuffer@CGraphicVertexBuffer@@QBEPAUIDirect3DVertexBuffer8@@XZ ENDP ; CGraphicVertexBuffer::GetD3DVertexBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ PROC	; CSingleton<CTimer>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ ENDP	; CSingleton<CTimer>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 177  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	4e		 dec	 esi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	57		 push	 edi
  0000f	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b cf		 mov	 ecx, edi
  00014	ff d3		 call	 ebx
  00016	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  00019	4e		 dec	 esi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5f		 pop	 edi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
